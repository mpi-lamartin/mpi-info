"use strict";(self.webpackChunkmpi_info=self.webpackChunkmpi_info||[]).push([[5764],{5776:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>a,metadata:()=>l,toc:()=>m});var t=n(4848),s=n(8453),r=n(688),o=n(1178);const a={title:"LeetCode 4 : Find Edges in Shortest Paths",authors:"qfortier",tags:["leetcode","devoir","programmation"]},d=void 0,l={permalink:"/mpi-info/2025/12/6/leetcode4",editUrl:"https://github.com/mpi-lamartin/mpi-info/blog/2025-12-6-leetcode4.mdx",source:"@site/blog/2025-12-6-leetcode4.mdx",title:"LeetCode 4 : Find Edges in Shortest Paths",description:"Exercice \xe0 faire en C sur LeetCode cette semaine//leetcode.com/problems/find-edges-in-shortest-paths/description/",date:"2025-12-06T00:00:00.000Z",tags:[{inline:!0,label:"leetcode",permalink:"/mpi-info/tags/leetcode"},{inline:!0,label:"devoir",permalink:"/mpi-info/tags/devoir"},{inline:!0,label:"programmation",permalink:"/mpi-info/tags/programmation"}],hasTruncateMarker:!1,authors:[{name:"Quentin Fortier",title:"Professeur d'informatique",url:"https://fortierq.github.io/",imageURL:"https://fortierq.github.io/assets/images/photo_cv.png",key:"qfortier",page:null}],frontMatter:{title:"LeetCode 4 : Find Edges in Shortest Paths",authors:"qfortier",tags:["leetcode","devoir","programmation"]},unlisted:!1,prevItem:{title:"Cours et TD 11/12",permalink:"/mpi-info/2025/12/11/cahier"},nextItem:{title:"TD 4/12",permalink:"/mpi-info/2025/12/4/cahier"}},c={authorsImageUrls:[void 0]},m=[];function g(e){const i={a:"a",p:"p",...(0,s.R)(),...e.components},{Details:n}=i;return n||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(i.p,{children:["Exercice \xe0 faire en C sur LeetCode cette semaine : ",(0,t.jsx)(i.a,{href:"https://leetcode.com/problems/find-edges-in-shortest-paths/description/",children:"https://leetcode.com/problems/find-edges-in-shortest-paths/description/"})]}),"\n",(0,t.jsx)(i.p,{children:"Il y a deux indices en bas de la page (Hint)."}),"\n",(0,t.jsx)(n,{children:(0,t.jsxs)(i.p,{children:[(0,t.jsx)("summary",{children:"Indice"}),"\nPour passer tous les tests, il faut impl\xe9menter l'algorithme de Dijkstra ce qui demande une file de priorit\xe9 (tas min) et est un peu long \xe0 impl\xe9menter... On pourrait impl\xe9menter Floyd-Warshall ou Bellman-Ford \xe0 la place."]})}),"\n","\n",(0,t.jsx)(r.A,{file:o.A,lang:"c",show:!0})]})}function p(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(g,{...e})}):g(e)}},688:(e,i,n)=>{n.d(i,{A:()=>l});n(6540);var t=n(1432),s=n(4164),r=n(3551),o=n(9893);const a="details_JMAC";var d=n(4848);const l=e=>{let{file:i,lang:n,show:l,title:c="Solution",children:m}=e;return(0,d.jsxs)("div",{children:[" ",l&&(0,d.jsxs)(r.B,{className:(0,s.A)("alert alert--success",a),summary:c,children:[m&&(0,d.jsx)(o.A,{children:m}),(0,d.jsx)(t.A,{language:n,children:i})]})]})}},1178:(e,i,n)=>{n.d(i,{A:()=>t});const t="#include <stdbool.h>\n\nint** createGraph(int n, int** edges, int edgesSize, int* edgesColSize) { // matrice d'adjacence\n    int **g = (int**)malloc(n * sizeof(int*));\n    for (int i = 0; i < n; i++) {\n        g[i] = (int*)malloc(n * sizeof(int));\n        for (int j = 0; j < n; j++)\n            g[i][j] = -1;\n    }\n    for (int i = 0; i < edgesSize; i++) {\n        int a = edges[i][0];\n        int b = edges[i][1];\n        int w = edges[i][2];\n        g[a][b] = w;\n        g[b][a] = w;\n    }\n    return g;\n}\n\nint** floydWarshall(int n, int** g) {\n    int** dist = (int**)malloc(n * sizeof(int*));\n    for (int i = 0; i < n; i++) {\n        dist[i] = (int*)malloc(n * sizeof(int));\n        for (int j = 0; j < n; j++) {\n            if (i == j)\n                dist[i][j] = 0;\n            else if (g[i][j] != -1)\n                dist[i][j] = g[i][j];\n            else\n                dist[i][j] = 1e9;\n        }\n    }\n    for (int k = 0; k < n; k++)\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                if (dist[i][k] + dist[k][j] < dist[i][j])\n                    dist[i][j] = dist[i][k] + dist[k][j];\n    return dist;\n}\n\nbool* findAnswer(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize) {\n    int** g = createGraph(n, edges, edgesSize, edgesColSize);\n    int** dist = floydWarshall(n, g);\n    bool* answer = (bool*)malloc(edgesSize * sizeof(bool));\n    for (int i = 0; i < edgesSize; i++) {\n        int a = edges[i][0];\n        int b = edges[i][1];\n        int w = edges[i][2];\n        if (dist[0][a] + w + dist[b][n - 1] == dist[0][n - 1] ||\n            dist[0][b] + w + dist[a][n - 1] == dist[0][n - 1])\n            answer[i] = true;\n        else\n            answer[i] = false;\n    }\n    *returnSize = edgesSize;\n    for (int i = 0; i < n; i++) {\n        free(g[i]);\n        free(dist[i]);\n    }\n    free(g);\n    free(dist);\n    return answer;\n}\n"}}]);