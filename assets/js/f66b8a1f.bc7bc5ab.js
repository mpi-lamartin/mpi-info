"use strict";(self.webpackChunkmpi_info=self.webpackChunkmpi_info||[]).push([[2379],{5156:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>u,default:()=>f,frontMatter:()=>l,metadata:()=>a,toc:()=>m});var i=t(4848),o=t(8453),r=t(688),s=t(8256);const l={title:"LeetCode 2 : Min Cost to Connect All Points",authors:"qfortier",tags:["leetcode","devoir","programmation"]},u=void 0,a={permalink:"/mpi-info/2025/11/3/leetcode2",editUrl:"https://github.com/mpi-lamartin/mpi-info/blog/2025-11-3-leetcode2.mdx",source:"@site/blog/2025-11-3-leetcode2.mdx",title:"LeetCode 2 : Min Cost to Connect All Points",description:"Exercice \xe0 faire en C sur LeetCode, avant lundi prochain//leetcode.com/problems/min-cost-to-connect-all-points",date:"2025-11-03T00:00:00.000Z",tags:[{inline:!0,label:"leetcode",permalink:"/mpi-info/tags/leetcode"},{inline:!0,label:"devoir",permalink:"/mpi-info/tags/devoir"},{inline:!0,label:"programmation",permalink:"/mpi-info/tags/programmation"}],hasTruncateMarker:!1,authors:[{name:"Quentin Fortier",title:"Professeur d'informatique",url:"https://fortierq.github.io/",imageURL:"https://fortierq.github.io/assets/images/photo_cv.png",key:"qfortier",page:null}],frontMatter:{title:"LeetCode 2 : Min Cost to Connect All Points",authors:"qfortier",tags:["leetcode","devoir","programmation"]},unlisted:!1,prevItem:{title:"Cours 3/11",permalink:"/mpi-info/2025/11/3/cahier"},nextItem:{title:"LeetCode 1 : Number of Islands",permalink:"/mpi-info/2025/10/18/leetcode1"}},d={authorsImageUrls:[void 0]},m=[];function p(n){const e={a:"a",code:"code",p:"p",pre:"pre",...(0,o.R)(),...n.components},{Details:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(e.p,{children:["Exercice \xe0 faire en C sur LeetCode, avant lundi prochain : ",(0,i.jsx)(e.a,{href:"https://leetcode.com/problems/min-cost-to-connect-all-points",children:"https://leetcode.com/problems/min-cost-to-connect-all-points"})]}),"\n",(0,i.jsxs)(t,{children:[(0,i.jsx)("summary",{children:"Indice"}),(0,i.jsx)(e.p,{children:"Utiliser l'algorithme de Kruskal sur le graphe dont les sommets sont les points et les ar\xeates sont les distances entre les points. Vous pouvez impl\xe9menter un tri fusion :"}),(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-c",children:"typedef struct {\n    int n; // nombre de sommets\n    int *degres; // degres[i] = nombre de voisins du sommet i\n    arete **aretes; // aretes[i] = tableau des aretes incidentes au sommet i\n} graphe;\n\narete a(int u, int v, int poids) {\n    arete e;\n    e.u = u;\n    e.v = v;\n    e.poids = poids;\n    return e;\n}\n\nvoid fusion(arete* t, int n, arete* t1, int n1, arete* t2, int n2) {\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < n1 && j < n2) {\n        if (t1[i].poids < t2[j].poids) {\n            t[k] = t1[i];\n            i++;\n        } else {\n            t[k] = t2[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        t[k] = t1[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        t[k] = t2[j];\n        j++;\n        k++;\n    }\n}\n\n// tri t de taille n entre les indices debut (inclus) et fin (exclus)\nvoid tri_fusion(arete* t, int n, int debut, int fin) {\n    if (fin - debut <= 1) {\n        return;\n    }\n    int milieu = (debut + fin) / 2;\n    tri_fusion(t, n, debut, milieu);\n    tri_fusion(t, n, milieu, fin);\n    arete* temp = malloc((fin - debut) * sizeof(arete));\n    fusion(temp, fin - debut, &t[debut], milieu - debut, &t[milieu], fin - milieu);\n    for (int i = debut; i < fin; i++) {\n        t[i] = temp[i - debut];\n    }\n    free(temp);\n}\n"})})]}),"\n","\n",(0,i.jsx)(r.A,{file:s.A,lang:"c",show:!0})]})}function f(n={}){const{wrapper:e}={...(0,o.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(p,{...n})}):p(n)}},688:(n,e,t)=>{t.d(e,{A:()=>a});t(6540);var i=t(1432),o=t(4164),r=t(3551),s=t(9893);const l="details_JMAC";var u=t(4848);const a=n=>{let{file:e,lang:t,show:a,title:d="Solution",children:m}=n;return(0,u.jsxs)("div",{children:[" ",a&&(0,u.jsxs)(r.B,{className:(0,o.A)("alert alert--success",l),summary:d,children:[m&&(0,u.jsx)(s.A,{children:m}),(0,u.jsx)(i.A,{language:t,children:e})]})]})}},8256:(n,e,t)=>{t.d(e,{A:()=>i});const i="typedef struct {\n    int u;\n    int v;\n    int poids;\n} arete;\n\ntypedef struct {\n    int n; // nombre de sommets\n    int *degres; // degres[i] = nombre de voisins du sommet i\n    arete **aretes; // aretes[i] = tableau des aretes incidentes au sommet i\n} graphe;\n\narete a(int u, int v, int poids) {\n    arete e;\n    e.u = u;\n    e.v = v;\n    e.poids = poids;\n    return e;\n}\n\ntypedef struct {\n  int n; // nombre d'\xe9lements\n  int* t; // t[i] = p\xe8re de i\n} uf;\n\nuf* create(int n) {\n    uf* u = malloc(sizeof(uf));\n    u->n = n;\n    u->t = malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        u->t[i] = -1;\n    }\n    return u;\n}\n\nint find(uf* u, int x) {\n    if (u->t[x] < 0) {\n        return x;\n    } else {\n        int r = find(u, u->t[x]);\n        u->t[x] = r;\n        return r;\n    }\n}\n\nvoid merge(uf* u, int x, int y) {\n    int rx = find(u, x);\n    int ry = find(u, y);\n    if (rx < ry) u->t[ry] = rx;\n    else if (rx > ry) u->t[rx] = ry;\n    else {\n        u->t[ry] = rx;\n        u->t[rx]--;\n    }\n}\n\nvoid fusion(arete* t, int n, arete* t1, int n1, arete* t2, int n2) {\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < n1 && j < n2) {\n        if (t1[i].poids < t2[j].poids) {\n            t[k] = t1[i];\n            i++;\n        } else {\n            t[k] = t2[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        t[k] = t1[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        t[k] = t2[j];\n        j++;\n        k++;\n    }\n}\n\nvoid tri_fusion(arete* t, int n, int debut, int fin) {\n    if (fin - debut <= 1) {\n        return;\n    }\n    int milieu = (debut + fin) / 2;\n    tri_fusion(t, n, debut, milieu);\n    tri_fusion(t, n, milieu, fin);\n    arete* temp = malloc((fin - debut) * sizeof(arete));\n    fusion(temp, fin - debut, &t[debut], milieu - debut, &t[milieu], fin - milieu);\n    for (int i = debut; i < fin; i++) {\n        t[i] = temp[i - debut];\n    }\n    free(temp);\n}\n\nint minCostConnectPoints(int** points, int pointsSize, int* pointsColSize) {\n    arete* t = malloc(pointsSize * (pointsSize - 1) / 2 * sizeof(arete));\n    int k = 0;\n    for (int i = 0; i < pointsSize; i++) {\n        for (int j = i + 1; j < pointsSize; j++) {\n            t[k] = a(i, j, abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]));\n            k++;\n        }\n    }\n    tri_fusion(t, pointsSize * (pointsSize - 1) / 2, 0, pointsSize * (pointsSize - 1) / 2);\n    uf* u = create(pointsSize);\n    int res = 0;\n    for (int i = 0; i < pointsSize * (pointsSize - 1) / 2; i++) {\n        if (find(u, t[i].u) != find(u, t[i].v)) {\n            res += t[i].poids;\n            merge(u, t[i].u, t[i].v);\n        }\n    }\n    free(u->t);\n    free(u);\n    free(t);\n    return res;\n}\n"}}]);