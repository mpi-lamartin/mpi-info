"use strict";(self.webpackChunkmpi_info=self.webpackChunkmpi_info||[]).push([[4951],{27332:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>m});var t=n(28449),s=n(74848),r=n(28453),o=n(30688),a=n(1178);const l={title:"LeetCode 4 : Find Edges in Shortest Paths",authors:"qfortier",tags:["leetcode","devoir","programmation"]},d=void 0,c={authorsImageUrls:[void 0]},m=[];function f(e){const i={a:"a",p:"p",...(0,r.R)(),...e.components},{Details:n}=i;return n||function(e,i){throw new Error("Expected "+(i?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(i.p,{children:["Exercice \xe0 faire en C sur LeetCode cette semaine : ",(0,s.jsx)(i.a,{href:"https://leetcode.com/problems/find-edges-in-shortest-paths/description/",children:"https://leetcode.com/problems/find-edges-in-shortest-paths/description/"})]}),"\n",(0,s.jsx)(i.p,{children:"Il y a deux indices en bas de la page (Hint)."}),"\n",(0,s.jsx)(n,{children:(0,s.jsxs)(i.p,{children:[(0,s.jsx)("summary",{children:"Indice"}),"\nPour passer tous les tests, il faut impl\xe9menter l'algorithme de Dijkstra ce\nqui demande une file de priorit\xe9 (tas min) et est un peu long \xe0 impl\xe9menter...\nOn pourrait impl\xe9menter Floyd-Warshall ou Bellman-Ford \xe0 la place."]})}),"\n","\n",(0,s.jsx)(o.A,{file:a.A,lang:"c",show:!0})]})}function p(e={}){const{wrapper:i}={...(0,r.R)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(f,{...e})}):f(e)}},30688:(e,i,n)=>{n.d(i,{A:()=>d});n(96540);var t=n(83457),s=n(34164),r=n(83551),o=n(6622);const a="details_JMAC";var l=n(74848);const d=({file:e,lang:i,show:n,title:d="Solution",children:c})=>(0,l.jsxs)("div",{children:[" ",n&&(0,l.jsxs)(r.B,{className:(0,s.A)("alert alert--success",a),summary:d,children:[c&&(0,l.jsx)(o.A,{children:c}),(0,l.jsx)(t.A,{language:i,children:e})]})]})},1178:(e,i,n)=>{n.d(i,{A:()=>t});const t="#include <stdbool.h>\n\nint** createGraph(int n, int** edges, int edgesSize, int* edgesColSize) { // matrice d'adjacence\n    int **g = (int**)malloc(n * sizeof(int*));\n    for (int i = 0; i < n; i++) {\n        g[i] = (int*)malloc(n * sizeof(int));\n        for (int j = 0; j < n; j++)\n            g[i][j] = -1;\n    }\n    for (int i = 0; i < edgesSize; i++) {\n        int a = edges[i][0];\n        int b = edges[i][1];\n        int w = edges[i][2];\n        g[a][b] = w;\n        g[b][a] = w;\n    }\n    return g;\n}\n\nint** floydWarshall(int n, int** g) {\n    int** dist = (int**)malloc(n * sizeof(int*));\n    for (int i = 0; i < n; i++) {\n        dist[i] = (int*)malloc(n * sizeof(int));\n        for (int j = 0; j < n; j++) {\n            if (i == j)\n                dist[i][j] = 0;\n            else if (g[i][j] != -1)\n                dist[i][j] = g[i][j];\n            else\n                dist[i][j] = 1e9;\n        }\n    }\n    for (int k = 0; k < n; k++)\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                if (dist[i][k] + dist[k][j] < dist[i][j])\n                    dist[i][j] = dist[i][k] + dist[k][j];\n    return dist;\n}\n\nbool* findAnswer(int n, int** edges, int edgesSize, int* edgesColSize, int* returnSize) {\n    int** g = createGraph(n, edges, edgesSize, edgesColSize);\n    int** dist = floydWarshall(n, g);\n    bool* answer = (bool*)malloc(edgesSize * sizeof(bool));\n    for (int i = 0; i < edgesSize; i++) {\n        int a = edges[i][0];\n        int b = edges[i][1];\n        int w = edges[i][2];\n        if (dist[0][a] + w + dist[b][n - 1] == dist[0][n - 1] ||\n            dist[0][b] + w + dist[a][n - 1] == dist[0][n - 1])\n            answer[i] = true;\n        else\n            answer[i] = false;\n    }\n    *returnSize = edgesSize;\n    for (int i = 0; i < n; i++) {\n        free(g[i]);\n        free(dist[i]);\n    }\n    free(g);\n    free(dist);\n    return answer;\n}\n"},28449:e=>{e.exports=JSON.parse('{"permalink":"/mpi-info/2025/12/6/leetcode4","editUrl":"https://github.com/mpi-lamartin/mpi-info/blog/2025-12-6-leetcode4.mdx","source":"@site/blog/2025-12-6-leetcode4.mdx","title":"LeetCode 4 : Find Edges in Shortest Paths","description":"Exercice \xe0 faire en C sur LeetCode cette semaine//leetcode.com/problems/find-edges-in-shortest-paths/description/","date":"2025-12-06T00:00:00.000Z","tags":[{"inline":false,"label":"LeetCode","permalink":"/mpi-info/tags/leetcode"},{"inline":false,"label":"Devoir","permalink":"/mpi-info/tags/devoir"},{"inline":false,"label":"Programmation","permalink":"/mpi-info/tags/programmation"}],"hasTruncateMarker":false,"authors":[{"name":"Quentin Fortier","title":"Professeur d\'informatique","url":"https://fortierq.github.io/","imageURL":"https://fortierq.github.io/assets/images/photo_cv.png","key":"qfortier","page":null}],"frontMatter":{"title":"LeetCode 4 : Find Edges in Shortest Paths","authors":"qfortier","tags":["leetcode","devoir","programmation"]},"unlisted":false,"prevItem":{"title":"Cours et TD 11/12","permalink":"/mpi-info/2025/12/11/cahier"},"nextItem":{"title":"TD 4/12","permalink":"/mpi-info/2025/12/4/cahier"}}')}}]);