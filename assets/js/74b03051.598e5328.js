"use strict";(self.webpackChunkmpi_info=self.webpackChunkmpi_info||[]).push([[3079],{4767:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>a,metadata:()=>d,toc:()=>p});var r=i(4848),t=i(8453),s=i(688),o=i(2824);const a={title:"LeetCode 3",authors:"qfortier",tags:["leetcode","devoir","programmation"]},l=void 0,d={permalink:"/mpi-info/2024/09/21/leetcode3",editUrl:"https://github.com/mpi-lamartin/mpi-info/blog/2024-09-21-leetcode3.mdx",source:"@site/blog/2024-09-21-leetcode3.mdx",title:"LeetCode 3",description:"Exercice \xe0 faire en C sur LeetCode, au plus tard pour samedi prochain//leetcode.com/problems/number-of-islands",date:"2024-09-21T00:00:00.000Z",tags:[{inline:!0,label:"leetcode",permalink:"/mpi-info/tags/leetcode"},{inline:!0,label:"devoir",permalink:"/mpi-info/tags/devoir"},{inline:!0,label:"programmation",permalink:"/mpi-info/tags/programmation"}],hasTruncateMarker:!1,authors:[{name:"Quentin Fortier",title:"Professeur d'informatique",url:"https://fortierq.github.io/",imageURL:"https://fortierq.github.io/assets/images/photo_cv.png",key:"qfortier",page:null}],frontMatter:{title:"LeetCode 3",authors:"qfortier",tags:["leetcode","devoir","programmation"]},unlisted:!1,prevItem:{title:"LeetCode 4",permalink:"/mpi-info/2024/09/29/leetcode4"},nextItem:{title:"Exercices de programmation et automates",permalink:"/mpi-info/2024/09/19/exercices"}},c={authorsImageUrls:[void 0]},p=[];function u(e){const n={a:"a",br:"br",code:"code",p:"p",pre:"pre",...(0,t.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["Exercice \xe0 faire en C sur LeetCode, au plus tard pour samedi prochain : ",(0,r.jsx)(n.a,{href:"https://leetcode.com/problems/number-of-islands",children:"https://leetcode.com/problems/number-of-islands"})]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)("summary",{children:"Indice"}),(0,r.jsxs)(n.p,{children:["Cela revient \xe0 calculer les composantes connexes du graphe dont les sommets sont les cases de la grille et o\xf9 chaque case a 4 ar\xeates possibles avec les cases voisines.",(0,r.jsx)(n.br,{}),"\n","Pour calculer le nombre de composantes connexes, on peut utiliser un parcours en profondeur (ou en largeur). On peut directement utiliser ",(0,r.jsx)(n.code,{children:"grid"})," comme tableau des vus (en mettant une case \xe0 '0' apr\xe8s l'avoir visit\xe9e)."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-c",children:"// Parcours en profondeur depuis la case (i, j)\nvoid dfs(char** grid, int n, int p, int i, int j) {\n    ...\n}\n\nint numIslands(char** grid, int gridSize, int* gridColSize) {\n    int n = gridSize, p = gridColSize[0]; // n lignes, p colonnes\n    int k = 0; // nombre de composantes connexes\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < p; j++)\n            ...\n    return k;\n}\n"})}),(0,r.jsxs)(n.p,{children:["Si besoin, vous pouvez revoir ",(0,r.jsx)(n.a,{href:"https://mp2i-info.github.io/6_graph/3_traversal/3_traversal",children:"le cours de 1\xe8re ann\xe9e"}),"."]})]}),"\n","\n",(0,r.jsx)(s.A,{file:o.A,lang:"c",show:!0})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},688:(e,n,i)=>{i.d(n,{A:()=>d});i(6540);var r=i(1432),t=i(4164),s=i(3551),o=i(9893);const a="details_JMAC";var l=i(4848);const d=e=>{let{file:n,lang:i,show:d,children:c}=e;return(0,l.jsxs)("div",{children:[" ",d&&(0,l.jsxs)(s.B,{className:(0,t.A)("alert alert--success",a),summary:"Solution",children:[c&&(0,l.jsx)(o.A,{children:c}),(0,l.jsx)(r.A,{language:i,children:n})]})]})}},2824:(e,n,i)=>{i.d(n,{A:()=>r});const r="// Solution en O(l) avec un parcours en profondeur, o\xf9 l = np est le nombre de cases de la grille\n// Plut\xf4t qu'utiliser une matrice de bool\xe9ens vus, on peut mettre les cases visit\xe9es \xe0 0 pour \xe9viter de les revisiter\n\nvoid dfs(char** grid, int n, int p, int i, int j) {\n    if(grid[i][j] == '0') return;\n    grid[i][j] = '0';\n    if(i > 0) // chaque sommet a 4 voisins\n        dfs(grid, n, p, i - 1, j);\n    if(i < n - 1)\n        dfs(grid, n, p, i + 1, j);\n    if(j > 0)\n        dfs(grid, n, p, i, j - 1);\n    if(j < p - 1)\n        dfs(grid, n, p, i, j + 1);\n}\n\nint numIslands(char** grid, int gridSize, int* gridColSize) {\n    int n = gridSize, p = gridColSize[0];\n    int k = 0;\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < p; j++)\n            if(grid[i][j] == '1') {\n                dfs(grid, n, p, i, j);\n                k++;\n            }\n    return k;\n}\n"}}]);