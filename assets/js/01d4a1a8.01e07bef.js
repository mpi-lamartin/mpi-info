"use strict";(self.webpackChunkmpi_info=self.webpackChunkmpi_info||[]).push([[8851],{79696:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>x,contentTitle:()=>f,default:()=>v,frontMatter:()=>h,metadata:()=>r,toc:()=>b});const r=JSON.parse('{"id":"revisions/qcm_revisions","title":"QCM R\xe9visions","description":"<QCMRandom","source":"@site/docs/revisions/qcm_revisions.mdx","sourceDirName":"revisions","slug":"/revisions/qcm_revisions","permalink":"/mpi-info/docs/revisions/qcm_revisions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"hide_title":true,"title":"QCM R\xe9visions","sidebar_position":1},"sidebar":"revisions"}');var s=t(74848),a=t(28453),i=t(96540);const o={container:"container_v_Cp",title:"title_iefr",progressBar:"progressBar_UTOv",progressFill:"progressFill_DR_K",progressLabel:"progressLabel_Ar5z",questionCard:"questionCard_G5Y9",questionText:"questionText_Y8Ol",answers:"answers_ryeS",answer:"answer_AdNj",correct:"correct_vIDz",incorrect:"incorrect_et5a",answerText:"answerText_j0O0",selected:"selected_uLoI",missed:"missed_RMLl",multiHint:"multiHint_saEV",answerBtn:"answerBtn_euw1",answerContent:"answerContent_sivg",answerMark:"answerMark_nf9s",explanation:"explanation_QIHP",actions:"actions_UIPF",btnPrimary:"btnPrimary_ZI0M",btnSecondary:"btnSecondary_Dodb",finalScore:"finalScore_K998",scoreText:"scoreText_VHOs"};var u=t(22130),l=t(86025),c=t(71765);function p(e){return Array.isArray(e)}function m(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function d(e,n){const t=[];let r=e.replace(/```([a-zA-Z0-9_-]+)?\n([\s\S]*?)```/g,((e,n,r)=>{const s=n||"text",a=c.My.languages[s]||c.My.languages.markup;let i=r;try{i=c.My.highlight(r,a,s)}catch{i=m(r)}const o=`<pre class="prism-code language-${s}" style="margin:6px 0;"><code class="language-${s}">${i}</code></pre>`,u=`@@CODEBLOCK_${t.length}@@`;return t.push(o),u}));return r=r.replace(/\$\$([^$]+)\$\$/g,((e,n)=>{try{return u.A.renderToString(n,{throwOnError:!1,displayMode:!0})}catch{return`$$${n}$$`}})),r=r.replace(/\$([^$]+)\$/g,((e,n)=>{try{return u.A.renderToString(n,{throwOnError:!1,displayMode:!1})}catch{return`$${n}$`}})),r=r.replace(/`([^`]+)`/g,((e,n)=>`<code>${m(n)}</code>`)),r=r.replace(/\n/g,"<br>"),r=r.replace(/src='\/([^']+)'/g,((e,t)=>`src='${n}${t}'`)),r=r.replace(/src="\/([^"]+)"/g,((e,t)=>`src="${n}${t}"`)),r=r.replace(/@@CODEBLOCK_(\d+)@@/g,((e,n)=>t[Number(n)])),r}function $({text:e}){const n=(0,l.Ay)("/");return(0,s.jsx)("span",{dangerouslySetInnerHTML:{__html:d(e,n)}})}function g({questions:e,title:n="QCM Algorithmes",repoOwner:t="mpi-lamartin",repoName:r="mpi-info"}){const[a]=(0,i.useState)((()=>function(e){const n=[...e];for(let t=n.length-1;t>0;t--){const e=Math.floor(Math.random()*(t+1));[n[t],n[e]]=[n[e],n[t]]}return n}(e.map(((e,n)=>n))))),[u,l]=(0,i.useState)(0),[c,m]=(0,i.useState)(new Set),[d,g]=(0,i.useState)(!1),[h,f]=(0,i.useState)(0),[x,b]=(0,i.useState)(0),[q,v]=(0,i.useState)(!1),_=e[a[u]],L=(P=_.correct,new Set(p(P)?P:[P]));var P;const w=p(_.correct),C=!w,y=e=>{g(!0),b((e=>e+1)),(e=>{if(e.size!==L.size)return!1;let n=!0;return L.forEach((t=>{e.has(t)||(n=!1)})),n})(e)&&f((e=>e+1))},S=()=>{y(c)},T=()=>{u+1>=a.length?v(!0):(l((e=>e+1)),m(new Set),g(!1))},N=x>0?Math.round(h/x*100):0;return(0,i.useEffect)((()=>{const e=e=>{if((e.ctrlKey||e.metaKey)&&"Enter"===e.key&&!q){if(d)return T(),void e.preventDefault();S(),e.preventDefault()}};return window.addEventListener("keydown",e),()=>window.removeEventListener("keydown",e)}),[q,d,C,c]),q?(0,s.jsx)("div",{className:o.container,children:(0,s.jsxs)("div",{className:o.finalScore,children:[(0,s.jsx)("p",{children:"QCM termin\xe9 !"}),(0,s.jsxs)("p",{className:o.scoreText,children:["Score final :"," ",(0,s.jsxs)("strong",{children:[h,"/",x]})," ","(",N,"%)"]})]})}):(0,s.jsxs)("div",{className:o.container,children:[(0,s.jsx)("div",{className:o.progressBar,children:(0,s.jsx)("div",{className:o.progressFill,style:{width:(u+1)/a.length*100+"%"}})}),(0,s.jsxs)("div",{className:o.progressLabel,children:["Question ",u+1," / ",a.length," \xa0\u2014\xa0 Score :"," ",h,"/",x," (",N,"%)"]}),(0,s.jsxs)("div",{className:o.questionCard,children:[(0,s.jsxs)("div",{className:o.questionText,children:[(0,s.jsx)($,{text:_.question}),w&&(0,s.jsxs)("span",{className:o.multiHint,children:[" ","(plusieurs r\xe9ponses possibles)"]})]}),(0,s.jsx)("div",{className:o.answers,children:_.answers.map(((e,n)=>{const t=c.has(n),r=L.has(n),a=d&&t?r?"\u2705":"\u274c":null;let i=o.answerBtn;return d?r?i=`${o.answerBtn} ${o.correct}`:t&&(i=`${o.answerBtn} ${o.incorrect}`):t&&(i=`${o.answerBtn} ${o.selected}`),(0,s.jsxs)("button",{className:i,onClick:()=>(e=>{if(!d)if(w){const n=new Set(c);n.has(e)?n.delete(e):n.add(e),m(n)}else{const n=new Set([e]);m(n),y(n)}})(n),disabled:d,children:[(0,s.jsx)("span",{className:o.answerContent,children:(0,s.jsx)($,{text:e})}),a&&(0,s.jsx)("span",{className:o.answerMark,children:a})]},n)}))}),d&&_.explanation&&(0,s.jsxs)("div",{className:o.explanation,children:[(0,s.jsx)("strong",{children:"Explication :"})," ",(0,s.jsx)("br",{}),(0,s.jsx)($,{text:_.explanation})]})]}),(0,s.jsxs)("div",{className:o.actions,children:[(0,s.jsx)("button",{className:o.btnSecondary,onClick:()=>{const e=a[u]+1,n=_.question.length>1200?`${_.question.slice(0,1200)}...`:_.question,s=`QCM : erreur potentielle question #${e}`,i=p(_.correct)?_.correct:[_.correct],o=["## Contexte",`Index question (fichier source): ${e}`,"","## Question concern\xe9e","```text",n,"```","","## R\xe9ponses possibles",_.answers.map(((e,n)=>`  ${n+1}. ${e}`)),"","## R\xe9ponses correctes sur le site",i.map((e=>`  ${e+1}. ${_.answers[e]}`)),"","## Probl\xe8me","..."].join("\n"),l=`https://github.com/${t}/${r}/issues/new?title=${encodeURIComponent(s)}&body=${encodeURIComponent(o)}`;window.open(l,"_blank","noopener,noreferrer")},children:"Erreur ?"}),d?(0,s.jsx)("button",{className:o.btnPrimary,onClick:T,children:u+1>=a.length?"Voir le r\xe9sultat":"Question suivante (Ctrl+Enter) \u2192"}):!C&&(0,s.jsx)("button",{className:o.btnPrimary,onClick:S,children:"Valider (Ctrl+Enter)"})]})]})}const h={hide_title:!0,title:"QCM R\xe9visions",sidebar_position:1},f=void 0,x={},b=[];function q(e){return(0,s.jsx)(g,{title:"QCM R\xe9visions",questions:[{question:"Avec le type OCaml suivant et `v` une variable de type `t`, quelles sont les syntaxes valides ?\n```ocaml\ntype t = {x : int; a : int array}```",answers:["`let w = {0; [|1; 2; 3|]}`","`let w = {x : 0; a : [|1; 2; 3|]}`","`let w = {x = 0; a = [|1; 2; 3|]}`","`v.x`","`v->x`","`v.x = 1`","`v.x <- 1`","`v.a.(0) = 1` (en supposant que `v.a` a au moins un \xe9l\xe9ment)","`v.a.(0) <- 1` (en supposant que `v.a` a au moins un \xe9l\xe9ment)"],correct:[2,3,5,6,7,8],explanation:"`v.x = 1` est une comparaison d'\xe9galit\xe9, tandis que `v.x <- 1` est une affectation qui ne fonctionne que si `v` est mutable. `v.a.(0) <- 1` est valide car un tableau est mutable. Par contre, `v.a <- ...` ne serait valide que si `v.a` \xe9tait mutable."},{question:'Quelles sont les lignes donnant une erreur (ou comportement ind\xe9fini) ?\n```c\n#include <stdio.h>\n\ntypedef struct { int x; int* a; } t;\n\nt f() {\n    t res;\n    int x = 0;\n    int a[] = {1, 2};\n    res.x = x;\n    res.a = a;\n    return res;\n}\n\nint main() {\n    t res = f();\n    printf("%d", res.x);\n    printf("%d", res.a[1]);\n    return 0;\n}\n```',answers:["`int a[] = {1, 2};`","`res.x = x;`","`res.a = a;`",'`printf("%d", res.x);`','`printf("%d", res.a[1]);`'],correct:[4],explanation:'La ligne `printf("%d", res.a[1]);` est incorrecte car `res.a` pointe vers un tableau local qui est d\xe9truit \xe0 la fin de la fonction `f()`.\n Par contre, `printf("%d", res.x);` est correct car `res.x` est copi\xe9 dans la structure retourn\xe9e par `f()`.'},{question:'Apr\xe8s les lignes suivantes, que donne `printf("%d", x);`, `printf("%d", y);`, `printf("%d", z);` ?\n```c\nint x = 0, y = 1;\nif(y == 1) {\nint x = 1, z = 2;\ny = 2;\n}\n```',answers:["`0, 1, 2`","`0, 2, 2`","`1, 1, 2`","`1, 2, 2`","`0, 1, erreur`","`0, 2, erreur`","`1, 1, erreur`","`1, 2, erreur`"],correct:[5],explanation:"La variable `z` est d\xe9clar\xe9e dans un bloc if, donc elle n'est accessible que dans ce bloc. Lorsque le programme sort du bloc, `z` n'est plus accessible, donc `printf(\"%d\", z);` affiche une erreur de compilation."},{question:"L'algorithme de d\xe9terminisation d'un automate \xe0 $n$ \xe9tats et $p$ transitions sur un alphabet de taille $k$ donne un automate avec :",answers:["$2^n$ \xe9tats et $p$ transitions","$2^n$ \xe9tats et $k2^n$ transitions","$n!$ \xe9tats et $p$ transitions","$n!$ \xe9tats et $k n!$ transitions"],correct:1,explanation:"L'automate des parties a $2^n$ \xe9tats (tous les sous-ensembles d'\xe9tats). Chaque \xe9tat de l'automate des parties a $k$ transitions (une par lettre de l'alphabet), soit au total $k 2^n$ transitions."},{question:"Quelles sont les valeurs possibles de `c` si deux threads ex\xe9cutent la fonction `f` ?\n```c\nint c = 10;\n\nvoid f() {\n  for(int i = 0; i < 5; i++)\n    c--;\n}\n```",answers:["Seulement 0","De 0 \xe0 8","De 0 \xe0 9","De 0 \xe0 10"],correct:1,explanation:"Similaire au compteur du cours."},{question:"Quel algorithme est une variante de Dijkstra utilisant une heuristique estimant la distance restante au sommet cible pour explorer en priorit\xe9 les sommets les plus prometteurs ?",answers:["Bellman-Ford","Kruskal","A*","LZW"],correct:2,explanation:"A* utilise une heuristique pour guider la recherche vers le sommet cible plus efficacement que Dijkstra."},{question:"L'algorithme A* permet de :",answers:["Trouver un plus court chemin entre deux sommets en utilisant une heuristique","Calculer les composantes connexes d'un graphe","Trouver un arbre couvrant de poids minimum","Partitionner des donn\xe9es en classes"],correct:0,explanation:"A* combine le co\xfbt r\xe9el du chemin avec une heuristique estimant le co\xfbt restant pour guider efficacement la recherche."},{question:"Lesquels de ces algorithmes utilisent la programmation dynamique (ou m\xe9mo\xefsation) ?",answers:["Boyer-Moore","Calcul des attracteurs","Quine","Floyd-Warshall"],correct:[1,3],explanation:"Dans le calcul des attracteurs, pour \xe9viter de calculer plusieurs fois le m\xeame sommet. Dans Floyd-Warshall, avec une \xe9quation de r\xe9currence."},{question:"L'algorithme de Floyd-Warshall sur un graphe \xe0 $n$ sommets :",answers:["Utilise une r\xe9currence sur le nombre de sommets utilisable dans un plus court chemin","Utilise une r\xe9currence sur la longueur d'un plus court chemin","Est en O($n^3$)","Est en O($n\\log(n)$)"],correct:[0,2],explanation:"Floyd-Warshall r\xe9sout en $O(n^3)$ (3 boucles) le probl\xe8me des plus courts chemins entre toutes les paires de sommets en calculant la distance $d_k(u, v)$ de $u$ \xe0 $v$ utilisant les sommets $1, ..., k$."},{question:"Quel algorithme trouve les composantes fortement connexes d'un graphe orient\xe9 en effectuant deux parcours en profondeur (un sur le graphe et un sur le graphe transpos\xe9) ?",answers:["Kruskal","Dijkstra","Kosaraju","Prim"],correct:2,explanation:"Kosaraju effectue un premier parcours en profondeur pour obtenir un ordre de traitement, puis un second parcours en profondeur sur le graphe transpos\xe9."},{question:"L'algorithme de Kosaraju permet de :",answers:["Trouver un arbre couvrant de poids minimum","Calculer un couplage maximum","Trouver les composantes fortement connexes","Calculer les plus courts chemins"],correct:2,explanation:"Kosaraju identifie les composantes fortement connexes en utilisant deux parcours en profondeur."},{question:"La complexit\xe9 de l'algorithme de Kruskal avec Union-Find sur un graphe \xe0 $n$ sommets et $P$ ar\xeates est :",answers:["$O(np)$","$O(p \\log p)$","$O(np \\log p)$","$O(n + p)$"],correct:1,explanation:"Le tri des ar\xeates co\xfbte $O(p \\log p)$ ($= O(p \\log n)$). Les op\xe9rations Union-Find ont une complexit\xe9 amortie quasi-constante gr\xe2ce \xe0 l'union par rang et la compression de chemins."},{question:"Quel algorithme utilise des chemins augmentants ?",answers:["Kruskal","Recherche de couplage maximum","Kosaraju","Bellman-Ford"],correct:1,explanation:"L'algorithme cherche des chemins augmentants et applique la diff\xe9rence sym\xe9trique avec le couplage courant pour l'agrandir."},{question:"Un couplage $M$ dans un graphe $G = (S, A)$ est maximum si et seulement si :",answers:["Il n'y a pas de chemin alternant pour $M$","Il n'y a pas de chemin augmentant pour $M$","$\\forall e\\in A$, $M\\cup\\{e\\}$ n'est pas un couplage","Tous les sommets de $G$ sont couverts par $M$"],correct:1,explanation:"Par d\xe9finition, $M$ est maximum s'il n'y a pas de couplage de cardinal sup\xe9rieur (contenant plus d'ar\xeates). Si $C$ est un chemin augmentant, $M\\Delta C$ est un couplage de cardinal sup\xe9rieur \xe0 $M$."},{question:"Quel est l'algorithme le plus efficace pour trouver des plus courts chemins depuis un sommet fix\xe9 dans un graphe non pond\xe9r\xe9 ?",answers:["Parcours en largeur","Dijkstra","Parcours en profondeur","A*"],correct:0,explanation:"Le parcours en largeur visite les sommets par distance croissante (en nombre d'ar\xeates) depuis un sommet de d\xe9part."},{question:"Quels algorithmes utilisent une file ?",answers:["Parcours en profondeur","Parcours en largeur","Huffman","LZW"],correct:[1],explanation:"Le parcours en largeur utilise une file pour explorer les sommets couche par couche. Huffman utilise une file de priorit\xe9. LZW un dictionnaire. Le parcours en profondeur peut utiliser une pile."},{question:"Un parcours en profondeur peut \xeatre utilis\xe9 pour :",answers:["L'algorithme min-max","Trouver un arbre couvrant","D\xe9tecter un cycle dans un graphe orient\xe9","Trouver un tri topologique"],correct:[0,1,2,3],explanation:"On peut parcourir l'arbre min-max en profondeur. L'ensemble des ar\xeates parcourues forme un arbre couvrant. On peut tester l'existence d'un arc arri\xe8re pour d\xe9tecter un cycle. L'algorithme de Kosaraju utilise deux DFS."},{question:"Quel type d'algorithme probabiliste renvoie toujours un r\xe9sultat correct mais avec un temps d'ex\xe9cution variable ?",answers:["Monaco","Monte-Carlo","Las Vegas","Los Angeles"],correct:2,explanation:"Un algorithme de Las Vegas est toujours correct mais son temps d'ex\xe9cution est al\xe9atoire. Exemple : tri rapide randomis\xe9."},{question:"Un algorithme de Las Vegas est un algorithme qui :",answers:["Peut renvoyer un r\xe9sultat incorrect mais s'ex\xe9cute en temps d\xe9terministe","Renvoie toujours un r\xe9sultat correct mais avec un temps d'ex\xe9cution al\xe9atoire","Garantit un facteur d'approximation constant mais s'ex\xe9cute en temps d\xe9terministe","Donne un facteur d'approximation variable mais avec un temps d'ex\xe9cution al\xe9atoire"],correct:1,explanation:"Las Vegas = toujours correct, temps variable. Exemple : quicksort randomis\xe9."},{question:"Quels algorithmes permettent d'explorer seulement une partie du graphe des configurations ?",answers:["Calcul des attracteurs","Branch-and-bound","Alpha-beta","Quine"],correct:[1,2,3],explanation:"Le calcul des attracteurs est optimal mais explore toutes les configurations. Branch-and-bound coupe les branches dont l'heuristique est moins bonne que la meilleure solution trouv\xe9e. Alpha-beta coupe les branches en dehors de l'intervalle $\\alpha \\leq \\beta$. Quine s'implifie la formule pour \xe9viter de parcourir toutes les valuations."},{question:"Lesquels sont des algorithmes de classification supervis\xe9e ?",answers:["$k$-moyennes","ID3","k plus proches voisins","Classification hi\xe9rarchique ascendante"],correct:[1,2],explanation:"$k$-moyennes et classification hi\xe9rarchique ascendante sont non-supervis\xe9s (pas de donn\xe9e d'entra\xeenement)."},{question:"Un arbre $k$-dimensionnel :",answers:["Permet de trouver efficacement des plus proches voisins","Permet de classifier des donn\xe9es","Est un arbre binaire de recherche","Est un arbre \xe9quilibr\xe9"],correct:[0,2,3],explanation:"Un arbre $k$-dimensionnel est obtenu en divisant r\xe9cursivement en deux (suivant un axe) des points dans $\\mathbb{R}^k$.\n Il peut \xeatre utilis\xe9 pour trouver les voisins dans l'algorithme des $k$-plus proches voisins."},{question:"Dans l'algorithme des $k$-moyennes, $k$ d\xe9signe :",answers:["Le nombre de voisins","Le nombre de classes","Le nombre de donn\xe9es","La dimension de l'espace"],correct:1,explanation:"L'algorithme des $k$-moyennes est un algorithme de classification non supervis\xe9 qui partitionne les donn\xe9es en essayant de minimiser la distance aux centres des classes."},{question:"Quel algorithme de classification non supervis\xe9e fusionne it\xe9rativement les deux classes les plus proches, en partant d'une classe par donn\xe9e ?",answers:["$k$-moyennes","$k$ plus proches voisins","Classification hi\xe9rarchique ascendante","ID3"],correct:2,explanation:"CHA construit une hi\xe9rarchie de classes en fusionnant les plus proches \xe0 chaque \xe9tape."},{question:"La classification hi\xe9rarchique ascendante :",answers:["Pr\xe9dit la classe d'une donn\xe9e \xe0 partir de ses voisins","Fusionne it\xe9rativement les classes les plus proches","Construit un arbre de d\xe9cision par gain d'information","Met \xe0 jour alternativement classes et centres"],correct:1,explanation:"CHA part de $n$ classes (une par donn\xe9e) et fusionne les deux plus proches \xe0 chaque \xe9tape."},{question:"Quel algorithme de classification supervis\xe9e construit un arbre de d\xe9cision en choisissant \xe0 chaque n\u0153ud l'attribut maximisant le gain d'information ?",answers:["$k$NN","$k$-moyennes","CHA","ID3"],correct:3,explanation:"ID3 construit un arbre de d\xe9cision de mani\xe8re gloutonne en maximisant le gain d'entropie \xe0 chaque n\u0153ud."},{question:"Quel algorithme construit un automate reconnaissant le langage d'une expression r\xe9guli\xe8re en lin\xe9arisant l'expression ?",answers:["Automate produit","Berry-Sethi","Kleene","Thompson"],correct:1,explanation:"Berry-Sethi lin\xe9arise l'expression r\xe9guli\xe8re et construit un automate local reconnaissant le m\xeame langage."},{question:"Les langages r\xe9guliers sont stables par :",answers:["Compl\xe9mentaire","Diff\xe9rence","Intersection","Inclusion","Miroir"],correct:[0,1,2,4],explanation:"Compl\xe9mentaire : d\xe9terminiser l'automate puis inverser \xe9tats initiaux et finaux.\n Diff\xe9rence et intersection : automate produit.\n Miroir : inverser les transitions et les \xe9tats finaux/initiaux.\n Inclusion : faux car tout langage contient $\\emptyset$ et est inclus dans $\\Sigma^*$."},{question:"Lesquels de ces langages sont r\xe9guliers ?",answers:["$\\{a^n b^p \\mid n, p \\in \\mathbb{N}\\}$","$\\{a^n b^n \\mid n \\in \\mathbb{N}\\}$","$\\{a^n b^p \\mid n = p \\mod 3\\}$","$\\{a^n b^p \\mid n < p\\}$"],correct:[0,2],explanation:"Le premier est $a^* b^*$. Le 3\xe8me est reconnu par un automate produit \xe0 $4$ \xe9tats o\xf9 on arrive sur l'\xe9tat $(x, y)$ si le nombre de $a$ (resp. $b$) est \xe9gal \xe0 $x$ (resp. $y$). Le 2\xe8me et 4\xe8me ne sont pas r\xe9gulier par le lemme de l'\xe9toile."},{question:"Quel est le nombre d'ar\xeates d'un graphe complet non-orient\xe9 \xe0 $n$ sommets ?",answers:["$n!$","$n^2$","$n - 1$","$\\frac{n(n-1)}{2}$"],correct:3,explanation:"Un graphe complet non orient\xe9 \xe0 $n$ sommets a une ar\xeate entre chaque paire de sommets, soit $\\binom{n}{2} = \\frac{n(n-1)}{2}$ ar\xeates."},{question:"Quel algorithme d'exclusion mutuelle pour deux threads utilise un tableau `want` et une variable `turn` ?",answers:["Boulangerie de Lamport","Dekker","Peterson","Dijkstra"],correct:2,explanation:"Peterson utilise deux variables want (indiquant le souhait d'entrer en section critique) et turn (c\xe9dant la priorit\xe9)."},{question:"L'algorithme de la boulangerie de Lamport :",answers:["Impl\xe9mente un mutex pour $n$ threads","Impl\xe9mente un s\xe9maphore pour $n$ threads","Utilise un tableau `want` et une variable `turn`","Utilise un syst\xe8me de tickets pour g\xe9rer l'acc\xe8s \xe0 la section critique"],correct:[0,3],explanation:"Lamport g\xe9n\xe9ralise l'exclusion mutuelle \xe0 $n$ threads avec un m\xe9canisme de prise de ticket."},{question:"La programmation dynamique :",answers:["Diviser le probl\xe8me en sous-probl\xe8mes ind\xe9pendants","Choisit localement le meilleur choix \xe0 chaque \xe9tape","Utilise une relation de r\xe9currence","Stocke les r\xe9sultats interm\xe9diaires"],correct:[2,3],explanation:"La programmation dynamique utilise une relation de r\xe9currence et du stockage (m\xe9mo\xefsation ou tableau) pour \xe9viter les calculs redondants."},{question:"Quel algorithme glouton de compression construit un arbre binaire optimal o\xf9 les lettres fr\xe9quentes ont un code court ?",answers:["LZW","Rabin-Karp","Huffman","Boyer-Moore-Horspool"],correct:2,explanation:"Huffman construit un arbre de codage pr\xe9fixe optimal en fusionnant les deux symboles les moins fr\xe9quents \xe0 chaque \xe9tape."},{question:"Quel algorithme de compression en ligne construit un dictionnaire de motifs au fur et \xe0 mesure de la lecture du texte ?",answers:["Huffman","Rabin-Karp","Boyer-Moore-Horspool","LZW (Lempel-Ziv-Welch)"],correct:3,explanation:"LZW construit dynamiquement un dictionnaire et remplace les motifs d\xe9j\xe0 vus par des codes plus courts."},{question:"Quel algorithme de recherche de motif dans un texte utilise une fonction de hachage glissante (rolling hash) ?",answers:["Boyer-Moore-Horspool","Huffman","Rabin-Karp","LZW"],correct:2,explanation:"Rabin-Karp utilise un hash glissant pour comparer le motif \xe0 chaque fen\xeatre du texte en $O(n)$ en moyenne."},{question:"Quel algorithme de recherche de motif compare les caract\xe8res de droite \xe0 gauche et utilise une table de d\xe9calage pr\xe9calcul\xe9e ?",answers:["Rabin-Karp","Boyer-Moore-Horspool","Huffman","KMP"],correct:1,explanation:"Boyer-Moore-Horspool compare de droite \xe0 gauche et saute des positions gr\xe2ce \xe0 une table de d\xe9calage."},{question:"Quel algorithme r\xe9sout le probl\xe8me SAT par backtracking en affectant les variables et en simplifiant les clauses \xe0 chaque \xe9tape ?",answers:["Branch-and-bound","Alpha-beta","Quine","Calcul des attracteurs"],correct:2,explanation:"L'algorithme de Quine affecte chaque variable \xe0 vrai ou faux et simplifie les clauses \xe0 chaque \xe9tape par backtracking."},{question:"L'\xe9lagage alpha-b\xeata est une variante de min-max qui :",answers:["Explore en priorit\xe9 les branches d'heuristique la plus prometteuses","Coupe les branches qui ne peuvent pas influencer le r\xe9sultat final","Parcourt toutes les configurations du jeu","M\xe9morise les r\xe9sultats interm\xe9diaires pour \xe9viter les calculs redondants"],correct:1,explanation:"Alpha-b\xeata \xe9lague les branches inutiles de l'arbre de jeu en maintenant des bornes $\\alpha$ et $\\beta$."},{question:"Quelles sont les impl\xe9mentations efficaces d'une file de priorit\xe9 ?",answers:["Arbre binaire de recherche","Arbre $k$-dimensionnel","Tas","Table de hachage"],correct:[0,2],explanation:"Un tas binaire est un arbre binaire presque complet impl\xe9ment\xe9 par un tableau, avec insertion et extraction du minimum en $O(\\log n)$.\n On peut aussi utiliser un arbre binaire de recherche (\xe9quilibr\xe9 \xe9ventuellement) en cherchant le minimum tout \xe0 gauche."},{question:"Soit $a = N(g, r, d)$ un arbre. $a$ est un arbre binaire de recherche si et seulement si :",answers:["$r$ est sup\xe9rieur aux \xe9tiquettes de $g$ et inf\xe9rieur aux \xe9tiquettes de $d$","$r$ est sup\xe9rieur \xe0 la racine de $g$ et inf\xe9rieur \xe0 la racine de $d$","Le parcours pr\xe9fixe de $a$ est tri\xe9 par ordre croissant","Le parcours infixe de $a$ est tri\xe9 par ordre croissant"],correct:[3],explanation:"La premi\xe8re condition n'est pas suffisante : il faut aussi que $g$ et $d$ soient des arbres binaires de recherche.\n La deuxi\xe8me n'est pas bonne du tout.\nUn arbre est un arbre binaire de recherche si et seulement si son parcours infixe est tri\xe9 par ordre croissant."},{question:"Quels algorithmes du cours utilisent une file de priorit\xe9 ?",answers:["Dijkstra","A*","Tri par tas","Huffman","BFS","Quine"],correct:[0,1,2,3],explanation:"Le tas (file de priorit\xe9) est utilis\xe9 par Dijkstra et A* pour extraire le sommet le plus proche, par le tri par tas, et par Huffman pour fusionner les arbres de fr\xe9quences minimales."},{question:"Quelles sont des applications possibles d'Union-Find ?",answers:["Gestion de classes d'\xe9quivalence","Prim","Kruskal","Tester la connexit\xe9 d'un graphe"],correct:[0,2,3],explanation:"Union-Find stocke une partition dans un tableau de p\xe8res. Il est utilis\xe9 par Kruskal pour v\xe9rifier si une ar\xeate relie deux composantes distinctes (find) et pour les fusionner (union). On peut aussi l'utiliser pour g\xe9rer des classes d'\xe9quivalence ou tester la connexit\xe9 d'un graphe en v\xe9rifiant que tous les sommets sont dans la m\xeame classe."},{question:"Le lemme de l'\xe9toile :",answers:["Permet de choisir la d\xe9composition $u = xyz$","S'applique aux langages hors-contextes","Permet de prouver qu'un langage n'est pas r\xe9gulier","Permet de prouver qu'un langage est r\xe9gulier"],correct:[2],explanation:"Le lemme de l'\xe9toile est utilis\xe9 par l'absurde pour prouver qu'un langage n'est pas r\xe9gulier. La r\xe9ciproque est fausse donc on ne peut pas prouver qu'un langage est r\xe9gulier avec ce lemme. Il est faux pour les langages hors-contextes g\xe9n\xe9raux, qui ont un lemme de l'\xe9toile diff\xe9rent (avec $u = vwx$ et $|vx| > 0$)."},{question:"Tout automate est \xe9quivalent \xe0 :",answers:["Une expression r\xe9guli\xe8re","Une grammaire r\xe9guli\xe8re","Un automate d\xe9terministe complet","Un automate \xe9mond\xe9 (dont tous les \xe9tats sont accessibles et co-accessibles)","Un automate local","Un automate sans $\\epsilon$-transition"],correct:[0,1,2,3,5],explanation:"Tout automate est \xe9quivalent \xe0 une expression r\xe9guli\xe8re par le th\xe9or\xe8me de Kleene. Tout automate est \xe9quivalent \xe0 un automate d\xe9terministe complet par d\xe9terminisation. Tout automate est \xe9quivalent \xe0 un automate \xe9mond\xe9 en supprimant les \xe9tats inaccessibles ou non co-accessibles. Seuls les langages locaux sont reconnus par des automates locaux."},{question:"L'algorithme d'\xe9limination des \xe9tats :",answers:["Permet d'obtenir un automate minimal","Permet d'obtenir une expression r\xe9guli\xe8re","Permet d'obtenir un automate \xe9mond\xe9 (dont tous les \xe9tats sont accessibles et co-accessibles)","Permet d'obtenir un automate local"],correct:1,explanation:"L'algorithme d'\xe9limination des \xe9tats permet de transformer un automate en une expression r\xe9guli\xe8re \xe9quivalente en \xe9liminant les \xe9tats un par un et en mettant \xe0 jour les transitions avec des expressions r\xe9guli\xe8res."},{question:"Quelle est la structure de donn\xe9e utilis\xe9e dans le cours pour repr\xe9senter un tas ?",answers:["Tableau `T` o\xf9 `T[i]` est le p\xe8re de `T[2i+1]` et `T[2i+2]`","Tableau `T` o\xf9 `T[i]` est le p\xe8re de `i`","Type OCaml `type 'a arb = Empty | Node of 'a * 'a arb * 'a arb`","Dictionnaire associant \xe0 chaque sommet la liste de ses fils"],correct:0,explanation:"Un tas binaire est un arbre binaire presque complet, qui peut \xeatre repr\xe9sent\xe9 par un tableau `T` o\xf9 `T[i]` est le p\xe8re de `T[2i+1]` et `T[2i+2]`. Le p\xe8re de `T[j]` est `T[(j-1)/2]`.\\n Remarque : on peut aussi d\xe9finir un tas persistant (skew heap)."},{question:"Quelle est la structure de donn\xe9e utilis\xe9e pour repr\xe9senter une structure d'Union-Find ?",answers:["Tableau `T` o\xf9 `T[i]` est le p\xe8re de `T[2i+1]` et `T[2i+2]`","Tableau `T` o\xf9 `T[i]` est le p\xe8re de `i`","Type OCaml `type 'a arb = Empty | Node of 'a * 'a arb * 'a arb`","Dictionnaire associant \xe0 chaque sommet la liste de ses fils"],correct:1,explanation:"Union-Find est repr\xe9sent\xe9 par un tableau `T` o\xf9 `T[i]` est le p\xe8re de `i`. Les \xe9l\xe9ments d'une m\xeame classe d'\xe9quivalence forment un arbre dont la racine est un repr\xe9sentant de la classe."},{question:"Quel est le nombre d'ar\xeates d'un arbre \xe0 $n$ sommets ?",answers:["$n-1$","$n$","$2n-1$","$2n$"],correct:0,explanation:"Avec $G$ connexe $\\Rightarrow$ $n-1$ ar\xeates et $G$ acyclique $\\Rightarrow$ au plus $n-1$ ar\xeates."},{question:"Quelles structures de donn\xe9es permettent d'impl\xe9menter un dictionnaire ?",answers:["Arbre binaire de recherche","Table de hachage","Tas binaire","Union-Find"],correct:[0,1],explanation:"On peut utiliser un arbre binaire de recherche dont les \xe9tiquettes sont des couples (cl\xe9, valeur), avec des op\xe9rations O($h$). On peut aussi utiliser une table de hachage avec du O(1) en moyenne."},{question:"L'arbre de Huffman garantit :",answers:["Toutes les lettres ont un code de m\xeame longueur","Les lettres les plus fr\xe9quentes ont un code court ","L'arbre est \xe9quilibr\xe9","Une compression optimale","Un codage pr\xe9fixe (aucun code n'est pr\xe9fixe d'un autre)"],correct:[1,3,4],explanation:"Le codage de Huffman est un codage pr\xe9fixe (aucun code n'est pr\xe9fixe d'un autre) qui minimise la longueur moyenne."},{question:"Un arbre binaire presque complet dont chaque n\u0153ud est sup\xe9rieur ou \xe9gal \xe0 ses fils est :",answers:["Un arbre binaire de recherche","Un tas max","Un arbre min-max","Un arbre de Huffman"],correct:1,explanation:"C'est la d\xe9finition d'un tas max : arbre presque complet + propri\xe9t\xe9 de tas (n\u0153ud \u2265 fils)."},{question:"La compression de chemins dans Union-Find consiste \xe0 :",answers:["Trier les \xe9l\xe9ments de chaque classe","Rattacher tous les n\u0153uds du chemin directement \xe0 la racine lors d'un `find`","Fusionner les deux plus petites classes","Doubler la taille du tableau interne"],correct:1,explanation:"Lors d'un find, la compression de chemins rattache chaque n\u0153ud travers\xe9 directement \xe0 la racine, aplatissant l'arbre pour les requ\xeates futures."},{question:"Dans un arbre binaire strict (chaque n\u0153ud a soit 0 soit 2 fils) avec $f$ feuilles et $n_i$ n\u0153uds internes (non feuilles) :",answers:["$f = n_i$","$f = n_i + 1$","$f = 2n_i$","$f = 2n_i + 1$"],correct:1,explanation:"Par induction structurelle."},{question:"Dans un arbre binaire de hauteur $h$ et \xe0 $n$ n\u0153uds (donner les meilleures bornes) :",answers:["$n \\leq 2^h - 1$","$n \\leq 2^{h+1} - 1$","$n \\geq h$","$n \\geq h + 1$"],correct:[1,3],explanation:"Il y a entre $1$ et $2^p$ n\u0153uds \xe0 la profondeur P, qu'on peut sommer."},{question:"Si $\\Pi_1 \\leq_p \\Pi_2$ alors :",answers:["Si $\\Pi_1 \\in$ P alors $\\Pi_2 \\in$ P","Si $\\Pi_2 \\in$ P alors $\\Pi_1 \\in$ P","Si $\\Pi_1 \\in$ NP alors $\\Pi_2 \\in$ NP","Si $\\Pi_2 \\in$ NP alors $\\Pi_1 \\in$ NP","Si $\\Pi_2\\in$ NP et $\\Pi_1$ est NP-complet alors $\\Pi_2$ est NP-complet","Si $\\Pi_1\\in$ NP et $\\Pi_2$ est NP-complet alors $\\Pi_1$ est NP-complet"],correct:[1,3,5],explanation:"Soit $\\varphi$ une r\xe9duction de $\\Pi_1$ \xe0 $\\Pi_2$. Si $\\Pi_2 \\in$ P, alors $\\Pi_1$ est dans P car on peut r\xe9soudre une instance $I$ de $\\Pi_1$ en r\xe9solvant $\\varphi(I)$ dans $\\Pi_2$. Si $A$ est un v\xe9rificateur pour $\\Pi_2$, alors $A(\\varphi(I), c)$ est un v\xe9rificateur pour $\\Pi_1$. Si $\\Pi_2$ est NP-complet et $\\Pi_1 \\in$ NP, alors $\\Pi_1$ est NP-complet par transitivit\xe9."},{question:"Un probl\xe8me est d\xe9cidable si :",answers:["Il peut \xeatre r\xe9solu en temps polynomial","Il existe un algorithme qui termine toujours et r\xe9pond correctement","Il appartient \xe0 NP","Il peut \xeatre v\xe9rifi\xe9 en temps polynomial"],correct:1,explanation:"Un probl\xe8me est d\xe9cidable s'il existe un algorithme (machine de Turing) qui termine toujours et donne la bonne r\xe9ponse."},{question:"Quelles relations sont connues concernant P et NP ?",answers:["P = NP","P $\\subset$ NP","NP $\\subset$ P","P et NP sont disjoints"],correct:1,explanation:"On sait que P $\\subset$ NP car un probl\xe8me r\xe9soluble en temps polynomial peut \xe9videmment \xeatre v\xe9rifi\xe9 en temps polynomial. La question P = NP reste ouverte."},{question:"Quels sont les probl\xe8mes NP-complets ?",answers:["$\\texttt{SAT}$","$\\texttt{2-SAT}$","$\\texttt{3-SAT}$","$\\texttt{FNC-SAT}$ : $\\texttt{SAT}$ restreint aux formes normales disjonctives (FNC)","Couplage maximum","Clique maximum","Arbre couvrant de poids maximum","Chemin de poids maximum"],correct:[0,2,5,7],explanation:"$\\texttt{SAT}$ est NP-complet d'apr\xe8s le th\xe9or\xe8me de Cook-Levin.\n$\\texttt{2-SAT}$ et $\\texttt{FNC-SAT}$ sont dans P.\n$\\texttt{3-SAT}$ est NP-complet par r\xe9duction depuis $\\texttt{SAT}$.\nCouplage maximum est dans P (algorithme des chemins augmentants pour graphe biparti et algorithme hongrois dans le cas g\xe9n\xe9ral).\nClique maximum est NP-complet par r\xe9duction depuis $\\texttt{SAT}$ (ou $\\texttt{STABLE}$ comme dans le cours).\nUn arbre couvrant de poids maximum peut \xeatre trouv\xe9 en triant les ar\xeates par poids d\xe9croissant dans Kruskal.\nChemin de poids maximum est NP-complet par r\xe9duction depuis $\\texttt{HAMILTONIEN}$."},{question:"On note $\\varphi \\equiv \\psi$ lorsque $\\varphi$ et $\\psi$ ont les m\xeames valuations positives. Lesquelles de ces identit\xe9s sont vraies ?",answers:["$\\lnot \\lnot \\varphi \\equiv \\varphi$","$\\varphi_1 \\lor (\\varphi_2 \\land \\varphi_3) \\equiv (\\varphi_1 \\lor \\varphi_2) \\land (\\varphi_1 \\lor \\varphi_3)$","$\\varphi_1 \\land (\\varphi_2 \\lor \\varphi_3) \\equiv (\\varphi_1 \\land \\varphi_2) \\lor (\\varphi_1 \\land \\varphi_3)$","$\\varphi_1 \\longrightarrow \\varphi_2 \\equiv \\lnot \\varphi_2 \\longrightarrow \\lnot \\varphi_1$","$\\lnot(\\varphi_1 \\land \\varphi_2) \\equiv \\lnot \\varphi_1 \\lor \\lnot \\varphi_2$","$\\lnot(\\varphi_1 \\lor \\varphi_2) \\equiv \\lnot \\varphi_1 \\land \\lnot \\varphi_2$"],correct:[0,1,2,3,4,5],explanation:"Par table de v\xe9rit\xe9 ou utilisation de la d\xe9finition de l'\xe9valuation d'une formule."},{question:"Si $\\Pi_1$ se r\xe9duit \xe0 $\\Pi_2$ alors :",answers:["$\\Pi_1 \\leq \\Pi_2$","$\\Pi_2 \\leq \\Pi_1$","Il existe une fonction de r\xe9duction de $\\Pi_1$ \xe0 $\\Pi_2$","Il existe une fonction de r\xe9duction de $\\Pi_2$ \xe0 $\\Pi_1$","$\\Pi_1$ ind\xe9cidable $\\Longrightarrow \\Pi_2$ ind\xe9cidable","$\\Pi_2$ ind\xe9cidable $\\Longrightarrow \\Pi_1$ ind\xe9cidable","$\\Pi_1$ NP-complet $\\Longrightarrow \\Pi_2$ NP-complet","$\\Pi_2$ NP-complet $\\Longrightarrow \\Pi_1$ NP-complet"],correct:[0,2,4],explanation:"$\\Pi_1 \\leq_p \\Pi_2$ signifie que $\\Pi_1$ se r\xe9duit \xe0 $\\Pi_2$, c'est-\xe0-dire qu'il existe une fonction de r\xe9duction de $\\Pi_1$ \xe0 $\\Pi_2$.\nPar cons\xe9quent, si $\\Pi_1$ est ind\xe9cidable, alors $\\Pi_2$ doit \xe9galement \xeatre ind\xe9cidable, car sinon on pourrait r\xe9soudre $\\Pi_1$ en utilisant la r\xe9duction vers $\\Pi_2$\n Il faut que la r\xe9duction soit polynomiale et avoir l'appartenance \xe0 NP pour conclure sur les probl\xe8mes NP-complets."},{question:"Le lemme de l'\xe9toile sur un langage r\xe9gulier $L$ commence ainsi :",answers:["$\\forall u \\in L, \\exists n \\in \\mathbb{N}, |u| \\geq n \\Longrightarrow \\exists x, y, z \\in \\Sigma^*, u = xyz, |xy| \\leq n, |y| > 0$","$\\exists n \\in \\mathbb{N}, \\forall u \\in L, |u| \\geq n \\Longrightarrow \\exists x, y, z \\in \\Sigma^*, u = xyz, |xy| \\leq n, |y| > 0$","$\\forall u \\in L, \\exists n \\in \\mathbb{N}, |u| \\geq n \\Longrightarrow \\forall x, y, z \\in \\Sigma^*, u = xyz, |xy| \\leq n, |y| > 0$","$\\exists n \\in \\mathbb{N}, \\forall u \\in L, |u| \\geq n \\Longrightarrow \\forall x, y, z \\in \\Sigma^*, u = xyz, |xy| \\leq n, |y| > 0$"],correct:1,explanation:"En cas de doute, revenir \xe0 la d\xe9monstration du lemme de l'\xe9toile."},{question:"Quels sont les langages hors-contextes ?",answers:["$\\{a^n b^p \\mid n, p \\in \\mathbb{N}\\}$","$\\{a^n b^n \\mid n \\in \\mathbb{N}\\}$","$\\{a^n b^p \\mid n \\leq p \\}$","$\\{a^n b^n c^n \\mid n \\in \\mathbb{N}\\}$"],correct:[0,1,2],explanation:"Le premier est r\xe9gulier donc hors-contexte.\nLe second est engendr\xe9 par $S \\Longrightarrow aSb \\mid \\epsilon$.\nLe troisi\xe8me est engendr\xe9 par $S \\Longrightarrow aSb \\mid bS \\mid \\epsilon$.\nLe quatri\xe8me n'est pas hors-contexte par le lemme de l'\xe9toile pour les langages hors-contextes (voir TD)."},{question:"Une grammaire $G$ est ambig\xfce si et seulement si :",answers:["Il existe un mot de $L(G)$ ayant au moins deux arbres de d\xe9rivation diff\xe9rents","Tous les mots de $L(G)$ ont au moins deux arbres de d\xe9rivation diff\xe9rents","Il existe un mot de $L(G)$ ayant au moins deux d\xe9rivations gauches diff\xe9rentes","Tous les mots de $L(G)$ ont au moins deux d\xe9rivations gauches diff\xe9rentes"],correct:[0,2],explanation:"Cours."},{question:"Les grammaires non-contextuelles sont stables par :",answers:["Inclusion","Union","Concat\xe9nation","\xc9toile","Intersection","Compl\xe9mentaire","Diff\xe9rence","Miroir"],correct:[1,2,3,7],explanation:"Les langages hors-contextes sont stables par union, concat\xe9nation, \xe9toile, miroir (cours).\nIls ne sont pas stables par intersection, compl\xe9mentaire ou diff\xe9rence (voir TD) ni par inclusion."},{question:"Toute formule logique est \xe9quivalente \xe0 :",answers:["Une formule en forme normale conjonctive (FNC)","Une formule en forme normale disjonctive (FND)","Une formule en forme normale n\xe9gative (o\xf9 les n\xe9gations ne sont appliqu\xe9es qu'\xe0 des variables)","Une formule $\\texttt{2-SAT}$ (FNC o\xf9 chaque clause contient au plus 2 litt\xe9raux)","Une formule $\\texttt{3-SAT}$ (FNC o\xf9 chaque clause contient au plus 3 litt\xe9raux)"],correct:[0,1,2,4],explanation:"Toute formule est \xe9quivalente \xe0 une FNC et \xe0 une FND, en passant par une table de v\xe9rit\xe9.\nPar induction et en poussant les n\xe9gations vers les variables, on obtient une formule \xe9quivalente en forme normale n\xe9gative.\nOn a montr\xe9 dans la r\xe9duction de $\\texttt{SAT}$ \xe0 $\\texttt{3-SAT}$ que toute formule est \xe9quivalente \xe0 une formule $\\texttt{3-SAT}$.\nPar contre, $\\texttt{2-SAT}$ est dans P, donc on aurait P = NP si toute formule \xe9tait \xe9quivalente \xe0 une formule $\\texttt{2-SAT}$."},{question:"On note $e_1 \\equiv e_2$ lorsque les expressions r\xe9guli\xe8res $e_1$ et $e_2$ reconnaissent le m\xeame langage. Lesquelles de ces identit\xe9s sont vraies ?",answers:["$(e^*)^* \\equiv e^*$","$(e_1 \\mid e_2)^* \\equiv e_1^* \\mid e_2^*$","$(e_1 e_2)^* \\equiv e_1^* e_2^*$","$e_1 (e_2 \\mid e_3) \\equiv e_1 e_2 \\mid e_1 e_3$","$e_1 \\mid (e_2 e_3) \\equiv e_1 e_2 \\mid e_1 e_3$"],correct:[0,3],explanation:"On montre la premi\xe8re avec la d\xe9finition.\n Si $e_1 = a^*$ et $e_2 = b^*$ alors $(e_1 \\mid e_2)^* \\not\\equiv e_1^* \\mid e_2^*$. Similaire pour les autres r\xe9ponses."},{question:"Quelles affirmations sont vraies ?",answers:["$\\emptyset$ est une lettre","$\\emptyset$ est un mot","$\\emptyset$ est un langage","$\\epsilon$ est une lettre","$\\epsilon$ est un mot","$\\epsilon$ est un langage"],correct:[2,4,5],explanation:"$\\emptyset$ n'est ni une lettre ni un mot, mais un langage (le langage vide).\n$\\epsilon$ est le mot vide mais peut aussi d\xe9signer un langage par abus de notation, sur les expression r\xe9guli\xe8re : l'ensemble $\\{\\epsilon\\}$."},{question:"Un automate produit de deux automates $A_1$ et $A_2$ d'\xe9tats $Q_1$ et $Q_2$ :",answers:["Poss\xe8de $Q_1 \\times Q_2$ comme ensemble d'\xe9tats","Peut permettre de reconna\xeetre $L(A_1)L(A_2)$","Peut permettre de reconna\xeetre $L(A_1) \\cup L(A_2)$","Peut permettre de reconna\xeetre $L(A_1) \\cap L(A_2)$","Peut permettre de reconna\xeetre $L(A_1) \\setminus L(A_2)$","Peut permettre de reconna\xeetre $L(A_1) \\Delta L(A_2)$"],correct:[0,2,3,4,5],explanation:"L'automate produit a bien $Q_1 \\times Q_2$ comme \xe9tats. En ajustant les \xe9tats finaux, il permet de reconna\xeetre l'union, l'intersection, la diff\xe9rence et la diff\xe9rence sym\xe9trique. En revanche, la concat\xe9nation $L(A_1)L(A_2)$ ne se fait pas avec un simple produit.\nAttention : les deux automates doivent \xeatre d\xe9terministes pour que le produit permette de reconnaitre ces langages."},{question:"Si $\\Pi \\in$ NP :",answers:["On ne sait pas le r\xe9soudre en temps polynomial","Il peut \xeatre r\xe9solu en temps exponentiel","Il peut \xeatre r\xe9solu en espace polynomial","Pour chaque instance de $\\Pi$, on peut cr\xe9er un certificat en temps polynomial"],correct:[1,2],explanation:"Tout probl\xe8me de P est dans NP.\nUn probl\xe8me de NP peut toujours \xeatre r\xe9solu en temps exponentiel (\xe9num\xe9ration des certificats) et en espace polynomial (r\xe9utilisation de l'espace pour v\xe9rifier chaque certificat).\nLe v\xe9rificateur doit v\xe9rifier en temps polynomial un certificat, pas le cr\xe9er."},{question:"\xc0 quoi s'\xe9value l'expression `0.1 +. 0.2 = 0.3` en OCaml ?",answers:["Une erreur car il faut utiliser `==`","Une erreur car il faut utiliser `=.` sur des flottants","`false` car `0.1` est stock\xe9 de fa\xe7on approch\xe9e","`true` car `0.1 +. 0.2` est \xe9gal \xe0 `0.3`"],correct:2,explanation:"Les flottants sont stock\xe9s en base 2 et `0.1` n'a pas d'\xe9criture exacte en base 2, donc les comparaisons d'\xe9galit\xe9 stricte peuvent \xe9chouer \xe0 cause des erreurs d'arrondi."},{question:"La suite de bits $10110$ peut repr\xe9senter :",answers:["22","-10 en compl\xe9ment \xe0 2","Un rationnel","Un caract\xe8re"],correct:[0,1,2,3],explanation:"$10110$ vaut 22 en non sign\xe9. Sur 5 bits en compl\xe9ment \xe0 2, cela repr\xe9sente -10. Cette suite peut aussi coder une valeur rationnelle selon un format flottant donn\xe9, et peut repr\xe9senter un caract\xe8re selon un encodage choisi."},{question:"Une fonction de hachage peut \xeatre utilis\xe9e pour :",answers:["La s\xe9curit\xe9 informatique","La reconnaissance de motif dans un texte","La m\xe9mo\xefsation","Acc\xe9l\xe9rer l'algorithme des $k$ plus proches voisins"],correct:[0,1,2],explanation:"En s\xe9curit\xe9 pour \xe9viter de stocker les mots de passe en clair.\nEn reconnaissance de motif, comme dans l'algorithme de Rabin-Karp.\nEn m\xe9mo\xefsation pour stocker les r\xe9sultats interm\xe9diaires d'une fonction r\xe9cursive."},{question:"Quelles structures sont persistantes ?",answers:["Liste","Tableau","Arbre binaire avec `type 'a arb = Empty | Node of 'a * 'a arb * 'a arb`","Tas binaire comme dans le cours","Cha\xeene de caract\xe8res en C","Cha\xeene de caract\xe8res en OCaml"],correct:[0,2,5],explanation:"Les listes et arbres OCaml sont persistants, et les cha\xeenes OCaml sont immuables.\n Les tableaux, tas binaires classiques et cha\xeenes (tableaux de caract\xe8res) C sont mutables."},{question:"Les arbres rouge-noirs :",answers:["Sont des arbres binaires de recherche","Sont des tas","Sont \xe9quilibr\xe9s","Maintiennent l'invariant : les deux fils de chaque n\u0153ud sont de hauteur \xe9gales +/- 1","Permettent d'impl\xe9menter un dictionnaire","Utilisent une op\xe9ration de rotation pour maintenir l'\xe9quilibre"],correct:[0,2,4,5],explanation:"Les arbres rouge-noirs sont des arbres binaires de recherche auto-\xe9quilibr\xe9s, qui maintiennent une contrainte de coloration pour garantir que la hauteur est logarithmique.\nIls permettent d'impl\xe9menter un dictionnaire avec des op\xe9rations en O($\\log n$). Les rotations sont utilis\xe9es pour r\xe9\xe9quilibrer l'arbre apr\xe8s les insertions ou suppressions.\nL'invariant est celui des AVL."},{question:"Sur un graphe non-orient\xe9 $G = (S, A)$ \xe0 $n$ sommets et $p$ ar\xeates :",answers:["$\\sum_{v \\in S} \\deg(v) = p$","$\\sum_{v \\in S} \\deg(v) = 2p$","$G$ a un nombre pair de sommets de degr\xe9 impair","$G$ a un nombre impair de sommets de degr\xe9 pair","$G$ connexe $\\Longrightarrow p \\geq n-1$","$p \\geq n-1 \\Longrightarrow G \\text{ connexe}$","$G$ acyclique $\\Longrightarrow p \\leq n-1$","$p \\leq n-1 \\Longrightarrow G \\text{ acyclique}$"],correct:[1,2,4,6],explanation:"La plupart par r\xe9currence. Voir cours."},{question:"Quels algorithmes utilisent la m\xe9thode diviser pour r\xe9gner ?",answers:["Algorithme de tri rapide","Algorithme de tri fusion","Algorithme de recherche par dichotomie dans un tableau tri\xe9","Algorithme de construction d'un arbre $k$-d","Algorithme ID3"],correct:[0,1,2,3,4],explanation:"Ces algorithmes divisent le probl\xe8me en sous-probl\xe8mes, les r\xe9solvent r\xe9cursivement puis combinent les r\xe9sultats."},{question:"Quelles sont les bonnes r\xe9solutions d'\xe9quation de complexit\xe9 ?",answers:["$C(n) = C(\\frac{n}{2}) + 1 \\Longrightarrow C(n) = O(\\log n)$","$C(n) = C(\\frac{n}{2}) + 1 \\Longrightarrow C(n) = O(n)$","$C(n) = C(\\frac{n}{2}) + n \\Longrightarrow C(n) = O(n \\log n)$","$C(n) = C(\\frac{n}{2}) + n \\Longrightarrow C(n) = O(n^2)$","$C(n) = 2C(\\frac{n}{2}) + 1 \\Longrightarrow C(n) = O(n)$","$C(n) = 2C(\\frac{n}{2}) + 1 \\Longrightarrow C(n) = O(n \\log n)$","$C(n) = 2C(\\frac{n}{2}) + n \\Longrightarrow C(n) = O(n \\log n)$","$C(n) = 2C(\\frac{n}{2}) + n \\Longrightarrow C(n) = O(n^2)$","$C(n) = 2 C(n-1) + 1 \\Longrightarrow C(n) = O(n^2)$","$C(n) = 2 C(n-1) + 1 \\Longrightarrow C(n) = O(2^n)$"],correct:[0,3,4,6,9],explanation:"$$C(n) \\leq C(\\frac{n}{2}) + 1 \\leq C(\\frac{n}{4}) + 1 + 1 \\leq \\dots \\leq C\\left(\\frac{n}{2^{\\lfloor \\log_2(n) \\rfloor}}\\right) + \\lfloor \\log_2(n) \\rfloor = O(\\log n)$$ $$C(n) = C(\\frac{n}{2}) + n = C(1) + n\\times \\sum_{k=0}^{\\lfloor \\log_2(n) \\rfloor - 1} \\frac{1}{2^k} \\leq C(1) + 2n$$ $$C(n) \\leq 2C(\\frac{n}{2}) + 1 \\leq 4C(\\frac{n}{4}) + 2 + 1 \\leq \\dots \\leq 2^{\\lfloor \\log_2(n) \\rfloor} C\\left(\\frac{n}{2^{\\lfloor \\log_2(n) \\rfloor}}\\right) + \\sum_{k=0}^{\\lfloor \\log_2(n) \\rfloor - 1} 2^k = O(n)$$ $$C(n) = 2C(n-1) + 1 = 4C(n-2) + 2 + 1 = \\dots = 2^{n-1}C(1) + \\sum_{k=0}^{n-2} 2^k = O(2^n)$$"},{question:"Pour rechercher si un motif appara\xeet dans un texte, on peut utiliser :",answers:["Un automate","L'algorithme de Lempel-Ziv-Welch","L'algorithme de Rabin-Karp","L'algorithme de Boyer-Moore","L'algorithme de Huffman"],correct:[0,2,3],explanation:"On peut construire l'automate reconnaissant $\\Sigma^*m\\Sigma^*$, o\xf9 $m$ est le motif. \n LZW et Huffman sont des algorithmes de compression."},{question:"Un ordre topologique d'un graphe orient\xe9 $G$ :",answers:["Existe si et seulement si $G$ est acyclique","Est unique s'il existe","Peut \xeatre calcul\xe9 avec un parcours en largeur","Peut \xeatre calcul\xe9 en temps $O(|S| + |A|)$","Peut \xeatre utilis\xe9 pour l'algorithme de Kosaraju"],correct:[0,3,4],explanation:"Un ordre topologique existe exactement pour les DAG. Il n'est pas forc\xe9ment unique. Il peut \xeatre calcul\xe9 par l'algorithme de Kahn (bas\xe9 sur une file), en temps lin\xe9aire en sommets + ar\xeates."},{question:"Un couplage $M$ d'un graphe \xe0 $n$ sommets v\xe9rifie :",answers:["$M$ ne contient pas deux ar\xeates adjacentes.","$M$ ne contient pas deux sommets adjacents.","Le nombre d'ar\xeates de $M$ est au plus $\\lfloor \\frac{n}{2} \\rfloor$.","Le nombre de sommets de $M$ est au plus $\\lfloor \\frac{n}{2} \\rfloor$."],correct:[0,2],explanation:"Un couplage est un ensemble d'ar\xeates sans sommets communs, donc chaque sommet est adjacent \xe0 au plus une ar\xeate du couplage. Par cons\xe9quent, le nombre d'ar\xeates dans un couplage est limit\xe9 par la moiti\xe9 du nombre de sommets, soit $\\lfloor \\frac{n}{2} \\rfloor$."},{question:"Un graphe $G$ est biparti si et seulement si :",answers:["Il ne contient pas de cycle de longueur paire","Il ne contient pas de cycle de longueur impaire","Il est 2-coloriable","Il est 3-coloriable","Il contient un couplage parfait"],correct:[1,2],explanation:"$G$ est biparti si on peut s\xe9parer les sommets en deux ensembles disjoints tels que toutes les ar\xeates relient un sommet de l'un \xe0 un sommet de l'autre. Cela \xe9quivaut \xe0 dire qu'il est 2-coloriable. \nSi un graphe ne contient pas de cycle de longueur impaire, un parcours de graphe en alternant les couleurs des sommets permet de 2-colorer le graphe."},{question:"L'algorithme des $k$-moyennes :",answers:["Est un algorithme d'apprentissage supervis\xe9","Converge toujours","Converge vers une solution optimale","Ne reconna\xeet pas les classes non convexes"],correct:[1,3],explanation:"C'est de la classification non-supervis\xe9e (pas de donn\xe9e d'entra\xeenement). $k$-moyennes converge mais pas forc\xe9ment vers l'optimum global. Il ne reconna\xeet pas bien les classes non convexes (ex. classes concentriques). "}]})}function v(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(q,{...e})}):q()}}}]);