"use strict";(self.webpackChunkmpi_info=self.webpackChunkmpi_info||[]).push([[9936],{3263:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>c,toc:()=>u});var t=n(4848),r=n(8453),a=n(7146);const i={title:"QCM - Plus courts chemins",sidebar_position:9},o=void 0,c={id:"graphes/sp/qcm_sp",title:"QCM - Plus courts chemins",description:"<QCM",source:"@site/docs/graphes/5_sp/9_qcm_sp.mdx",sourceDirName:"graphes/5_sp",slug:"/graphes/sp/qcm_sp",permalink:"/mpi-info/docs/graphes/sp/qcm_sp",draft:!1,unlisted:!1,editUrl:"https://github.com/mpi-lamartin/mpi-info/docs/graphes/5_sp/9_qcm_sp.mdx",tags:[],version:"current",sidebarPosition:9,frontMatter:{title:"QCM - Plus courts chemins",sidebar_position:9},sidebar:"graphes",previous:{title:"TD Algorithme de Boruvka et Johnson",permalink:"/mpi-info/docs/graphes/sp/td_boruvka_johnson"}},l={},u=[];function p(e){return(0,t.jsx)(a.A,{title:"QCM - Plus courts chemins",questions:[{question:"L'algorithme de Dijkstra permet de calculer :",answers:["Les plus courts chemins avec poids n\xe9gatifs","Les plus courts chemins depuis une source avec poids positifs ou nuls","Un arbre couvrant de poids minimum","Les composantes fortement connexes"],correct:1,explanation:"Dijkstra calcule les plus courts chemins depuis une source unique, mais ne fonctionne qu'avec des poids positifs ou nuls."},{question:"L'algorithme de Bellman-Ford permet de :",answers:["Calculer les plus courts chemins avec poids n\xe9gatifs (sans cycle n\xe9gatif)","Trouver un cycle hamiltonien","Calculer un couplage maximum","Trier les sommets par degr\xe9"],correct:0,explanation:"Bellman-Ford fonctionne avec des poids n\xe9gatifs et peut d\xe9tecter les cycles de poids n\xe9gatif."},{question:"La complexit\xe9 de Dijkstra avec un tas binaire est :",answers:["$O(n^2)$","$O(n + p)$","$O((n + p) \\log n)$","$O(n^3)$"],correct:2,explanation:"Avec un tas binaire, chaque extraction du minimum co\xfbte $O(\\log n)$ et on fait $O(n + p)$ op\xe9rations au total."},{question:"La complexit\xe9 de Bellman-Ford est :",answers:["$O(n + p)$","$O(n \\cdot p)$","$O(n^2)$","$O(n^3)$"],correct:1,explanation:"Bellman-Ford effectue $n-1$ passes, chacune examinant toutes les $p$ ar\xeates, soit $O(n \\cdot p)$."},{question:"L'algorithme de Floyd-Warshall calcule :",answers:["Les plus courts chemins depuis une source","Les plus courts chemins entre toutes les paires de sommets","Un arbre couvrant minimum","Les composantes connexes"],correct:1,explanation:"Floyd-Warshall calcule les distances entre toutes les paires de sommets en O(n\xb3)."},{question:"La complexit\xe9 de Floyd-Warshall est :",answers:["$O(n^2)$","$O(n \\cdot p)$","$O(n^3)$","$O(n^2 \\log n)$"],correct:2,explanation:"Floyd-Warshall utilise trois boucles imbriqu\xe9es sur les $n$ sommets, d'o\xf9 $O(n^3)$."},{question:"Dijkstra ne fonctionne pas avec des poids n\xe9gatifs car :",answers:["Il ne peut pas trier les ar\xeates","Une fois un sommet trait\xe9, sa distance peut encore diminuer avec un poids n\xe9gatif","Il n\xe9cessite un graphe connexe","Il ne g\xe8re pas les cycles"],correct:1,explanation:"Dijkstra suppose qu'une fois un sommet extrait du tas, sa distance est d\xe9finitive. Un poids n\xe9gatif pourrait la r\xe9duire plus tard."},{question:"Pour d\xe9tecter un cycle de poids n\xe9gatif avec Bellman-Ford, on effectue :",answers:["n-1 passes de relaxation","Une n-i\xe8me passe qui ne devrait rien modifier s'il n'y a pas de cycle n\xe9gatif","Un parcours BFS","Une recherche de composantes fortement connexes"],correct:1,explanation:"Si une n-i\xe8me passe modifie encore une distance, c'est qu'il existe un cycle de poids n\xe9gatif."},{question:"L'op\xe9ration de relaxation d'une ar\xeate $(u, v)$ consiste \xe0 :",answers:["Supprimer l'ar\xeate $(u, v)$","Mettre \xe0 jour $d[v] = \\min(d[v], d[u] + w(u,v))$","Inverser le sens de l'ar\xeate","Ajouter un nouveau sommet"],correct:1,explanation:"La relaxation met \xe0 jour la distance estim\xe9e de $v$ si passer par $u$ donne un chemin plus court."},{question:"L'algorithme de Johnson pour les plus courts chemins entre toutes paires utilise :",answers:["Uniquement Dijkstra","Uniquement Bellman-Ford","Bellman-Ford puis $n$ appels \xe0 Dijkstra apr\xe8s repond\xe9ration","Floyd-Warshall puis Dijkstra"],correct:2,explanation:"Johnson utilise Bellman-Ford pour calculer une fonction de potentiel, puis repond\xe8re les ar\xeates pour avoir des poids positifs et applique Dijkstra depuis chaque sommet."}]})}function d(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(p,{...e})}):p()}},7146:(e,s,n)=>{n.d(s,{A:()=>c});var t=n(6540);const r={qcmContainer:"qcmContainer_FnPK",title:"title_OTr8",questionCard:"questionCard_Dptz",questionText:"questionText_Lk5S",answers:"answers_hmWU",answer:"answer_aiwq",correct:"correct_jYJv",incorrect:"incorrect_k4t6",answerText:"answerText_Jy_F",selected:"selected_s4DF",explanation:"explanation_htI1",actions:"actions_uLhF",submitButton:"submitButton_YtkZ",resetButton:"resetButton_PQiK",scoreDisplay:"scoreDisplay_OJ7r"};var a=n(2130),i=n(4848);function o(e){let{text:s}=e;const n=function(e){let s=e.replace(/\$\$([^$]+)\$\$/g,((e,s)=>{try{return a.A.renderToString(s,{throwOnError:!1,displayMode:!0})}catch{return`$$${s}$$`}}));return s=s.replace(/\$([^$]+)\$/g,((e,s)=>{try{return a.A.renderToString(s,{throwOnError:!1,displayMode:!1})}catch{return`$${s}$`}})),s}(s);return(0,i.jsx)("span",{dangerouslySetInnerHTML:{__html:n}})}function c(e){let{questions:s,title:n="QCM"}=e;const[a,c]=(0,t.useState)(new Array(s.length).fill(null)),[l,u]=(0,t.useState)(!1),[p,d]=(0,t.useState)(0),m=a.every((e=>null!==e));return(0,i.jsxs)("div",{className:r.qcmContainer,children:[(0,i.jsx)("h3",{className:r.title,children:n}),s.map(((e,s)=>(0,i.jsxs)("div",{className:r.questionCard,children:[(0,i.jsxs)("p",{className:r.questionText,children:[(0,i.jsxs)("strong",{children:["Question ",s+1,"."]})," ",(0,i.jsx)(o,{text:e.question})]}),(0,i.jsx)("div",{className:r.answers,children:e.answers.map(((n,t)=>{const u=a[s]===t,p=e.correct===t;let d=r.answer;return l?p?d=`${r.answer} ${r.correct}`:u&&!p&&(d=`${r.answer} ${r.incorrect}`):u&&(d=`${r.answer} ${r.selected}`),(0,i.jsxs)("label",{className:d,children:[(0,i.jsx)("input",{type:"radio",name:`question-${s}`,checked:u,onChange:()=>((e,s)=>{if(l)return;const n=[...a];n[e]=s,c(n)})(s,t),disabled:l}),(0,i.jsx)("span",{className:r.answerText,children:(0,i.jsx)(o,{text:n})})]},t)}))}),l&&e.explanation&&(0,i.jsxs)("div",{className:r.explanation,children:[(0,i.jsx)("strong",{children:"Explication :"})," ",(0,i.jsx)(o,{text:e.explanation})]})]},s))),(0,i.jsx)("div",{className:r.actions,children:l?(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)("div",{className:r.scoreDisplay,children:["Score : ",p,"/",s.length," (",Math.round(p/s.length*100),"%)"]}),(0,i.jsx)("button",{className:r.resetButton,onClick:()=>{c(new Array(s.length).fill(null)),u(!1),d(0)},children:"Recommencer"})]}):(0,i.jsx)("button",{className:r.submitButton,onClick:()=>{let e=0;s.forEach(((s,n)=>{a[n]===s.correct&&e++})),d(e),u(!0)},disabled:!m,children:"Valider"})})]})}}}]);