"use strict";(self.webpackChunkmpi_info=self.webpackChunkmpi_info||[]).push([[8851],{79696:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>b,contentTitle:()=>v,default:()=>y,frontMatter:()=>x,metadata:()=>r,toc:()=>q});const r=JSON.parse('{"id":"revisions/qcm_revisions","title":"QCM R\xe9visions","description":"<QCMRandom","source":"@site/docs/revisions/qcm_revisions.mdx","sourceDirName":"revisions","slug":"/revisions/qcm_revisions","permalink":"/mpi-info/docs/revisions/qcm_revisions","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"hide_table_of_contents":true,"hide_title":true,"title":"QCM R\xe9visions","sidebar_position":1},"sidebar":"revisions"}');var s=t(74848),i=t(28453),a=t(96540);const o={container:"container_v_Cp",title:"title_iefr",progressBar:"progressBar_UTOv",progressFill:"progressFill_DR_K",progressLabel:"progressLabel_Ar5z",questionCard:"questionCard_G5Y9",questionText:"questionText_Y8Ol",answers:"answers_ryeS",answer:"answer_AdNj",correct:"correct_vIDz",incorrect:"incorrect_et5a",answerText:"answerText_j0O0",selected:"selected_uLoI",missed:"missed_RMLl",multiHint:"multiHint_saEV",answerBtn:"answerBtn_euw1",answerContent:"answerContent_sivg",answerMark:"answerMark_nf9s",explanation:"explanation_QIHP",actions:"actions_UIPF",btnPrimary:"btnPrimary_ZI0M",btnSecondary:"btnSecondary_Dodb",finalScore:"finalScore_K998",scoreText:"scoreText_VHOs"};var l=t(22130),u=t(86025),c=t(71765);const d="v2";function p(e){return Array.isArray(e)}function m(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function $(e,n){const t=[];let r=e.replace(/```([a-zA-Z0-9_-]+)?\n([\s\S]*?)```/g,((e,n,r)=>{const s=n||"text",i=c.My.languages[s]||c.My.languages.markup;let a=r;try{a=c.My.highlight(r,i,s)}catch{a=m(r)}const o=`<pre class="prism-code language-${s}" style="margin:6px 0;"><code class="language-${s}">${a}</code></pre>`,l=`@@CODEBLOCK_${t.length}@@`;return t.push(o),l}));return r=r.replace(/<pre(?:\s+[^>]*)?>\s*<code\s+class=(?:"|')language-([a-zA-Z0-9_-]+)(?:"|')>([\s\S]*?)<\/code>\s*<\/pre>/g,((e,n,t)=>{const r=n||"text",s=c.My.languages[r]||c.My.languages.markup,i=t.replace(/<br\s*\/?\s*>/gi,"\n").replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&amp;/g,"&");let a=i;try{a=c.My.highlight(i,s,r)}catch{a=m(i)}return`<pre class="prism-code language-${r}" style="margin:6px 0;"><code class="language-${r}">${a}</code></pre>`})),r=r.replace(/\$\$([^$]+)\$\$/g,((e,n)=>{try{return l.A.renderToString(n,{throwOnError:!1,displayMode:!0})}catch{return`$$${n}$$`}})),r=r.replace(/\$([^$]+)\$/g,((e,n)=>{try{return l.A.renderToString(n,{throwOnError:!1,displayMode:!1})}catch{return`$${n}$`}})),r=r.replace(/`([^`]+)`/g,((e,n)=>`<code>${m(n)}</code>`)),r=r.replace(/\n/g,"<br>"),r=r.replace(/src='\/([^']+)'/g,((e,t)=>`src='${n}${t}'`)),r=r.replace(/src="\/([^"]+)"/g,((e,t)=>`src="${n}${t}"`)),r=r.replace(/@@CODEBLOCK_(\d+)@@/g,((e,n)=>t[Number(n)])),r}function g({text:e}){const n=(0,u.Ay)("/");return(0,s.jsx)("span",{dangerouslySetInnerHTML:{__html:$(e,n)}})}function h(e){const n=[...e];for(let t=n.length-1;t>0;t--){const e=Math.floor(Math.random()*(t+1));[n[t],n[e]]=[n[e],n[t]]}return n}function f({questions:e,title:n="QCM Algorithmes",repoOwner:t="mpi-lamartin",repoName:r="mpi-info"}){const[i,l]=(0,a.useState)((()=>h(e.map(((e,n)=>n))))),[u,c]=(0,a.useState)(0),[m,$]=(0,a.useState)(new Set),[f,x]=(0,a.useState)(!1),[v,b]=(0,a.useState)(0),[q,_]=(0,a.useState)(0),[y,w]=(0,a.useState)(!1),[L,P]=(0,a.useState)(!1),C=(0,a.useMemo)((()=>function(e){const n=JSON.stringify(e.map((e=>({question:e.question,answers:e.answers,correct:e.correct,explanation:e.explanation||""}))));let t=3735928559^n.length,r=1103547991^n.length;for(let s=0;s<n.length;s++){const e=n.charCodeAt(s);t=Math.imul(t^e,2654435761),r=Math.imul(r^e,1597334677)}return t=Math.imul(t^t>>>16,2246822507),t^=Math.imul(r^r>>>13,3266489909),r=Math.imul(r^r>>>16,2246822507),r^=Math.imul(t^t>>>13,3266489909),`${e.length}:${(r>>>0).toString(16)}:${(t>>>0).toString(16)}`}(e)),[e]),j=(0,a.useMemo)((()=>"undefined"==typeof window?null:`qcm-random:${d}:${window.location.pathname}:${n}`),[n]),S=e[i[u]],A=(N=S.correct,new Set(p(N)?N:[N]));var N;const k=p(S.correct),T=!k,U=e=>{x(!0),_((e=>e+1)),(e=>{if(e.size!==A.size)return!1;let n=!0;return A.forEach((t=>{e.has(t)||(n=!1)})),n})(e)&&b((e=>e+1))},O=()=>{U(m)},I=()=>{u+1>=i.length?w(!0):(c((e=>e+1)),$(new Set),x(!1))},M=()=>{l(h(e.map(((e,n)=>n)))),c(0),$(new Set),x(!1),b(0),_(0),w(!1)},D=q>0?Math.round(v/q*100):0;return(0,a.useEffect)((()=>{if(j)try{const n=window.localStorage.getItem(j);if(!n)return void P(!0);const t=JSON.parse(n);if(t.signature!==C)return void P(!0);if(!function(e,n){if(e.length!==n)return!1;const t=new Set;for(const r of e){if(!Number.isInteger(r)||r<0||r>=n)return!1;if(t.has(r))return!1;t.add(r)}return!0}(t.order,e.length))return void P(!0);const r=Math.min(Math.max(t.current,0),Math.max(t.order.length-1,0)),s=e[t.order[r]].answers.length-1,i=(t.selected||[]).filter((e=>Number.isInteger(e)&&e>=0&&e<=s));l(t.order),c(r),$(new Set(i)),x(Boolean(t.validated)),b(Math.max(0,t.correctCount||0)),_(Math.max(0,t.answeredCount||0)),w(Boolean(t.finished))}catch{}finally{P(!0)}else P(!0)}),[e,C,j]),(0,a.useEffect)((()=>{if(!L||!j)return;const e={signature:C,order:i,current:u,selected:Array.from(m),validated:f,correctCount:v,answeredCount:q,finished:y};try{window.localStorage.setItem(j,JSON.stringify(e))}catch{}}),[q,v,u,y,L,i,C,m,j,f]),(0,a.useEffect)((()=>{const e=e=>{if(!L)return;if((e.ctrlKey||e.metaKey)&&"Enter"===e.key&&!y){if(f)return I(),void e.preventDefault();O(),e.preventDefault()}};return window.addEventListener("keydown",e),()=>window.removeEventListener("keydown",e)}),[y,L,f,T,m]),L?y?(0,s.jsx)("div",{className:o.container,children:(0,s.jsxs)("div",{className:o.finalScore,children:[(0,s.jsx)("p",{children:"QCM termin\xe9 !"}),(0,s.jsxs)("p",{className:o.scoreText,children:["Score final :"," ",(0,s.jsxs)("strong",{children:[v,"/",q]})," ","(",D,"%)"]}),(0,s.jsx)("div",{className:o.actions,children:(0,s.jsx)("button",{className:o.btnSecondary,onClick:M,children:"Recommencer"})})]})}):(0,s.jsxs)("div",{className:o.container,children:[(0,s.jsx)("div",{className:o.progressBar,children:(0,s.jsx)("div",{className:o.progressFill,style:{width:(u+1)/i.length*100+"%"}})}),(0,s.jsxs)("div",{className:o.progressLabel,children:["Question ",u+1," / ",i.length," \xa0\u2014\xa0 Score :"," ",v,"/",q," (",D,"%)"]}),(0,s.jsxs)("div",{className:o.questionCard,children:[(0,s.jsxs)("div",{className:o.questionText,children:[(0,s.jsx)(g,{text:S.question}),k&&(0,s.jsxs)("span",{className:o.multiHint,children:[" ","(plusieurs r\xe9ponses possibles)"]})]}),(0,s.jsx)("div",{className:o.answers,children:S.answers.map(((e,n)=>{const t=m.has(n),r=A.has(n),i=f&&t?r?"\u2705":"\u274c":null;let a=o.answerBtn;return f?r?a=`${o.answerBtn} ${o.correct}`:t&&(a=`${o.answerBtn} ${o.incorrect}`):t&&(a=`${o.answerBtn} ${o.selected}`),(0,s.jsxs)("button",{className:a,onClick:()=>(e=>{if(!f)if(k){const n=new Set(m);n.has(e)?n.delete(e):n.add(e),$(n)}else{const n=new Set([e]);$(n),U(n)}})(n),disabled:f,children:[(0,s.jsx)("span",{className:o.answerContent,children:(0,s.jsx)(g,{text:e})}),i&&(0,s.jsx)("span",{className:o.answerMark,children:i})]},n)}))}),f&&S.explanation&&(0,s.jsxs)("div",{className:o.explanation,children:[(0,s.jsx)("strong",{children:"Explication :"})," ",(0,s.jsx)("br",{}),(0,s.jsx)(g,{text:S.explanation})]})]}),(0,s.jsxs)("div",{className:o.actions,children:[f?(0,s.jsx)("button",{className:o.btnPrimary,onClick:I,children:u+1>=i.length?"Voir le r\xe9sultat":"Question suivante (Ctrl+Enter)"}):!T&&(0,s.jsx)("button",{className:o.btnPrimary,onClick:O,children:"Valider (Ctrl+Enter)"}),(0,s.jsx)("button",{className:o.btnSecondary,onClick:()=>{const e=i[u]+1,n=S.question.length>1200?`${S.question.slice(0,1200)}...`:S.question,s=`QCM : erreur potentielle question #${e}`,a=p(S.correct)?S.correct:[S.correct],o=["## Contexte",`Index question (fichier source): ${e}`,"","## Question concern\xe9e","```text",n,"```","","## R\xe9ponses possibles",S.answers.map(((e,n)=>`  ${n+1}. ${e}`)),"","## R\xe9ponses correctes sur le site",a.map((e=>`  ${e+1}. ${S.answers[e]}`)),"","## Probl\xe8me","..."].join("\n"),l=`https://github.com/${t}/${r}/issues/new?title=${encodeURIComponent(s)}&body=${encodeURIComponent(o)}`;window.open(l,"_blank","noopener,noreferrer")},children:"Erreur ?"}),(0,s.jsx)("button",{className:o.btnSecondary,onClick:M,children:"Recommencer"})]})]}):(0,s.jsx)("div",{className:o.container,children:(0,s.jsx)("div",{className:o.progressLabel,children:"Chargement du QCM\u2026"})})}const x={hide_table_of_contents:!0,hide_title:!0,title:"QCM R\xe9visions",sidebar_position:1},v=void 0,b={},q=[];function _(e){return(0,s.jsx)(f,{title:"QCM R\xe9visions",questions:[{question:["Comment compl\xe9ter le code suivant pour que le programme termine et soit correct ?","```c","bool dichotomie(int e, int* T, int n) {","  int g = 0, d = n - 1;","  while (g <= d) {","    int m = ...;","    if (T[m] == e) return true;","    else if (e < T[m]) ...;","    else ...;","  }","  return false;","}","```"].join("\n"),answers:["m = (g + d) / 2;","m = (d - g) / 2;","else if (e < T[m]) g = m;","else if (e < T[m]) d = m;","else if (e < T[m]) g = m + 1;","else if (e < T[m]) d = m - 1;"],correct:[0,4],explanation:["Le milieu de $[g, d]$ est `m = (g + d) / 2`.","Si `e < T[m]`, alors `e` est dans la partie gauche, donc on met \xe0 jour `d = m - 1`.","Avec `d = m`, on peut avoir une boucle infinie (ex : `g = 0`, `d = 1`, alors `m = 0`, on met `d = m = 0`, puis `m = 0` \xe0 nouveau...)."].join("\n")},{question:["On ex\xe9cute le code C suivant. Quelle affirmation est correcte ?","```c","#include <stdio.h>","","int main() {","  for (unsigned int i = 3; i >= 0; i--)",'    printf("%u ", i);',"  return 0;","}","```"].join("\n"),answers:["Le programme ne compile pas.","Le programme ne termine pas.","Le programme a un comportement ind\xe9fini.","Le programme affiche `3 2 1`.","Le programme affiche `3 2 1 0`."],correct:1,explanation:["`i` est de type non sign\xe9 (entier positif) : la condition `i >= 0` est donc toujours vraie.","Quand `i` vaut `0`, l'op\xe9ration `i--` fait un calcul modulo $2^n$ et `i` devient `UINT_MAX`, puis la boucle continue.","Ce n'est pas un comportement ind\xe9fini : c'est le comportement normal des entiers non sign\xe9s en C."].join("\n")},{question:["Parmi les 4 arbres suivants, lesquels sont des arbres rouge-noirs ?",'<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;"><div style="text-align:center;"><img src="/img/qcm/rb-tree-1.svg" alt="Arbre 1" style="max-width:220px;width:100%;height:auto;"/><p style="margin:6px 0 0;">Arbre 1</p></div><div style="text-align:center;"><img src="/img/qcm/rb-tree-2.svg" alt="Arbre 2" style="max-width:220px;width:100%;height:auto;"/><p style="margin:6px 0 0;">Arbre 2</p></div><div style="text-align:center;"><img src="/img/qcm/rb-tree-3.svg" alt="Arbre 3" style="max-width:220px;width:100%;height:auto;"/><p style="margin:6px 0 0;">Arbre 3</p></div><div style="text-align:center;"><img src="/img/qcm/rb-tree-4.svg" alt="Arbre 4" style="max-width:220px;width:100%;height:auto;"/><p style="margin:6px 0 0;">Arbre 4</p></div></div>'].join("\n"),answers:["Arbre 1","Arbre 2","Arbre 3","Arbre 4"],correct:[0,3],explanation:["Arbre 1 et Arbre 4 sont valides.","Arbre 2 est invalide car il ne respecte pas la propri\xe9t\xe9 d'arbre binaire de recherche (le n\u0153ud 8 est dans le sous-arbre droit de 10).","Arbre 3 est invalide car les hauteurs noires ne sont pas \xe9gales sur tous les chemins de la racine \xe0 un emplacement Vide (10 - 5 - Vide a hauteur noire \xe9gale \xe0 1 alors que 10 - 5 - 2 - Vide a hauteur noire \xe9gale \xe0 2)."].join("\n")},{question:["Laquelle de ces fonctions est une fonction de r\xe9duction correcte de CH \xe0 CHO ?",'<div class="alert alert--secondary" role="note"><div class="alert__heading" style="margin-bottom:2px;"><h5 style="margin:0;">CH</h5></div><div class="alert__content" style="margin-top:0;"><strong>Entr\xe9e :</strong> un graphe non-orient\xe9 $G$<br><strong>Sortie :</strong> $G$ a t-il un cycle hamiltonien (passant par chaque sommet exactement une fois) ?</div></div>','<div class="alert alert--secondary" role="note"><div class="alert__heading" style="margin-bottom:2px;"><h5 style="margin:0;">CHO</h5></div><div class="alert__content" style="margin-top:0;"><strong>Entr\xe9e :</strong> un graphe orient\xe9 $G$<br><strong>Sortie :</strong> $G$ a t-il un cycle hamiltonien orient\xe9 ?</div></div>'].join("\n"),answers:["\xc0 un cycle hamiltonien $C$ de $G$, associer un cycle hamiltonien orient\xe9 en orientant les ar\xeates de $C$ arbitrairement.","\xc0 un cycle hamiltonien $C$ de $G$, associer un cycle hamiltonien orient\xe9 en orientant les ar\xeates de $C$ dans un sens de parcours.","\xc0 un graphe non-orient\xe9 $G$, associer un graphe orient\xe9 $G'$ en orientant chaque ar\xeate de $G$ dans un sens arbitraire.","\xc0 un graphe non-orient\xe9 $G$, associer un graphe orient\xe9 $G'$ en rempla\xe7ant chaque ar\xeate de $G$ par deux ar\xeates dans les deux sens."],correct:3,explanation:["Une fonction de r\xe9duction doit prendre et renvoyer une instance (pas une solution).","Il faut des ar\xeates dans les deux sens pour avoir l'\xe9quivalence de positivit\xe9 des instances."].join("\n")},{question:["On ex\xe9cute le code C suivant. Quel sch\xe9ma repr\xe9sente correctement l'\xe9tat m\xe9moire final ?","```c","int a = 1;","int b = 2;","int* p = &a;","int* q = &b;","*p = 3;","q = p;","*q = 4;","```",'<div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px;"><div><pre>+---+---+-----+-----+\n| a | b |  p  |  q  |\n+---+---+-----+-----+\n| 3 | 4 |  &amp;a |  &amp;b |\n+---+---+-----+-----+</pre><p style="text-align:center;margin:6px 0 0;">Sch\xe9ma 1</p></div><div><pre>+---+---+-----+-----+\n| a | b |  p  |  q  |\n+---+---+-----+-----+\n| 4 | 2 |  &amp;a |  &amp;a |\n+---+---+-----+-----+</pre><p style="text-align:center;margin:6px 0 0;">Sch\xe9ma 2</p></div><div><pre>+---+---+-----+-----+\n| a | b |  p  |  q  |\n+---+---+-----+-----+\n| 1 | 4 |  &amp;a |  &amp;b |\n+---+---+-----+-----+</pre><p style="text-align:center;margin:6px 0 0;">Sch\xe9ma 3</p></div><div><pre>+---+---+-----+-----+\n| a | b |  p  |  q  |\n+---+---+-----+-----+\n| 4 | 2 |  &amp;b |  &amp;a |\n+---+---+-----+-----+</pre><p style="text-align:center;margin:6px 0 0;">Sch\xe9ma 4</p></div></div>'].join("\n"),answers:["Sch\xe9ma 1","Sch\xe9ma 2","Sch\xe9ma 3","Sch\xe9ma 4"],correct:1,explanation:"Apr\xe8s `*p = 3`, on a `a = 3`. Puis `q = p` fait pointer `q` sur `a`. Enfin `*q = 4` modifie donc `a` (pas `b`). \xc9tat final : `a = 4`, `b = 2`, `p = &a`, `q = &a`."},{question:["On consid\xe8re le probl\xe8me d'optimisation COUPLAGE suivant ainsi qu'un probl\xe8me de d\xe9cision DCOUPLAGE associ\xe9 :",'<div class="alert alert--secondary" role="note"><div class="alert__heading" style="margin-bottom:2px;"><h5 style="margin:0;">COUPLAGE</h5></div><div class="alert__content" style="margin-top:0;"><strong>Entr\xe9e :</strong> un graphe biparti $G$<br><strong>Sortie :</strong> un couplage maximum de $G$</div></div>'].join("\n"),answers:['<div class="alert alert--secondary" role="note"><div class="alert__heading" style="margin-bottom:2px;"><h5 style="margin:0;">DCOUPLAGE</h5></div><div class="alert__content" style="margin-top:0;"><strong>Entr\xe9e :</strong> un graphe biparti $G$ et un entier $k$<br><strong>Sortie :</strong> est-ce que $G$ admet un couplage de cardinal inf\xe9rieur \xe0 $k$ ?</div></div>','<div class="alert alert--secondary" role="note"><div class="alert__heading" style="margin-bottom:2px;"><h5 style="margin:0;">DCOUPLAGE</h5></div><div class="alert__content" style="margin-top:0;"><strong>Entr\xe9e :</strong> un graphe biparti $G$ et un entier $k$<br><strong>Sortie :</strong> est-ce que $G$ admet un couplage de cardinal \xe9gal \xe0 $k$ ?</div></div>','<div class="alert alert--secondary" role="note"><div class="alert__heading" style="margin-bottom:2px;"><h5 style="margin:0;">DCOUPLAGE</h5></div><div class="alert__content" style="margin-top:0;"><strong>Entr\xe9e :</strong> un graphe biparti $G$ et un entier $k$<br><strong>Sortie :</strong> est-ce que $G$ admet un couplage de cardinal sup\xe9rieur \xe0 $k$ ?</div></div>',"DCOUPLAGE $\\in$ P","DCOUPLAGE $\\in$ NP","DCOUPLAGE $\\in$ NP-difficile","DCOUPLAGE $\\in$ NP-complet"],correct:[1,2,3,4],explanation:["Le premier probl\xe8me de d\xe9cision est trivial car il est toujours vrai : le couplage vide convient. Les deux autres d\xe9finitions sont possibles et appartiennent aux m\xeames classes de complexit\xe9.","DCOUPLAGE est dans P avec l'algorithme des chemins augmentants. Comme P $\\subset$ NP, DCOUPLAGE est aussi dans NP."].join("\n")},{question:["On ouvre le dossier `projet` dans un terminal :",'<div class="qcm-code-grid" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;"><div class="qcm-code-card"><pre><code>projet/\n\u251c\u2500\u2500 include/\n\u2502   \u2514\u2500\u2500 utils.h\n\u2514\u2500\u2500 src/\n    \u251c\u2500\u2500 main.c\n    \u2514\u2500\u2500 utils.c</code></pre><p>Fichiers</p></div><div class="qcm-code-card"><pre class="language-c"><code class="language-c">#ifndef UTILS_H\n#define UTILS_H\n\n...\n\n#endif</code></pre><p>utils.h</p></div><div class="qcm-code-card"><pre class="language-c"><code class="language-c">#include "../include/utils.h"\n\n...</code></pre><p>utils.c</p></div><div class="qcm-code-card"><pre class="language-c"><code class="language-c">#include "../include/utils.h"\n\nint main() { \n    ...\n}</code></pre><p>main.c</p></div></div>'].join("\n"),answers:["On peut compiler avec `gcc main.c utils.c`","`#ifndef UTILS_H` sert \xe0 \xe9viter des inclusions multiples","`utils.h` contient des d\xe9clarations, `utils.c` contient des impl\xe9mentations",'`#include "..."` cherche dans le dossier courant puis dans les dossiers du compilateur, alors que `#include <...>` cherche seulement dans les dossiers du compilateur'],correct:[1,2,3],explanation:["`gcc src/main.c src/utils.c` est n\xe9cessaire si la commande est lanc\xe9e depuis le dossier `projet`. Alternativement, on peut se placer dans `src` (`cd src`) puis faire `gcc main.c utils.c`.","`#ifndef UTILS_H` (if not defined) v\xe9rifie si `UTILS_H` n'est pas d\xe9fini. Si ce n'est pas le cas, il d\xe9finit `UTILS_H` et inclut le contenu du fichier. Cela permet d'\xe9viter les probl\xe8mes d'inclusion multiple qui peuvent survenir si un fichier est inclus plusieurs fois dans un projet.","Dans un projet structur\xe9, les fichiers `.h` contiennent g\xe9n\xe9ralement les d\xe9clarations de fonctions, de types et de macros, tandis que les fichiers `.c` contiennent les impl\xe9mentations de ces fonctions. Cela permet de s\xe9parer l'interface (d\xe9clarations) de l'impl\xe9mentation (d\xe9finitions) et facilite la maintenance du code.","L'instruction `#include \"...\"` indique au pr\xe9processeur de chercher le fichier d'en-t\xeate dans le r\xe9pertoire courant (o\xf9 se trouve le fichier source) avant de chercher dans les r\xe9pertoires standard du compilateur. En revanche, `#include <...>` indique au pr\xe9processeur de chercher uniquement dans les r\xe9pertoires standard du compilateur, ce qui est g\xe9n\xe9ralement utilis\xe9 pour inclure des biblioth\xe8ques standard ou des biblioth\xe8ques externes install\xe9es sur le syst\xe8me."].join("\n")},{question:["Avec le type OCaml suivant et `v` une variable de type `t`, quelles sont les syntaxes valides ?","```ocaml","type t = {x : int; a : int array}```"].join("\n"),answers:["`let w = {0; [|1; 2; 3|]}`","`let w = {x : 0; a : [|1; 2; 3|]}`","`let w = {x = 0; a = [|1; 2; 3|]}`","`v.x`","`v->x`","`v.x = 1`","`v.x <- 1`","`v.a.(0) = 1` (en supposant que `v.a` a au moins un \xe9l\xe9ment)","`v.a.(0) <- 1` (en supposant que `v.a` a au moins un \xe9l\xe9ment)"],correct:[2,3,5,6,7,8],explanation:"`v.x = 1` est une comparaison d'\xe9galit\xe9, tandis que `v.x <- 1` est une affectation qui ne fonctionne que si `v` est mutable. `v.a.(0) <- 1` est valide car un tableau est mutable. Par contre, `v.a <- ...` ne serait valide que si `v.a` \xe9tait mutable."},{question:["Quelles sont les lignes donnant une erreur (ou comportement ind\xe9fini) ?","```c","#include <stdio.h>","","typedef struct { int x; int* a; } t;","","t f() {","    t res;","    int x = 0;","    int a[] = {1, 2};","    res.x = x;","    res.a = a;","    return res;","}","","int main() {","    t res = f();",'    printf("%d", res.x);','    printf("%d", res.a[1]);',"    return 0;","}","```"].join("\n"),answers:["`int a[] = {1, 2};`","`res.x = x;`","`res.a = a;`",'`printf("%d", res.x);`','`printf("%d", res.a[1]);`'],correct:[4],explanation:['La ligne `printf("%d", res.a[1]);` est incorrecte car `res.a` pointe vers un tableau local qui est d\xe9truit \xe0 la fin de la fonction `f()`.',' Par contre, `printf("%d", res.x);` est correct car `res.x` est copi\xe9 dans la structure retourn\xe9e par `f()`.'].join("\n")},{question:['Apr\xe8s les lignes suivantes, que donne `printf("%d", x);`, `printf("%d", y);`, `printf("%d", z);` ?',"```c","int x = 0, y = 1;","if (y == 1) {","  int x, z = 2;","  x = 1;","  y = 2;","}","```"].join("\n"),answers:["`0, 1, 2`","`0, 2, 2`","`1, 1, 2`","`1, 2, 2`","`0, 1, erreur`","`0, 2, erreur`","`1, 1, erreur`","`1, 2, erreur`"],correct:[5],explanation:"La variable `z` est d\xe9clar\xe9e dans un bloc if, donc elle n'est accessible que dans ce bloc. Lorsque le programme sort du bloc, `z` n'est plus accessible, donc `printf(\"%d\", z);` affiche une erreur de compilation."},{question:"L'algorithme de d\xe9terminisation d'un automate \xe0 $n$ \xe9tats et $p$ transitions sur un alphabet de taille $k$ donne un automate avec :",answers:["$2^n$ \xe9tats et $p$ transitions","$2^n$ \xe9tats et $k2^n$ transitions","$n!$ \xe9tats et $p$ transitions","$n!$ \xe9tats et $k n!$ transitions"],correct:1,explanation:"L'automate des parties a $2^n$ \xe9tats (tous les sous-ensembles d'\xe9tats). Chaque \xe9tat de l'automate des parties a $k$ transitions (une par lettre de l'alphabet), soit au total $k 2^n$ transitions."},{question:["Quelles sont les valeurs possibles de `c` si deux threads ex\xe9cutent la fonction `f` ?","```c","int c = 10;","","void f() {","  for(int i = 0; i < 5; i++)","    c--;","}","```"].join("\n"),answers:["Seulement 0","De 0 \xe0 8","De 0 \xe0 9","De 0 \xe0 10"],correct:1,explanation:"Similaire au compteur du cours."},{question:"Quel algorithme est une variante de Dijkstra utilisant une heuristique estimant la distance restante au sommet cible pour explorer en priorit\xe9 les sommets les plus prometteurs ?",answers:["Bellman-Ford","Kruskal","A*","LZW"],correct:2,explanation:"A* utilise une heuristique pour guider la recherche vers le sommet cible plus efficacement que Dijkstra."},{question:"L'algorithme A* permet de :",answers:["Trouver un plus court chemin entre deux sommets en utilisant une heuristique","Calculer les composantes connexes d'un graphe","Trouver un arbre couvrant de poids minimum","Partitionner des donn\xe9es en classes"],correct:0,explanation:"A* combine le co\xfbt r\xe9el du chemin avec une heuristique estimant le co\xfbt restant pour guider efficacement la recherche."},{question:"Lesquels de ces algorithmes utilisent la programmation dynamique (ou m\xe9mo\xefsation) ?",answers:["Boyer-Moore","Calcul des attracteurs","Quine","Floyd-Warshall"],correct:[1,3],explanation:"Dans le calcul des attracteurs, pour \xe9viter de calculer plusieurs fois le m\xeame sommet. Dans Floyd-Warshall, avec une \xe9quation de r\xe9currence."},{question:"L'algorithme de Floyd-Warshall sur un graphe \xe0 $n$ sommets :",answers:["Utilise une r\xe9currence sur le nombre de sommets utilisable dans un plus court chemin","Utilise une r\xe9currence sur la longueur d'un plus court chemin","Est en O($n^3$)","Est en O($n\\log(n)$)"],correct:[0,2],explanation:"Floyd-Warshall r\xe9sout en $O(n^3)$ (3 boucles) le probl\xe8me des plus courts chemins entre toutes les paires de sommets en calculant la distance $d_k(u, v)$ de $u$ \xe0 $v$ utilisant les sommets $1, ..., k$."},{question:"Quel algorithme trouve les composantes fortement connexes d'un graphe orient\xe9 en effectuant deux parcours en profondeur (un sur le graphe et un sur le graphe transpos\xe9) ?",answers:["Kruskal","Dijkstra","Kosaraju","Prim"],correct:2,explanation:"Kosaraju effectue un premier parcours en profondeur pour obtenir un ordre de traitement, puis un second parcours en profondeur sur le graphe transpos\xe9."},{question:"L'algorithme de Kosaraju permet de :",answers:["Trouver un arbre couvrant de poids minimum","Calculer un couplage maximum","Trouver les composantes fortement connexes","Calculer les plus courts chemins"],correct:2,explanation:"Kosaraju identifie les composantes fortement connexes en utilisant deux parcours en profondeur."},{question:"La complexit\xe9 de l'algorithme de Kruskal avec Union-Find sur un graphe \xe0 $n$ sommets et $P$ ar\xeates est :",answers:["$O(np)$","$O(p \\log p)$","$O(np \\log p)$","$O(n + p)$"],correct:1,explanation:"Le tri des ar\xeates co\xfbte $O(p \\log p)$ ($= O(p \\log n)$). Les op\xe9rations Union-Find ont une complexit\xe9 amortie quasi-constante gr\xe2ce \xe0 l'union par rang et la compression de chemins."},{question:"Quel algorithme utilise des chemins augmentants ?",answers:["Kruskal","Recherche de couplage maximum","Kosaraju","Bellman-Ford"],correct:1,explanation:"L'algorithme cherche des chemins augmentants et applique la diff\xe9rence sym\xe9trique avec le couplage courant pour l'agrandir."},{question:"Un couplage $M$ dans un graphe $G = (S, A)$ est maximum si et seulement si :",answers:["Il n'y a pas de chemin alternant pour $M$","Il n'y a pas de chemin augmentant pour $M$","$\\forall e\\in A$, $M\\cup\\{e\\}$ n'est pas un couplage","Tous les sommets de $G$ sont couverts par $M$"],correct:1,explanation:"Par d\xe9finition, $M$ est maximum s'il n'y a pas de couplage de cardinal sup\xe9rieur (contenant plus d'ar\xeates). Si $C$ est un chemin augmentant, $M\\Delta C$ est un couplage de cardinal sup\xe9rieur \xe0 $M$."},{question:"Quel est l'algorithme le plus efficace pour trouver des plus courts chemins depuis un sommet fix\xe9 dans un graphe non pond\xe9r\xe9 ?",answers:["Parcours en largeur","Dijkstra","Parcours en profondeur","Floyd-Warshall"],correct:0,explanation:"Le parcours en largeur visite les sommets par distance croissante (en nombre d'ar\xeates) depuis un sommet de d\xe9part."},{question:"Quels algorithmes utilisent une file ?",answers:["Parcours en profondeur","Parcours en largeur","Huffman","LZW"],correct:[1],explanation:"Le parcours en largeur utilise une file pour explorer les sommets couche par couche. Huffman utilise une file de priorit\xe9. LZW un dictionnaire. Le parcours en profondeur peut utiliser une pile."},{question:"Un parcours en profondeur peut \xeatre utilis\xe9 pour :",answers:["L'algorithme min-max","Trouver un arbre couvrant","D\xe9tecter un cycle dans un graphe orient\xe9","Trouver un tri topologique"],correct:[0,1,2,3],explanation:"On peut parcourir l'arbre min-max en profondeur. L'ensemble des ar\xeates parcourues forme un arbre couvrant. On peut tester l'existence d'un arc arri\xe8re pour d\xe9tecter un cycle. L'algorithme de Kosaraju utilise deux DFS."},{question:"Quel type d'algorithme probabiliste renvoie toujours un r\xe9sultat correct mais avec un temps d'ex\xe9cution variable ?",answers:["Monaco","Monte-Carlo","Las Vegas","Los Angeles"],correct:2,explanation:"Un algorithme de Las Vegas est toujours correct mais son temps d'ex\xe9cution est al\xe9atoire. Exemple : tri rapide randomis\xe9."},{question:"Un algorithme de Las Vegas est un algorithme qui :",answers:["Peut renvoyer un r\xe9sultat incorrect mais s'ex\xe9cute en temps d\xe9terministe","Renvoie toujours un r\xe9sultat correct mais avec un temps d'ex\xe9cution al\xe9atoire","Garantit un facteur d'approximation constant mais s'ex\xe9cute en temps d\xe9terministe","Donne un facteur d'approximation variable mais avec un temps d'ex\xe9cution al\xe9atoire"],correct:1,explanation:"Las Vegas = toujours correct, temps variable. Exemple : quicksort randomis\xe9."},{question:"Lesquels sont des algorithmes de classification supervis\xe9e ?",answers:["$k$-moyennes","ID3","k plus proches voisins","Classification hi\xe9rarchique ascendante"],correct:[1,2],explanation:"$k$-moyennes et classification hi\xe9rarchique ascendante sont non-supervis\xe9s (pas de donn\xe9e d'entra\xeenement)."},{question:"Un arbre $k$-dimensionnel :",answers:["Permet de trouver efficacement des plus proches voisins","Permet de classifier des donn\xe9es","Est un arbre binaire de recherche","Est un arbre \xe9quilibr\xe9"],correct:[0,2,3],explanation:["Un arbre $k$-dimensionnel est obtenu en divisant r\xe9cursivement en deux (suivant un axe) des points dans $\\mathbb{R}^k$."," Il peut \xeatre utilis\xe9 pour trouver les voisins dans l'algorithme des $k$-plus proches voisins."].join("\n")},{question:"Dans l'algorithme des $k$-moyennes, $k$ d\xe9signe :",answers:["Le nombre de voisins","Le nombre de classes","Le nombre de donn\xe9es","La dimension de l'espace"],correct:1,explanation:"L'algorithme des $k$-moyennes est un algorithme de classification non supervis\xe9 qui partitionne les donn\xe9es en essayant de minimiser la distance aux centres des classes."},{question:"Quel algorithme de classification non supervis\xe9e fusionne it\xe9rativement les deux classes les plus proches, en partant d'une classe par donn\xe9e ?",answers:["$k$-moyennes","$k$ plus proches voisins","Classification hi\xe9rarchique ascendante","ID3"],correct:2,explanation:"CHA construit une hi\xe9rarchie de classes en fusionnant les plus proches \xe0 chaque \xe9tape."},{question:"La classification hi\xe9rarchique ascendante :",answers:["Pr\xe9dit la classe d'une donn\xe9e \xe0 partir de ses voisins","Fusionne it\xe9rativement les classes les plus proches","Construit un arbre de d\xe9cision par gain d'information","Met \xe0 jour alternativement classes et centres"],correct:1,explanation:"CHA part de $n$ classes (une par donn\xe9e) et fusionne les deux plus proches \xe0 chaque \xe9tape."},{question:"Quel algorithme de classification supervis\xe9e construit un arbre de d\xe9cision en choisissant \xe0 chaque n\u0153ud l'attribut maximisant le gain d'information ?",answers:["$k$NN","$k$-moyennes","CHA","ID3"],correct:3,explanation:"ID3 construit un arbre de d\xe9cision de mani\xe8re gloutonne en maximisant le gain d'entropie \xe0 chaque n\u0153ud."},{question:"Quel algorithme construit un automate reconnaissant le langage d'une expression r\xe9guli\xe8re en lin\xe9arisant l'expression ?",answers:["Automate produit","Berry-Sethi","Kleene","Thompson"],correct:1,explanation:"Berry-Sethi lin\xe9arise l'expression r\xe9guli\xe8re et construit un automate local reconnaissant le m\xeame langage."},{question:"Les langages r\xe9guliers sont stables par :",answers:["Compl\xe9mentaire","Diff\xe9rence","Intersection","Inclusion","Miroir"],correct:[0,1,2,4],explanation:["Compl\xe9mentaire : d\xe9terminiser l'automate puis inverser \xe9tats initiaux et finaux."," Diff\xe9rence et intersection : automate produit."," Miroir : inverser les transitions et les \xe9tats finaux/initiaux."," Inclusion : faux car tout langage contient $\\emptyset$ et est inclus dans $\\Sigma^*$."].join("\n")},{question:"Lesquels de ces langages sont r\xe9guliers ?",answers:["$\\{a^n b^p \\mid n, p \\in \\mathbb{N}\\}$","$\\{a^n b^n \\mid n \\in \\mathbb{N}\\}$","$\\{a^n b^p \\mid n = p \\mod 3\\}$","$\\{a^n b^p \\mid n < p\\}$"],correct:[0,2],explanation:["Le premier est $a^* b^*$."," Le 3\xe8me est reconnu par un automate produit \xe0 $4$ \xe9tats o\xf9 on arrive sur l'\xe9tat $(x, y)$ si le nombre de $a$ (resp. $b$) est \xe9gal \xe0 $x$ (resp. $y$)."," Le 2\xe8me et 4\xe8me ne sont pas r\xe9gulier par le lemme de l'\xe9toile."].join("\n")},{question:"Quel est le nombre d'ar\xeates d'un graphe complet non-orient\xe9 \xe0 $n$ sommets ?",answers:["$n!$","$n^2$","$n - 1$","$\\frac{n(n-1)}{2}$"],correct:3,explanation:"Un graphe complet non orient\xe9 \xe0 $n$ sommets a une ar\xeate entre chaque paire de sommets, soit $\\binom{n}{2} = \\frac{n(n-1)}{2}$ ar\xeates."},{question:"Quel algorithme d'exclusion mutuelle pour deux threads utilise un tableau `want` et une variable `turn` ?",answers:["Boulangerie de Lamport","Dekker","Peterson","Dijkstra"],correct:2,explanation:"Peterson utilise deux variables want (indiquant le souhait d'entrer en section critique) et turn (c\xe9dant la priorit\xe9)."},{question:"L'algorithme de la boulangerie de Lamport :",answers:["Impl\xe9mente un mutex pour $n$ threads","Impl\xe9mente un s\xe9maphore pour $n$ threads","Utilise un tableau `want` et une variable `turn`","Utilise un syst\xe8me de tickets pour g\xe9rer l'acc\xe8s \xe0 la section critique"],correct:[0,3],explanation:"Lamport g\xe9n\xe9ralise l'exclusion mutuelle \xe0 $n$ threads avec un m\xe9canisme de prise de ticket."},{question:"La programmation dynamique :",answers:["Diviser le probl\xe8me en sous-probl\xe8mes ind\xe9pendants","Choisit localement le meilleur choix \xe0 chaque \xe9tape","Utilise une relation de r\xe9currence","Stocke les r\xe9sultats interm\xe9diaires"],correct:[2,3],explanation:"La programmation dynamique utilise une relation de r\xe9currence et du stockage (m\xe9mo\xefsation ou tableau) pour \xe9viter les calculs redondants."},{question:"Quel algorithme glouton de compression construit un arbre binaire optimal o\xf9 les lettres fr\xe9quentes ont un code court ?",answers:["LZW","Rabin-Karp","Huffman","Boyer-Moore-Horspool"],correct:2,explanation:"Huffman construit un arbre de codage pr\xe9fixe optimal en fusionnant les deux symboles les moins fr\xe9quents \xe0 chaque \xe9tape."},{question:"Quel algorithme de compression en ligne construit un dictionnaire de motifs au fur et \xe0 mesure de la lecture du texte ?",answers:["Huffman","Rabin-Karp","Boyer-Moore-Horspool","LZW (Lempel-Ziv-Welch)"],correct:3,explanation:"LZW construit dynamiquement un dictionnaire et remplace les motifs d\xe9j\xe0 vus par des codes plus courts."},{question:"Quel algorithme de recherche de motif dans un texte utilise une fonction de hachage glissante (rolling hash) ?",answers:["Boyer-Moore-Horspool","Huffman","Rabin-Karp","LZW"],correct:2,explanation:"Rabin-Karp utilise un hash glissant pour comparer le motif \xe0 chaque fen\xeatre du texte en $O(n)$ en moyenne."},{question:"Quel algorithme de recherche de motif compare les caract\xe8res de droite \xe0 gauche et utilise une table de d\xe9calage pr\xe9calcul\xe9e ?",answers:["Rabin-Karp","Boyer-Moore-Horspool","Huffman","KMP"],correct:1,explanation:"Boyer-Moore-Horspool compare de droite \xe0 gauche et saute des positions gr\xe2ce \xe0 une table de d\xe9calage."},{question:"Quel algorithme r\xe9sout le probl\xe8me $\\texttt{SAT}$ par backtracking en affectant les variables et en simplifiant les clauses \xe0 chaque \xe9tape ?",answers:["Branch-and-bound","Alpha-beta","Quine","Calcul des attracteurs"],correct:2,explanation:"L'algorithme de Quine affecte chaque variable \xe0 vrai ou faux et simplifie les clauses \xe0 chaque \xe9tape par backtracking."},{question:"L'\xe9lagage alpha-b\xeata est une variante de min-max qui :",answers:["Explore en priorit\xe9 les branches d'heuristique la plus prometteuses","Coupe les branches qui ne peuvent pas influencer le r\xe9sultat final","Parcourt toutes les configurations du jeu","M\xe9morise les r\xe9sultats interm\xe9diaires pour \xe9viter les calculs redondants"],correct:1,explanation:"Alpha-b\xeata \xe9lague les branches inutiles de l'arbre de jeu en maintenant des bornes $\\alpha$ et $\\beta$."},{question:"Quelles sont les impl\xe9mentations efficaces d'une file de priorit\xe9 ?",answers:["Arbre binaire de recherche","Arbre $k$-dimensionnel","Tas","Table de hachage"],correct:[0,2],explanation:["Un tas binaire est un arbre binaire presque complet impl\xe9ment\xe9 par un tableau, avec insertion et extraction du minimum en $O(\\log n)$."," On peut aussi utiliser un arbre binaire de recherche (\xe9quilibr\xe9 \xe9ventuellement) en cherchant le minimum tout \xe0 gauche."].join("\n")},{question:"Soit $a = N(g, r, d)$ un arbre. $a$ est un arbre binaire de recherche si et seulement si :",answers:["$r$ est sup\xe9rieur aux \xe9tiquettes de $g$ et inf\xe9rieur aux \xe9tiquettes de $d$","$r$ est sup\xe9rieur \xe0 la racine de $g$ et inf\xe9rieur \xe0 la racine de $d$","Le parcours pr\xe9fixe de $a$ est tri\xe9 par ordre croissant","Le parcours infixe de $a$ est tri\xe9 par ordre croissant"],correct:[3],explanation:["La premi\xe8re condition n'est pas suffisante : il faut aussi que $g$ et $d$ soient des arbres binaires de recherche."," La deuxi\xe8me n'est pas bonne du tout.","Un arbre est un arbre binaire de recherche si et seulement si son parcours infixe est tri\xe9 par ordre croissant."].join("\n")},{question:"Quels algorithmes du cours utilisent une file de priorit\xe9 ?",answers:["Dijkstra","A*","Tri par tas","Huffman","BFS","Quine"],correct:[0,1,2,3],explanation:["Une file de priorit\xe9 est utilis\xe9e par Dijkstra et A* pour extraire le sommet le plus proche.","Un tas est une impl\xe9mentation d'une file de priorit\xe9.","Par Huffman pour fusionner les arbres de fr\xe9quences minimales."].join("\n")},{question:"Quelles sont des applications possibles d'Union-Find ?",answers:["Gestion de classes d'\xe9quivalence","Prim","Kruskal","Tester la connexit\xe9 d'un graphe"],correct:[0,2,3],explanation:"Union-Find stocke une partition dans un tableau de p\xe8res. Il est utilis\xe9 par Kruskal pour v\xe9rifier si une ar\xeate relie deux composantes distinctes (find) et pour les fusionner (union). On peut aussi l'utiliser pour g\xe9rer des classes d'\xe9quivalence ou tester la connexit\xe9 d'un graphe en v\xe9rifiant que tous les sommets sont dans la m\xeame classe."},{question:"Le lemme de l'\xe9toile :",answers:["Permet de choisir la d\xe9composition $u = xyz$","S'applique aux langages hors-contextes","Permet de prouver qu'un langage n'est pas r\xe9gulier","Permet de prouver qu'un langage est r\xe9gulier"],correct:[2],explanation:["Le lemme de l'\xe9toile est utilis\xe9 par l'absurde pour prouver qu'un langage n'est pas r\xe9gulier. ","La r\xe9ciproque est fausse donc on ne peut pas prouver qu'un langage est r\xe9gulier avec ce lemme. ","Il est faux pour les langages hors-contextes g\xe9n\xe9raux, qui ont un lemme de l'\xe9toile diff\xe9rent."].join("\n")},{question:"Tout automate est \xe9quivalent \xe0 :",answers:["Un automate d\xe9terministe complet","Un automate \xe9mond\xe9 (dont tous les \xe9tats sont accessibles et co-accessibles)","Un automate complet \xe9mond\xe9","Un automate d\xe9terministe \xe9mond\xe9 ","Un automate local","Un automate sans $\\epsilon$-transition"],correct:[0,1,3,5],explanation:["Tout automate est \xe9quivalent \xe0 un automate d\xe9terministe complet par l'algorithme de d\xe9terminisation. ","Tout automate est \xe9quivalent \xe0 un automate \xe9mond\xe9 en supprimant les \xe9tats inaccessibles ou non co-accessibles. ","Le langage $a$ sur l'alphabet $\\{a, b\\}$ ne peut pas \xeatre reconnu par un automate complet \xe9mond\xe9. ","Seuls les langages locaux sont reconnus par des automates locaux."].join("\n")},{question:"L'algorithme d'\xe9limination des \xe9tats :",answers:["Permet d'obtenir un automate minimal","Permet d'obtenir une expression r\xe9guli\xe8re","Permet d'obtenir un automate \xe9mond\xe9 (dont tous les \xe9tats sont accessibles et co-accessibles)","Permet d'obtenir un automate local"],correct:1,explanation:"L'algorithme d'\xe9limination des \xe9tats permet de transformer un automate en une expression r\xe9guli\xe8re \xe9quivalente en \xe9liminant les \xe9tats un par un et en mettant \xe0 jour les transitions avec des expressions r\xe9guli\xe8res."},{question:"Quelle est la structure de donn\xe9e utilis\xe9e dans le cours pour repr\xe9senter un tas ?",answers:["Tableau `T` o\xf9 `T[i]` est le p\xe8re de `T[2i+1]` et `T[2i+2]`","Tableau `T` o\xf9 `T[i]` est le p\xe8re de `i`","Type OCaml `type 'a arb = Empty | Node of 'a * 'a arb * 'a arb`","Dictionnaire associant \xe0 chaque sommet la liste de ses fils"],correct:0,explanation:["Un tas binaire est un arbre binaire presque complet, qui peut \xeatre repr\xe9sent\xe9 par un tableau `T` o\xf9 `T[i]` est le p\xe8re de `T[2i+1]` et `T[2i+2]`. Le p\xe8re de `T[j]` est `T[(j-1)/2]`."," Remarque : on peut aussi d\xe9finir un tas persistant (skew heap)."].join("\n")},{question:"Quelle est la structure de donn\xe9e utilis\xe9e pour repr\xe9senter une structure d'Union-Find ?",answers:["Tableau `T` o\xf9 `T[i]` est le p\xe8re de `T[2i+1]` et `T[2i+2]`","Tableau `T` o\xf9 `T[i]` est le p\xe8re de `i`","Type OCaml `type 'a arb = Empty | Node of 'a * 'a arb * 'a arb`","Dictionnaire associant \xe0 chaque sommet la liste de ses fils"],correct:1,explanation:"Union-Find est repr\xe9sent\xe9 par un tableau `T` o\xf9 `T[i]` est le p\xe8re de `i`. Les \xe9l\xe9ments d'une m\xeame classe d'\xe9quivalence forment un arbre dont la racine est un repr\xe9sentant de la classe."},{question:"Quel est le nombre d'ar\xeates d'un arbre \xe0 $n$ sommets ?",answers:["$n-1$","$n$","$2n-1$","$2n$"],correct:0,explanation:"Avec $G$ connexe $\\Rightarrow$ $n-1$ ar\xeates et $G$ acyclique $\\Rightarrow$ au plus $n-1$ ar\xeates."},{question:"Quelles structures de donn\xe9es permettent d'impl\xe9menter un dictionnaire ?",answers:["Arbre binaire de recherche","Table de hachage","Tas binaire","Union-Find"],correct:[0,1],explanation:"On peut utiliser un arbre binaire de recherche dont les \xe9tiquettes sont des couples (cl\xe9, valeur), avec des op\xe9rations O($h$). On peut aussi utiliser une table de hachage avec du O(1) en moyenne."},{question:"L'arbre de Huffman garantit :",answers:["Toutes les lettres ont un code de m\xeame longueur","Les lettres les plus fr\xe9quentes ont un code court ","L'arbre est \xe9quilibr\xe9","Une compression optimale","Un codage pr\xe9fixe (aucun code n'est pr\xe9fixe d'un autre)"],correct:[1,3,4],explanation:"Le codage de Huffman est un codage pr\xe9fixe (aucun code n'est pr\xe9fixe d'un autre) qui minimise la longueur moyenne."},{question:"Un arbre binaire presque complet dont chaque n\u0153ud est sup\xe9rieur ou \xe9gal \xe0 ses fils est :",answers:["Un arbre binaire de recherche","Un tas max","Un arbre min-max","Un arbre de Huffman"],correct:1,explanation:"C'est la d\xe9finition d'un tas max : arbre presque complet + propri\xe9t\xe9 de tas (n\u0153ud \u2265 fils)."},{question:"La compression de chemins dans Union-Find consiste \xe0 :",answers:["Trier les \xe9l\xe9ments de chaque classe","Rattacher tous les n\u0153uds du chemin directement \xe0 la racine lors d'un `find`","Fusionner les deux plus petites classes","Doubler la taille du tableau interne"],correct:1,explanation:"Lors d'un find, la compression de chemins rattache chaque n\u0153ud travers\xe9 directement \xe0 la racine, aplatissant l'arbre pour les requ\xeates futures."},{question:"Dans un arbre binaire strict (chaque n\u0153ud a soit 0 soit 2 fils) avec $f$ feuilles et $n_i$ n\u0153uds internes (non feuilles) :",answers:["$f = n_i$","$f = n_i + 1$","$f = 2n_i$","$f = 2n_i + 1$"],correct:1,explanation:"Par induction structurelle ou bijection."},{question:"Dans un arbre binaire de hauteur $h$ et \xe0 $n$ n\u0153uds (donner les meilleures bornes) :",answers:["$n \\leq 2^h - 1$","$n \\leq 2^{h+1} - 1$","$n \\geq h$","$n \\geq h + 1$"],correct:[1,3],explanation:"Il y a entre $1$ et $2^p$ n\u0153uds \xe0 la profondeur $p$, qu'on peut sommer."},{question:"Si $\\Pi_1 \\leq_p \\Pi_2$ alors :",answers:["Si $\\Pi_1 \\in$ P alors $\\Pi_2 \\in$ P","Si $\\Pi_2 \\in$ P alors $\\Pi_1 \\in$ P","Si $\\Pi_1 \\in$ NP alors $\\Pi_2 \\in$ NP","Si $\\Pi_2 \\in$ NP alors $\\Pi_1 \\in$ NP","Si $\\Pi_2\\in$ NP et $\\Pi_1$ est NP-complet alors $\\Pi_2$ est NP-complet","Si $\\Pi_1\\in$ NP et $\\Pi_2$ est NP-complet alors $\\Pi_1$ est NP-complet"],correct:[1,3,4],explanation:["Soit $\\varphi$ une r\xe9duction de $\\Pi_1$ \xe0 $\\Pi_2$. Si $\\Pi_2 \\in$ P, alors $\\Pi_1$ est dans P car on peut r\xe9soudre une instance $I$ de $\\Pi_1$ en r\xe9solvant $\\varphi(I)$ dans $\\Pi_2$.","Si $A$ est un v\xe9rificateur pour $\\Pi_2$, alors $A(\\varphi(I), c)$ est un v\xe9rificateur pour $\\Pi_1$.","Si $\\Pi_2$ est NP-complet et $\\Pi_1 \\in$ NP, alors $\\Pi_1$ est NP-complet par transitivit\xe9."].join("\n")},{question:"Un probl\xe8me est d\xe9cidable si :",answers:["Il peut \xeatre r\xe9solu en temps polynomial","Il existe un algorithme qui termine toujours et r\xe9pond correctement","Il appartient \xe0 NP","Il peut \xeatre v\xe9rifi\xe9 en temps polynomial"],correct:1,explanation:"Un probl\xe8me est d\xe9cidable s'il existe un algorithme (machine de Turing) qui termine toujours et donne la bonne r\xe9ponse."},{question:"Quelles relations sont connues concernant P et NP ?",answers:["P = NP","P $\\subset$ NP","NP $\\subset$ P","P et NP sont disjoints"],correct:1,explanation:"On sait que P $\\subset$ NP car un probl\xe8me r\xe9soluble en temps polynomial peut \xe9videmment \xeatre v\xe9rifi\xe9 en temps polynomial. La question P = NP reste ouverte."},{question:"Quels sont les probl\xe8mes NP-complets ?",answers:["$\\texttt{SAT}$","$\\texttt{2-SAT}$","$\\texttt{3-SAT}$","$\\texttt{FND-SAT}$ : $\\texttt{SAT}$ restreint aux formes normales disjonctives","Couplage maximum","Clique maximum","Arbre couvrant de poids maximum","Chemin de poids maximum"],correct:[0,2,5,7],explanation:["$\\texttt{SAT}$ est NP-complet d'apr\xe8s le th\xe9or\xe8me de Cook-Levin.","$\\texttt{2-SAT}$ et $\\texttt{FNC-SAT}$ sont dans P.","$\\texttt{3-SAT}$ est NP-complet par r\xe9duction depuis $\\texttt{SAT}$.","Couplage maximum est dans P (algorithme des chemins augmentants pour graphe biparti et algorithme hongrois dans le cas g\xe9n\xe9ral).","Clique maximum est NP-complet par r\xe9duction depuis $\\texttt{SAT}$ (ou $\\texttt{STABLE}$ comme dans le cours).","Un arbre couvrant de poids maximum peut \xeatre trouv\xe9 en triant les ar\xeates par poids d\xe9croissant dans Kruskal.","Chemin de poids maximum est NP-complet par r\xe9duction depuis $\\texttt{HAMILTONIEN}$."].join("\n")},{question:"On note $\\varphi \\equiv \\psi$ lorsque $\\varphi$ et $\\psi$ ont les m\xeames valuations positives. Lesquelles de ces identit\xe9s sont vraies ?",answers:["$\\lnot \\lnot \\varphi \\equiv \\varphi$","$\\varphi_1 \\lor (\\varphi_2 \\land \\varphi_3) \\equiv (\\varphi_1 \\lor \\varphi_2) \\land (\\varphi_1 \\lor \\varphi_3)$","$\\varphi_1 \\land (\\varphi_2 \\lor \\varphi_3) \\equiv (\\varphi_1 \\land \\varphi_2) \\lor (\\varphi_1 \\land \\varphi_3)$","$\\varphi_1 \\longrightarrow \\varphi_2 \\equiv \\lnot \\varphi_2 \\longrightarrow \\lnot \\varphi_1$","$\\lnot(\\varphi_1 \\land \\varphi_2) \\equiv \\lnot \\varphi_1 \\lor \\lnot \\varphi_2$","$\\lnot(\\varphi_1 \\lor \\varphi_2) \\equiv \\lnot \\varphi_1 \\land \\lnot \\varphi_2$"],correct:[0,1,2,3,4,5],explanation:"Par table de v\xe9rit\xe9 ou utilisation de la d\xe9finition de l'\xe9valuation d'une formule."},{question:"Si $f$ est une fonction de r\xe9duction polynomiale de $\\Pi_1 = (I_1, I_1^+)$ ($I_1$ : instances, $I_1^+$ : instances positives) \xe0 $\\Pi_2 = (I_2, I_2^+)$, alors :",answers:["$f : I_1 \\longrightarrow I_2$","$f : I_1^+ \\longrightarrow I_2^+$","$f(x)$ est calculable en temps polynomial en fonction de la taille de $x$","$f(x)$ est de taille polynomiale en fonction de la taille de $x$","$x \\in I_1^+ \\Longrightarrow f(x) \\in I_2^+$","$f(x) \\in I_2^+ \\Longrightarrow x \\in I_1^+$","$f^{-1}$ est une fonction de r\xe9duction polynomiale de $\\Pi_2$ \xe0 $\\Pi_1$"],correct:[0,2,3,4,5],explanation:["Une fonction de r\xe9duction polynomiale de $\\Pi_1$ \xe0 $\\Pi_2$ est une fonction $f : I_1 \\longrightarrow I_2$ telle que $f(x)$ est calculable en temps polynomial en fonction de la taille de $x$, et que $x \\in I_1^+$ si et seulement si $f(x) \\in I_2^+$.","La condition de taille polynomiale ne fait pas partie de la d\xe9finition mais est impliqu\xe9e par la condition de calculabilit\xe9 en temps polynomial.","$f$ n'est pas forc\xe9ment bijective et, m\xeame si c'\xe9tait le cas, $f^{-1}$ ne serait pas forc\xe9ment polynomiale."].join("\n")},{question:["Quelles sont les fa\xe7ons correctes de d\xe9finir une matrice $3\\times 4$ en C et modifier l'\xe9l\xe9ment ligne 2, colonne 3 ?",'<div class="qcm-code-grid" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;"><div class="qcm-code-card"><pre class="language-c"><code class="language-c">int m[3][4];\nm[2][3] = 5;</code></pre><p>Possibilit\xe9 1</p></div><div class="qcm-code-card"><pre class="language-c"><code class="language-c">int** m = malloc(3 * sizeof(int*));\nint* l = malloc(4 * sizeof(int));\nfor (int i = 0; i &lt; 3; i++)\n  m[i] = l;\nm[2][3] = 5;</code></pre><p>Possibilit\xe9 2</p></div><div class="qcm-code-card"><pre class="language-c"><code class="language-c">int m[12];\nm[2*4 + 3] = 5;</code></pre><p>Possibilit\xe9 3</p></div><div class="qcm-code-card"><pre class="language-c"><code class="language-c">int* m = malloc(12 * sizeof(int));\nm[2*4 + 3] = 5;</code></pre><p>Possibilit\xe9 4</p></div></div>'].join("\n"),answers:["Possibilit\xe9 1","Possibilit\xe9 2","Possibilit\xe9 3","Possibilit\xe9 4"],correct:[0,2,3],explanation:["La premi\xe8re est la syntaxe classique pour d\xe9clarer une matrice sur la pile en C.","La deuxi\xe8me est incorrecte car elle fait pointer toutes les lignes vers le m\xeame tableau (aliasing). Corrig\xe9 :","```c","int** m = malloc(3 * sizeof(int*));","for (int i = 0; i < 3; i++)","  m[i] = malloc(4 * sizeof(int));","m[2][3] = 5;","```","La troisi\xe8me est correcte par lin\xe9arisation d'une matrice 2D avec un tableau 1D.","La quatri\xe8me est correcte par lin\xe9arisation d'une matrice 2D avec un tableau 1D allou\xe9 dynamiquement."].join("\n")},{question:["Quelles sont les syntaxes raisonnables apr\xe8s le code suivant ?","```c","int* x = malloc(sizeof(int));","int* y = malloc(sizeof(int));","typedef struct {","  int a;","} s;","s* p = malloc(sizeof(s));","```"].join("\n"),answers:["`x = y;`","`x = &y;`","`&x = y;`","`*x = y;`","`x = *y;`","`*x = *y;`","`p.a = 5;`","`p->a = 5;`","`(*p).a = 5;`"],correct:[0,5,7,8],explanation:["`x = y;` est correct : `x` et `y` pointent alors vers le m\xeame emplacement m\xe9moire.","`x = &y;` est incorrect : `&y` est de type `int**` alors que `x` est de type `int*`.","`&x = y;` est incorrect : on ne peut pas assigner \xe0 une adresse.","`*x = y;` est incorrect : `*x` est de type `int` alors que `y` est de type `int*`.","`x = *y;` est incorrect : `*y` est de type `int` alors que `x` est de type `int*`.","`*x = *y;` est correct : on copie la valeur enti\xe8re point\xe9e par `y` dans la case point\xe9e par `x`.","`p.a = 5;` est incorrect : `p` est un pointeur (`s*`), il faut utiliser `->` et non `.`.","`p->a = 5;` est correct.","`(*p).a = 5;` est correct (\xe9quivalent \xe0 `p->a = 5`)."].join("\n")},{question:"Si $\\Pi_1$ se r\xe9duit \xe0 $\\Pi_2$ alors :",answers:["$\\Pi_1 \\leq \\Pi_2$","$\\Pi_2 \\leq \\Pi_1$","Il existe une fonction de r\xe9duction de $\\Pi_1$ \xe0 $\\Pi_2$","Il existe une fonction de r\xe9duction de $\\Pi_2$ \xe0 $\\Pi_1$","$\\Pi_1$ ind\xe9cidable $\\Longrightarrow \\Pi_2$ ind\xe9cidable","$\\Pi_2$ ind\xe9cidable $\\Longrightarrow \\Pi_1$ ind\xe9cidable","$\\Pi_1$ NP-complet $\\Longrightarrow \\Pi_2$ NP-complet","$\\Pi_2$ NP-complet $\\Longrightarrow \\Pi_1$ NP-complet"],correct:[0,2,4],explanation:["$\\Pi_1 \\leq \\Pi_2$ signifie que $\\Pi_1$ se r\xe9duit \xe0 $\\Pi_2$, c'est-\xe0-dire qu'il existe une fonction de r\xe9duction de $\\Pi_1$ \xe0 $\\Pi_2$.","Par cons\xe9quent, si $\\Pi_1$ est ind\xe9cidable, alors $\\Pi_2$ doit \xe9galement \xeatre ind\xe9cidable, car sinon on pourrait r\xe9soudre $\\Pi_1$ en utilisant la r\xe9duction vers $\\Pi_2$"," Il faut que la r\xe9duction soit polynomiale et avoir l'appartenance \xe0 NP pour conclure sur les probl\xe8mes NP-complets."].join("\n")},{question:"Le lemme de l'\xe9toile sur un langage r\xe9gulier $L$ s'\xe9nonce ainsi :",answers:["$\\forall u \\in L, \\exists n \\in \\mathbb{N}, |u| \\geq n \\Longrightarrow \\exists x, y, z \\in \\Sigma^*, u = xyz, |xy| \\leq n, |y| > 0, \\forall k \\in \\mathbb{N}, xy^k z \\in L$","$\\exists n \\in \\mathbb{N}, \\forall u \\in L, |u| \\geq n \\Longrightarrow \\exists x, y, z \\in \\Sigma^*, u = xyz, |xy| \\leq n, |y| > 0, \\forall k \\in \\mathbb{N}, xy^k z \\in L$","$\\forall u \\in L, \\exists n \\in \\mathbb{N}, |u| \\geq n \\Longrightarrow \\forall x, y, z \\in \\Sigma^*, u = xyz, |xy| \\leq n, |y| > 0, \\forall k \\in \\mathbb{N}, xy^k z \\in L$","$\\exists n \\in \\mathbb{N}, \\forall u \\in L, |u| \\geq n \\Longrightarrow \\forall x, y, z \\in \\Sigma^*, u = xyz, |xy| \\leq n, |y| > 0, \\forall k \\in \\mathbb{N}, xy^k z \\in L$"],correct:1,explanation:"En cas de doute, revenir \xe0 la d\xe9monstration du lemme de l'\xe9toile."},{question:"Quels sont les langages hors-contextes ?",answers:["$\\{a^n b^p \\mid n, p \\in \\mathbb{N}\\}$","$\\{a^n b^n \\mid n \\in \\mathbb{N}\\}$","$\\{a^n b^p \\mid n \\leq p \\}$","$\\{a^n b^n c^n \\mid n \\in \\mathbb{N}\\}$"],correct:[0,1,2],explanation:["Le premier est r\xe9gulier donc hors-contexte.","Le second est engendr\xe9 par $S \\Longrightarrow aSb \\mid \\epsilon$.","Le troisi\xe8me est engendr\xe9 par $S \\Longrightarrow aSb \\mid bS \\mid \\epsilon$.","Le quatri\xe8me n'est pas hors-contexte par le lemme de l'\xe9toile pour les langages hors-contextes (voir TD)."].join("\n")},{question:"Une grammaire $G$ est ambig\xfce si et seulement si :",answers:["Il existe un mot de $L(G)$ ayant au moins deux arbres de d\xe9rivation diff\xe9rents","Tous les mots de $L(G)$ ont au moins deux arbres de d\xe9rivation diff\xe9rents","Il existe un mot de $L(G)$ ayant au moins deux d\xe9rivations gauches diff\xe9rentes","Tous les mots de $L(G)$ ont au moins deux d\xe9rivations gauches diff\xe9rentes"],correct:[0,2],explanation:"Cours."},{question:"Les grammaires non-contextuelles sont stables par :",answers:["Inclusion","Union","Concat\xe9nation","\xc9toile","Intersection","Compl\xe9mentaire","Diff\xe9rence","Miroir"],correct:[1,2,3,7],explanation:["Les langages hors-contextes sont stables par union, concat\xe9nation, \xe9toile, miroir (cours).","Ils ne sont pas stables par intersection, compl\xe9mentaire ou diff\xe9rence (voir TD) ni par inclusion."].join("\n")},{question:"Toute formule logique est \xe9quivalente \xe0 :",answers:["Une formule en forme normale conjonctive (FNC)","Une formule en forme normale disjonctive (FND)","Une formule en forme normale n\xe9gative (o\xf9 les n\xe9gations ne sont appliqu\xe9es qu'\xe0 des variables)","Une formule n'utilisant pas $\\longrightarrow$","Une formule n'utilisant que les connecteurs $\\land$ et $\\lnot$"],correct:[0,1,2,4],explanation:["Toute formule est \xe9quivalente \xe0 une FNC et \xe0 une FND, en passant par une table de v\xe9rit\xe9.","Par induction et en poussant les n\xe9gations vers les variables, on obtient une formule \xe9quivalente en forme normale n\xe9gative.","En utilisant les \xe9quivalences $\\varphi \\longrightarrow \\psi \\equiv \\lnot \\varphi \\lor \\psi$ et $\\lnot(\\varphi_1 \\land \\varphi_2) \\equiv \\lnot \\varphi_1 \\lor \\lnot \\varphi_2$, on peut \xe9liminer les connecteurs $\\longrightarrow$ et $\\lor$ pour n'avoir que $\\land$ et $\\lnot$."].join("\n")},{question:"On note $e_1 \\equiv e_2$ lorsque les expressions r\xe9guli\xe8res $e_1$ et $e_2$ reconnaissent le m\xeame langage. Lesquelles de ces identit\xe9s sont vraies ?",answers:["$(e^*)^* \\equiv e^*$","$(e_1 \\mid e_2)^* \\equiv e_1^* \\mid e_2^*$","$(e_1 e_2)^* \\equiv e_1^* e_2^*$","$e_1 (e_2 \\mid e_3) \\equiv e_1 e_2 \\mid e_1 e_3$","$e_1 \\mid (e_2 e_3) \\equiv e_1 e_2 \\mid e_1 e_3$"],correct:[0,3],explanation:["On montre la premi\xe8re avec la d\xe9finition."," Si $e_1 = a^*$ et $e_2 = b^*$ alors $(e_1 \\mid e_2)^* \\not\\equiv e_1^* \\mid e_2^*$. Similaire pour les autres r\xe9ponses."].join("\n")},{question:"Quelles affirmations sont vraies ?",answers:["$\\emptyset$ est une lettre","$\\emptyset$ est un mot","$\\emptyset$ est un langage","$\\epsilon$ est une lettre","$\\epsilon$ est un mot","$\\epsilon$ est un langage"],correct:[2,4,5],explanation:["$\\emptyset$ n'est ni une lettre ni un mot, mais un langage (le langage vide).","$\\epsilon$ est le mot vide mais peut aussi d\xe9signer un langage par abus de notation, sur les expression r\xe9guli\xe8re : l'ensemble $\\{\\epsilon\\}$."].join("\n")},{question:"Un automate produit de deux automates $A_1$ et $A_2$ d'\xe9tats $Q_1$ et $Q_2$ :",answers:["Poss\xe8de $Q_1 \\times Q_2$ comme ensemble d'\xe9tats","Peut permettre de reconna\xeetre $L(A_1)L(A_2)$","Peut permettre de reconna\xeetre $L(A_1) \\cup L(A_2)$","Peut permettre de reconna\xeetre $L(A_1) \\cap L(A_2)$","Peut permettre de reconna\xeetre $L(A_1) \\setminus L(A_2)$","Peut permettre de reconna\xeetre $L(A_1) \\Delta L(A_2)$"],correct:[0,2,3,4,5],explanation:["L'automate produit a bien $Q_1 \\times Q_2$ comme \xe9tats. En ajustant les \xe9tats finaux, il permet de reconna\xeetre l'union, l'intersection, la diff\xe9rence et la diff\xe9rence sym\xe9trique. En revanche, la concat\xe9nation $L(A_1)L(A_2)$ ne se fait pas avec un simple produit.","Attention : les deux automates doivent \xeatre d\xe9terministes pour que le produit permette de reconnaitre ces langages."].join("\n")},{question:"Si $\\Pi \\in$ NP :",answers:["On ne sait pas le r\xe9soudre en temps polynomial","Il peut \xeatre r\xe9solu en temps exponentiel","Il peut \xeatre r\xe9solu en espace polynomial","Pour chaque instance de $\\Pi$, on peut cr\xe9er un certificat en temps polynomial"],correct:[1,2],explanation:["Tout probl\xe8me de P est dans NP.","Un probl\xe8me de NP peut toujours \xeatre r\xe9solu en temps exponentiel (\xe9num\xe9ration des certificats) et en espace polynomial (r\xe9utilisation de l'espace pour v\xe9rifier chaque certificat).","Le v\xe9rificateur doit v\xe9rifier en temps polynomial un certificat, pas le cr\xe9er."].join("\n")},{question:"\xc0 quoi s'\xe9value l'expression `0.1 +. 0.2 = 0.3` en OCaml ?",answers:["Une erreur car il faut utiliser `==`","Une erreur car il faut utiliser `=.` sur des flottants","`false`","`true`"],correct:2,explanation:"Les flottants sont stock\xe9s en base 2 et `0.1` n'a pas d'\xe9criture exacte en base 2, donc les comparaisons d'\xe9galit\xe9 stricte peuvent \xe9chouer \xe0 cause des erreurs d'arrondi sur les flottants."},{question:"La suite de bits $10110$ peut repr\xe9senter :",answers:["22","-10 en compl\xe9ment \xe0 2","Un rationnel","Un caract\xe8re"],correct:[0,1,2,3],explanation:"$10110$ vaut 22 en non sign\xe9. Sur 5 bits en compl\xe9ment \xe0 2, cela repr\xe9sente -10. Cette suite peut aussi coder une valeur rationnelle selon un format flottant donn\xe9, et peut repr\xe9senter un caract\xe8re selon un encodage choisi."},{question:"Une fonction de hachage peut \xeatre utilis\xe9e pour :",answers:["La s\xe9curit\xe9 informatique","La reconnaissance de motif dans un texte","La m\xe9mo\xefsation","Acc\xe9l\xe9rer l'algorithme des $k$ plus proches voisins"],correct:[0,1,2],explanation:["En s\xe9curit\xe9 pour \xe9viter de stocker les mots de passe en clair.","En reconnaissance de motif, comme dans l'algorithme de Rabin-Karp.","En m\xe9mo\xefsation pour stocker les r\xe9sultats interm\xe9diaires d'une fonction r\xe9cursive."].join("\n")},{question:"Quelles structures sont persistantes ?",answers:["Liste","Tableau","Arbre binaire avec `type 'a arb = Empty | Node of 'a * 'a arb * 'a arb`","Tas binaire comme dans le cours","Cha\xeene de caract\xe8res en C","Cha\xeene de caract\xe8res en OCaml"],correct:[0,2,5],explanation:["Les listes et arbres OCaml sont persistants, et les cha\xeenes OCaml sont immuables."," Les tableaux, tas binaires classiques et cha\xeenes (tableaux de caract\xe8res) C sont mutables."].join("\n")},{question:"Les arbres rouge-noirs :",answers:["Sont des arbres binaires de recherche","Sont des tas","Sont \xe9quilibr\xe9s","Maintiennent l'invariant : les deux fils de chaque n\u0153ud sont de hauteur \xe9gales +/- 1","Permettent d'impl\xe9menter un dictionnaire","Utilisent une op\xe9ration de rotation pour maintenir l'\xe9quilibre"],correct:[0,2,4,5],explanation:["Les arbres rouge-noirs sont des arbres binaires de recherche auto-\xe9quilibr\xe9s, qui maintiennent une contrainte de coloration pour garantir que la hauteur est logarithmique.","Ils permettent d'impl\xe9menter un dictionnaire avec des op\xe9rations en O($\\log n$). Les rotations sont utilis\xe9es pour r\xe9\xe9quilibrer l'arbre apr\xe8s les insertions ou suppressions.","L'invariant est celui des AVL."].join("\n")},{question:"Sur un graphe non-orient\xe9 $G = (S, A)$ \xe0 $n$ sommets et $p$ ar\xeates :",answers:["$\\sum_{v \\in S} \\deg(v) = p$","$\\sum_{v \\in S} \\deg(v) = 2p$","$G$ a un nombre pair de sommets de degr\xe9 impair","$G$ a un nombre impair de sommets de degr\xe9 pair","$G$ connexe $\\Longrightarrow p \\geq n-1$","$p \\geq n-1 \\Longrightarrow G \\text{ connexe}$","$G$ acyclique $\\Longrightarrow p \\leq n-1$","$p \\leq n-1 \\Longrightarrow G \\text{ acyclique}$"],correct:[1,2,4,6],explanation:"La plupart par r\xe9currence. Voir cours."},{question:"Quels algorithmes utilisent la m\xe9thode diviser pour r\xe9gner ?",answers:["Algorithme de tri rapide","Algorithme de tri fusion","Algorithme de recherche par dichotomie dans un tableau tri\xe9","Algorithme de construction d'un arbre $k$-d","Algorithme ID3"],correct:[0,1,2,3,4],explanation:"Ces algorithmes divisent le probl\xe8me en sous-probl\xe8mes, les r\xe9solvent r\xe9cursivement puis combinent les r\xe9sultats."},{question:"Quelles sont les bonnes r\xe9solutions d'\xe9quation de complexit\xe9 ?",answers:["$C(n) = C(\\frac{n}{2}) + 1 \\Longrightarrow C(n) = O(\\log n)$","$C(n) = C(\\frac{n}{2}) + 1 \\Longrightarrow C(n) = O(n)$","$C(n) = C(\\frac{n}{2}) + n \\Longrightarrow C(n) = O(n \\log n)$","$C(n) = C(\\frac{n}{2}) + n \\Longrightarrow C(n) = O(n^2)$","$C(n) = 2C(\\frac{n}{2}) + 1 \\Longrightarrow C(n) = O(n)$","$C(n) = 2C(\\frac{n}{2}) + 1 \\Longrightarrow C(n) = O(n \\log n)$","$C(n) = 2C(\\frac{n}{2}) + n \\Longrightarrow C(n) = O(n \\log n)$","$C(n) = 2C(\\frac{n}{2}) + n \\Longrightarrow C(n) = O(n^2)$","$C(n) = 2 C(n-1) + 1 \\Longrightarrow C(n) = O(n^2)$","$C(n) = 2 C(n-1) + 1 \\Longrightarrow C(n) = O(2^n)$"],correct:[0,3,4,6,9],explanation:"$$C(n) \\leq C(\\frac{n}{2}) + 1 \\leq C(\\frac{n}{4}) + 1 + 1 \\leq \\dots \\leq C\\left(\\frac{n}{2^{\\lfloor \\log_2(n) \\rfloor}}\\right) + \\lfloor \\log_2(n) \\rfloor = O(\\log n)$$ $$C(n) = C(\\frac{n}{2}) + n = C(1) + n\\times \\sum_{k=0}^{\\lfloor \\log_2(n) \\rfloor - 1} \\frac{1}{2^k} \\leq C(1) + 2n$$ $$C(n) \\leq 2C(\\frac{n}{2}) + 1 \\leq 4C(\\frac{n}{4}) + 2 + 1 \\leq \\dots \\leq 2^{\\lfloor \\log_2(n) \\rfloor} C\\left(\\frac{n}{2^{\\lfloor \\log_2(n) \\rfloor}}\\right) + \\sum_{k=0}^{\\lfloor \\log_2(n) \\rfloor - 1} 2^k = O(n)$$ $$C(n) = 2C(n-1) + 1 = 4C(n-2) + 2 + 1 = \\dots = 2^{n-1}C(1) + \\sum_{k=0}^{n-2} 2^k = O(2^n)$$"},{question:"Pour rechercher si un motif appara\xeet dans un texte, on peut utiliser :",answers:["Un automate","L'algorithme de Lempel-Ziv-Welch","L'algorithme de Rabin-Karp","L'algorithme de Boyer-Moore","L'algorithme de Huffman"],correct:[0,2,3],explanation:["On peut construire l'automate reconnaissant $\\Sigma^*m\\Sigma^*$, o\xf9 $m$ est le motif. "," LZW et Huffman sont des algorithmes de compression."].join("\n")},{question:"Un ordre topologique d'un graphe orient\xe9 $G$ :",answers:["Existe si et seulement si $G$ est acyclique","Est unique s'il existe","Peut \xeatre calcul\xe9 comme l'inverse d'un parcours en profondeur pr\xe9fixe","Peut \xeatre calcul\xe9 en temps $O(|S| + |A|)$","Peut \xeatre utilis\xe9 pour l'algorithme de Kosaraju","Peut servir pour r\xe9soudre un probl\xe8me par programmation dynamique"],correct:[0,1,3,4,5],explanation:["Un ordre topologique est un ordre lin\xe9aire des sommets tel que pour chaque ar\xeate $(u, v)$, $u$ pr\xe9c\xe8de $v$.","Un tel ordre existe si et seulement si le graphe est acyclique (cours).","Il n'est pas forc\xe9ment unique.","On peut le calculer comme inverse d'un parcours en profondeur post-ordre (pas pr\xe9fixe).","Il peut \xeatre calcul\xe9 en O($|S| + |A|$) si le graphe repr\xe9sent\xe9 par liste d'adjacence.","L'algorithme de Kosaraju utilise un ordre de post-ordre pour trouver les composantes fortement connexes.","Dans une r\xe9solution de probl\xe8me par programmation dynamique, on peut repr\xe9senter les d\xe9pendances entre les sous-probl\xe8mes par un graphe orient\xe9 acyclique. Un ordre topologique donne alors un ordre des sous-probl\xe8mes \xe0 r\xe9soudre."].join("\n")},{question:"Un couplage $M$ d'un graphe \xe0 $n$ sommets v\xe9rifie :",answers:["$M$ ne contient pas deux ar\xeates adjacentes.","$M$ ne contient pas deux sommets adjacents.","Le nombre d'ar\xeates de $M$ est au plus $\\lfloor \\frac{n}{2} \\rfloor$.","Le nombre de sommets de $M$ est au plus $\\lfloor \\frac{n}{2} \\rfloor$."],correct:[0,2],explanation:"Un couplage est un ensemble d'ar\xeates sans sommets communs, donc chaque sommet est adjacent \xe0 au plus une ar\xeate du couplage. Par cons\xe9quent, le nombre d'ar\xeates dans un couplage est limit\xe9 par la moiti\xe9 du nombre de sommets, soit $\\lfloor \\frac{n}{2} \\rfloor$."},{question:"Un graphe $G$ est biparti si et seulement si :",answers:["Il ne contient pas de cycle de longueur paire","Il ne contient pas de cycle de longueur impaire","Il est 2-coloriable","Il est 3-coloriable","Il contient un couplage parfait"],correct:[1,2],explanation:["$G$ est biparti si on peut s\xe9parer les sommets en deux ensembles disjoints tels que toutes les ar\xeates relient un sommet de l'un \xe0 un sommet de l'autre. Cela \xe9quivaut \xe0 dire qu'il est 2-coloriable. ","Si un graphe ne contient pas de cycle de longueur impaire, un parcours de graphe en alternant les couleurs des sommets permet de 2-colorer le graphe."].join("\n")},{question:"L'algorithme des $k$-moyennes :",answers:["Est un algorithme d'apprentissage supervis\xe9","Converge toujours","Converge vers une solution optimale","Ne reconna\xeet pas les classes non convexes"],correct:[1,3],explanation:"C'est de la classification non-supervis\xe9e (pas de donn\xe9e d'entra\xeenement). $k$-moyennes converge mais pas forc\xe9ment vers l'optimum global. Il ne reconna\xeet pas bien les classes non convexes (ex. classes concentriques). "}]})}function y(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(_,{...e})}):_()}}}]);