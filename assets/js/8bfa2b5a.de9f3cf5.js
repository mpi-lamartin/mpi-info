(self.webpackChunkmpi_info=self.webpackChunkmpi_info||[]).push([[2359],{7657:(e,n,t)=>{var l={"./dm_fft.pdf":3775};function i(e){var n=r(e);return t(n)}function r(e){if(!t.o(l,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return l[e]}i.keys=function(){return Object.keys(l)},i.resolve=r,e.exports=i,i.id=7657},8577:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>m,frontMatter:()=>a,metadata:()=>f,toc:()=>p});var l=t(4848),i=t(8453),r=t(3093),s=t(688);const o="\ntype complexe = {re : float; im : float};;\n\nlet float_to_c r = {re = r; im = 0.};; (* pour tester : convertit flottant en complexe *)\nlet rec lf_to_lc = function  (* pour tester : convertit une liste de flottants en liste de complexes *)\n  | [] -> []\n  | e::q -> float_to_c e::lf_to_lc q;;\n\nlet zero = {re = 0.; im = 0.};;\nlet un = {re = 1.; im = 0.};;\nlet conj z = {re = z.re; im = -.z.im};;\nlet add z1 z2 = {re = z1.re +. z2.re; im = z1.im +. z2.im};;\nlet mul z1 z2 = {re = z1.re *. z2.re -. z1.im *. z2.im; im = z1.im *. z2.re +. z2.im *. z1.re};;\n\nlet rec horner p x = match p with \n  | [] -> zero\n  | a::q -> add a (mul x (horner q x));;\n(** Int\xe9r\xeat de la m\xe9thode : effectuer moins de multiplications (O(n)) que pour la m\xe9thode na\xefve (il faudrait calculer des puissances x**k) **)\n\nhorner (lf_to_lc [1.; 2.; 3.]) un;;\n\nlet rec divise p = match p with \n  | [] -> [], []\n  | [a] -> failwith \"le nombre de coefficients doit \xeatre pair\"\n  | a::b::q -> let p0, p1 = divise q in\n\t       a::p0, b::p1;;\n\nlet rec fft p w = \n  if List.tl p = [] then p (* cas de base: polyn\xf4me constant *)\n  else let p0, p1 = divise p in\n       let wcarre = mul w w in\n       let t0, t1 = fft p0 wcarre, fft p1 wcarre in\n       let rec aux wk l0 l1 = match l0, l1 with (* construit la transform\xe9e de p \xe0 partir de celles de p0 et p1 *)\n\t | [], [] -> []\n\t | y0::q0, y1::q1 -> (add y0 (mul wk y1))::aux (mul w wk) q0 q1 in\n       aux un (t0@t0) (t1@t1);;\n\n(* Soit C(n) la complexit\xe9 de fft p w pour p de taille n. \nAlors fft p w fait deux appels r\xe9cursifs sur des listes p0 et p1 de taille n/2. \nDe plus divise p et l'appel \xe0 aux sont lin\xe9aires, c'est \xe0 dire ont une complexit\xe9 Kn avec K constante.\nDonc C(n) = 2C(n/2) + K*n = 2(2C(n/4) + Kn/2) + Kn = ... = 2**p C(n/2**p) + Kn + Kn + ... + Kn = 2**p C(n/2**p) + p*Kn.\nEn prenant p = log2(n), on trouve C(n) = n C(1) + Knlog(n) = O(nlog(n)) *) \n\nlet rec est_puiss2 n =\n  if n = 1 then true\n  else if n mod 2 = 0 then est_puiss2 (n/2)\n  else false;;\n\nlet puiss2 l =\n  let rec aux n li = match li with (* n est le nombre d'\xe9l\xe9ments d\xe9j\xe0 vus *)\n    | [] -> if est_puiss2 n then [] else zero::aux (n+1) []\n    | e::q -> e::aux (n+1) q in\n  aux 0 l;;\n\npuiss2 [un; un; un; un; un];;\n\nlet completer l = \n  let rec aux n li = match li with\n    | [] -> if n = 0 then [] else zero::aux (n-1) []\n    | e::q -> e::aux n q in\n  aux (List.length l) l;;\n\ncompleter [un; un; un];;\n\nlet rec mul_ft p q = match p, q with\n  | [], [] -> []\n  | p0::p', q0::q' -> (mul p0 q0)::mul_ft p' q';;\n\nlet coeff r =\n  let n = List.length r in\n  let rec aux = function\n    | [] -> []\n    | e::q -> (mul {re = 1./. float n; im = 0.} e)::aux q in\n  aux r;;\n\nlet mul_poly p q =\n  let p', q' = completer p, completer q in\n  let n = List.length p' in\n  let theta = 2.*.3.14159265 /. float n in\n  let w = {re = cos(theta); im = sin(theta)} in (* on peut aussi utiliser exp *)\n  let ftp, ftq = fft p' w, fft q' w in\n  let r = mul_ft ftp ftq in\n  let rhat = fft r (conj w) in\n  coeff rhat;;\n\nmul_poly (lf_to_lc ([1.; 0.; 3.; 1.])) (lf_to_lc ([2.; 1.; 0.; 2.]));;\n(* (1 + 3X**2 + X**3)*(2 + X + 2X**3) = 2 + X + 6X**2 + 7X**3 + X**4 + 6X**5 + 2X**6 *) \n",a={hide_table_of_contents:!0,hide_title:!0,title:"DM 3 : FFT",pdf:"dm_fft"},c=void 0,f={id:"ds/dm_fft/dm_fft",title:"DM 3 : FFT",description:"",source:"@site/docs/ds/4_dm_fft/4_dm_fft.mdx",sourceDirName:"ds/4_dm_fft",slug:"/ds/dm_fft/",permalink:"/mpi-info/docs/ds/dm_fft/",draft:!1,unlisted:!1,editUrl:"https://github.com/mpi-lamartin/mpi-info/docs/ds/4_dm_fft/4_dm_fft.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{hide_table_of_contents:!0,hide_title:!0,title:"DM 3 : FFT",pdf:"dm_fft"},sidebar:"ds",previous:{title:"DS 3 : Mines-Ponts 2024 MP",permalink:"/mpi-info/docs/ds/ds3/"},next:{title:"DS 4 : CentraleSup\xe9lec 2023 MPI",permalink:"/mpi-info/docs/ds/ds4/"}},d={},p=[];function u(e){return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(s.A,{file:o,lang:"ocaml",show:!0}),"\n",(0,l.jsx)(r.A,{pdf:t(7657)(`./${a.pdf}.pdf`).default})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(u,{...e})}):u()}},3093:(e,n,t)=>{"use strict";t.d(n,{A:()=>o});var l=t(6540),i=t(3587),r=t(8865),s=t(4848);const o=e=>{let{pdf:n,cor:t}=e;const[o,a]=(0,l.useState)(!1);return(0,s.jsxs)("div",{children:[t&&(0,s.jsx)("center",{children:(0,s.jsx)(i.A,{sx:{mx:"auto",m:-2},variant:"contained",onClick:()=>{a((e=>!e))},children:o?"\xc9nonc\xe9":"Corrig\xe9"})}),(0,s.jsx)(r.A,{pdf:o?t:n,td:!0})]})}},8865:(e,n,t)=>{"use strict";t.d(n,{A:()=>i});var l=t(4848);const i=e=>{let{pdf:n,td:t=!1}=e;return(0,l.jsx)("div",{className:t?"containerA4":"container4x3",children:(0,l.jsx)("iframe",{src:n+"#zoom=page-fit&pagemode=none",className:"responsive-iframe",allowFullScreen:!0})})}},688:(e,n,t)=>{"use strict";t.d(n,{A:()=>c});t(6540);var l=t(1432),i=t(4164),r=t(3551),s=t(9893);const o="details_JMAC";var a=t(4848);const c=e=>{let{file:n,lang:t,show:c,children:f}=e;return(0,a.jsxs)("div",{children:[" ",c&&(0,a.jsxs)(r.B,{className:(0,i.A)("alert alert--success",o),summary:"Solution",children:[f&&(0,a.jsx)(s.A,{children:f}),(0,a.jsx)(l.A,{language:t,children:n})]})]})}},3775:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>l});const l=t.p+"assets/files/dm_fft-4fe04ed1e3376efeb89cbb5c97a4db4a.pdf"}}]);