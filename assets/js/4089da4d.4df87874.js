"use strict";(self.webpackChunkmpi_info=self.webpackChunkmpi_info||[]).push([[8263],{3410:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>_,default:()=>p,frontMatter:()=>o,metadata:()=>u,toc:()=>f});var r=t(4848),i=t(8453),s=t(688);const l='\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n\n#include <assert.h>\n\n\n// Structure pour une proposition\nstruct prop_ {\n    bool N; // Bool\xe9en indiquant si c\'est une proposition N_i ou O_i\n    int i; // Indice i associ\xe9 \xe0 la proposition\n};\ntypedef struct prop_ prop;\n\n// Structure pour une r\xe8gle reli\xe9e aux r\xe8gles suivantes.\nstruct regle_ {\n    struct regle_* suivant;\n    prop* premisse;\n    int taille_premisse;\n    prop conclusion;\n};\ntypedef struct regle_ regle;\n\n\n//////////////////////////////////////////////////////////////////////\n// D\xe9finition du jeu.\n\n// Lib\xe9ration des r\xe8gles restantes.\nvoid libere_regles(regle *r) {\n    // Attention \xe0 bien lib\xe9rer la premisse.\n    if (r != NULL) {\n        libere_regles(r->suivant);\n        free(r->premisse);\n        free(r);\n    }\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// Generation d\'une permutation\nvoid init_i(int* tableau, int k) {\n    for (int i = 0; i < k; i++) {\n        tableau[i] = i;\n    }\n}\n\nvoid pp_permutation(int* permutation, int k) {\n    for (int i = 0; i < k; i++) {\n        printf("%d ", permutation[i]);\n    }\n    printf("\\n");\n}\n\nvoid melange(int* tableau, int k) {\n    for (int i = 0; i < k; i++) {\n        int j = rand() % k;\n        int tmp = tableau[i];\n        tableau[i] = tableau[j];\n        tableau[j] = tmp;\n    }\n}\n\n//////////////////////////////////////////////////////////////////////\n// R\xe8gles de d\xe9duction\nregle* ajoute_regles_clefs(regle* r, int n1, int* clefs, int nb_clefs) {\n    for (int i = 0; i < nb_clefs; i++) {\n        regle* new = malloc(sizeof(regle));\n        prop* p = malloc(sizeof(prop));\n        p[0].N = true;\n        p[0].i = n1;\n        new->premisse = p;\n        new->taille_premisse = 1;\n        new->conclusion.N = false;\n        new->conclusion.i = clefs[i];\n        new->suivant = r;\n        r = new;\n    }\n    return r;\n}\n\n// ajoute une r\xe8gle provenant d\'une ar\xeate, seulement dans une direction\nregle* ajoute_regle_arete(regle* r, int n1, int n2, int* verr, int nb_verr) {\n    prop* p = malloc((nb_verr + 1) * sizeof(prop));\n    p[0].N = true;\n    p[0].i = n1;\n    for(int i = 0; i < nb_verr; i++) {\n        p[i + 1].N = false;\n        p[i + 1].i = verr[i];\n    }\n    regle *new = malloc(sizeof(regle));\n    new->premisse = p;\n    new->taille_premisse = nb_verr + 1;\n    new->conclusion.N = true;\n    new->conclusion.i = n2;\n    new->suivant = r;\n    return new;\n}\n\n// dans les deux directions\nregle* ajoute_regles_arete(regle* r, int n1, int n2, int* verr, int nb_verr) {\n    r = ajoute_regle_arete(r, n1, n2, verr, nb_verr);\n    r = ajoute_regle_arete(r, n2, n1, verr, nb_verr);\n    return r;\n}\n\nvoid print_jeu(regle* r) {\n    while (r != NULL) {\n        for (int i = 0; i < r->taille_premisse; i++) {\n            if (r->premisse[i].N) {\n                printf("N_%d ", r->premisse[i].i);\n            } else {\n                printf("O_%d ", r->premisse[i].i);\n            }\n        }\n        if (r->conclusion.N) {\n            printf("=> N_%d\\n", r->conclusion.i);\n        } else {\n            printf("=> O_%d\\n", r->conclusion.i);\n        }\n        r = r->suivant;\n    }\n}\n\nvoid init_faux(bool* tableau, int taille_tableau) {\n    for (int i = 0; i < taille_tableau; i++) {\n        tableau[i] = false;\n    }\n}\n\nbool verifie_premisse(regle r, bool* noeuds, bool* clefs) {\n    for (int i = 0; i < r.taille_premisse; i++) {\n        if (r.premisse[i].N) {\n            if (!noeuds[r.premisse[i].i]) {\n                return false;\n            }\n        } else {\n            if (!clefs[r.premisse[i].i]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nregle* parcours_regles(regle* r, bool* noeuds, bool* clefs, bool* progres) {\n    regle* debut = r;\n    while (r != NULL) {\n        printf("V\xe9rification de la r\xe8gle : ");\n        for (int i = 0; i < r->taille_premisse; i++) {\n            if (r->premisse[i].N) {\n                printf("N_%d ", r->premisse[i].i);\n            } else {\n                printf("O_%d ", r->premisse[i].i);\n            }\n        }\n        if (r->conclusion.N) {\n            printf("=> N_%d\\n", r->conclusion.i);\n        } else {\n            printf("=> O_%d\\n", r->conclusion.i);\n        }\n        if (verifie_premisse(*r, noeuds, clefs)) {\n            if (r->conclusion.N && !noeuds[r->conclusion.i]) {\n                noeuds[r->conclusion.i] = true;\n                printf("Noeud %d d\xe9bloqu\xe9\\n", r->conclusion.i);\n                *progres = true;\n            }\n            if (!r->conclusion.N && !clefs[r->conclusion.i]) {\n                clefs[r->conclusion.i] = true;\n                printf("Clef %d d\xe9bloqu\xe9e\\n", r->conclusion.i);\n                *progres = true;\n            }\n        }\n        r = r->suivant;\n    }\n    return debut;\n}\n\nbool est_sat(regle* r, int nb_noeuds, int nb_clefs, int D, int F) {\n    bool* noeuds = malloc(nb_noeuds * sizeof(bool));\n    bool* clefs = malloc(nb_clefs * sizeof(bool));\n    init_faux(noeuds, nb_noeuds);\n    init_faux(clefs, nb_clefs);\n    noeuds[D] = true;\n    bool progres = true;\n    while (progres) {\n        progres = false;\n        r = parcours_regles(r, noeuds, clefs, &progres);\n    }\n    bool res = noeuds[F];\n    free(noeuds);\n    free(clefs);\n    return res;\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// Tests\n\nregle* genere_jeu_1() {\n\n    regle* r = NULL;\n    // D\xe9finition des r\xe8gles repr\xe9sentant le jeu 1 donn\xe9 en exemple.\n\n    r = ajoute_regles_clefs(r, 2, (int []){1}, 1);\n    r = ajoute_regles_clefs(r, 3, (int []){0}, 1);\n    r = ajoute_regles_clefs(r, 4, (int []){0, 2}, 2);\n\n    r = ajoute_regles_arete(r, 0, 1, (int []){0}, 1);\n    r = ajoute_regles_arete(r, 1, 2, (int []){1}, 1);\n    r = ajoute_regles_arete(r, 1, 2, (int []){}, 0);\n    r = ajoute_regles_arete(r, 0, 3, (int []){}, 0);\n    r = ajoute_regles_arete(r, 1, 4, (int []){1}, 1);\n    r = ajoute_regles_arete(r, 2, 5, (int []){1, 2}, 2);\n    r = ajoute_regles_arete(r, 3, 4, (int []){1}, 1);\n    r = ajoute_regles_arete(r, 4, 5, (int []){0, 1}, 2);\n\n\n    // Noeud initial d\'indice 0, et noeud final d\'indice 5\n    // Ce jeu comprend 6 noeuds et 3 clefs diff\xe9rentes\n\n    return r;\n}\n\nregle* genere_jeu_2() {\n\n    regle* r = NULL;\n    // D\xe9finition des r\xe8gles repr\xe9sentant le jeu 2 donn\xe9 en annexe.\n\n    r = ajoute_regles_clefs(r, 1, (int []){2}, 1);\n    r = ajoute_regles_clefs(r, 2, (int []){5}, 1);\n    r = ajoute_regles_clefs(r, 3, (int []){0, 1}, 2);\n    r = ajoute_regles_clefs(r, 5, (int []){8}, 1);\n    r = ajoute_regles_clefs(r, 6, (int []){14}, 1);\n    r = ajoute_regles_clefs(r, 7, (int []){12}, 1);\n    r = ajoute_regles_clefs(r, 8, (int []){6}, 1);\n    r = ajoute_regles_clefs(r, 9, (int []){3, 4}, 2);\n    r = ajoute_regles_clefs(r, 10, (int []){13}, 1);\n    r = ajoute_regles_clefs(r, 11, (int []){10}, 1);\n    r = ajoute_regles_clefs(r, 12, (int []){11, 9}, 2);\n    r = ajoute_regles_clefs(r, 14, (int []){15}, 1);\n    r = ajoute_regles_clefs(r, 15, (int []){7}, 1);\n    r = ajoute_regles_clefs(r, 16, (int []){5}, 1);\n    r = ajoute_regles_clefs(r, 17, (int []){16}, 1);\n\n    r = ajoute_regles_arete(r, 0, 3, (int []){11, 12, 13}, 3);\n    r = ajoute_regles_arete(r, 1, 4, (int []){6, 7}, 2);\n    r = ajoute_regles_arete(r, 2, 3, (int []){1}, 1);\n    r = ajoute_regles_arete(r, 3, 4, (int []){3}, 1);\n    r = ajoute_regles_arete(r, 3, 4, (int []){0}, 1);\n    r = ajoute_regles_arete(r, 4, 5, (int []){0, 2}, 2);\n    r = ajoute_regles_arete(r, 2, 6, (int []){5, 6}, 2);\n    r = ajoute_regles_arete(r, 2, 7, (int []){}, 0);\n    r = ajoute_regles_arete(r, 3, 7, (int []){4}, 1);\n    r = ajoute_regles_arete(r, 3, 8, (int []){}, 0);\n    r = ajoute_regles_arete(r, 4, 11, (int []){}, 0);\n    r = ajoute_regles_arete(r, 5, 12, (int []){3}, 1);\n    r = ajoute_regles_arete(r, 6, 7, (int []){4, 5}, 2);\n    r = ajoute_regles_arete(r, 7, 8, (int []){4}, 1);\n    r = ajoute_regles_arete(r, 8, 9, (int []){6}, 1);\n    r = ajoute_regles_arete(r, 9, 10, (int []){7}, 1);\n    r = ajoute_regles_arete(r, 10, 11, (int []){4, 7}, 2);\n    r = ajoute_regles_arete(r, 7, 12, (int []){0}, 1);\n    r = ajoute_regles_arete(r, 8, 12, (int []){0, 6}, 2);\n    r = ajoute_regles_arete(r, 10, 13, (int []){}, 0);\n    r = ajoute_regles_arete(r, 12, 13, (int []){0, 9}, 2);\n    r = ajoute_regles_arete(r, 13, 14, (int []){7, 8}, 2);\n    r = ajoute_regles_arete(r, 13, 15, (int []){2}, 1);\n    r = ajoute_regles_arete(r, 13, 16, (int []){10}, 1);\n    r = ajoute_regles_arete(r, 16, 17, (int []){15, 16}, 2);\n\n    // Noeud initial d\'indice 3, et noeud final d\'indice 0\n    // Ce jeu comprend 18 noeuds et 17 clefs diff\xe9rentes\n\n    return r;\n}\n\n\nint main() {\n    srand(1); // seed \xe0 changer pour modifier l\'al\xe9atoire g\xe9n\xe9r\xe9.\n\n    printf("Jeu 1\\n");\n    regle* r = genere_jeu_1();\n    print_jeu(r);\n    printf("Est satisfiable ? %d\\n", est_sat(r, 6, 3, 0, 5));\n    libere_regles(r);\n    //int p0[] = {8, 10, 14, 12, 5, 13, 4, 16, 11, 15, 9, 3, 7, 0, 1, 2, 6};\n    //int p1[] = {0, 16, 5, 14, 1, 15, 3, 12, 8, 7, 11, 9, 13, 6, 4, 10, 2};\n    //int p2[] = {0, 5, 10, 4, 15, 2, 9, 11, 16, 12, 6, 8, 13, 3, 1, 14, 7};\n    //int p3[] = {3, 8, 7, 16, 2, 0, 4, 1, 5, 12, 9, 6, 10, 13, 11, 14, 15};\n    //int p4[] = {2, 10, 14, 13, 0, 6, 15, 11, 16, 12, 9, 4, 1, 5, 7, 8, 3};\n\n    return 0;\n}\n',a="type temps = int\ntype noeud = {id : int ; clefs : ((int * temps) list) ; est_final : bool}\n\ntype verrou = int list\ntype mgraphe = (temps * verrou * noeud) list array\n\ntype inventaire = int option array\n\ntype etat = {noeud : noeud; temps : temps; inventaire : inventaire}\n\n\n(* Construction du multi-graphe *)\nlet ajoute_transition g n1 n2 t clefs : unit =\n  g.(n1.id) <- (t, clefs, n2):: g.(n1.id);\n  g.(n2.id) <- (t, clefs, n1):: g.(n2.id)\n\n\n(* Exemple du jeu num\xe9ro 1 *)\nlet n1_0 = {id = 0; clefs = []; est_final = false}\nlet n1_1 = {id = 1; clefs = []; est_final = false}\nlet n1_2 = {id = 2; clefs = [(1, 1)]; est_final = false}\nlet n1_3 = {id = 3; clefs = [(0, 5); (1, 70)]; est_final = false}\nlet n1_4 = {id = 4; clefs = [(2, 5); (0, 1)]; est_final = false}\nlet n1_5 = {id = 5; clefs = []; est_final = true}\n\nlet g1 = Array.make 6 []\nlet () = ajoute_transition g1 n1_0 n1_1 10 [0]\nlet () = ajoute_transition g1 n1_1 n1_2 2 [1]\nlet () = ajoute_transition g1 n1_1 n1_2 10 []\nlet () = ajoute_transition g1 n1_0 n1_3 10 []\nlet () = ajoute_transition g1 n1_1 n1_4 80 [1]\nlet () = ajoute_transition g1 n1_2 n1_5 5 [1; 2]\nlet () = ajoute_transition g1 n1_3 n1_4 10 [1]\nlet () = ajoute_transition g1 n1_4 n1_5 10 [0; 1]\n\n\n(* Exemple du jeu num\xe9ro 2 *)\n\nlet n2_0 = {id = 0; clefs = []; est_final = true}\nlet n2_1 = {id = 1; clefs = [(2, 10)]; est_final = false}\nlet n2_2 = {id = 2; clefs = [(5, 10)]; est_final = false}\n\n(* Noeud initial : n2_3*)\nlet n2_3 = {id = 3; clefs = [(0, 10); (1, 1)]; est_final = false}\nlet n2_4 = {id = 4; clefs = []; est_final = false}\nlet n2_5 = {id = 5; clefs = [(8, 5)]; est_final = false}\nlet n2_6 = {id = 6; clefs = [(14, 10)]; est_final = false}\nlet n2_7 = {id = 7; clefs = [(12, 10)]; est_final = false}\nlet n2_8 = {id = 8; clefs = [(6, 5)]; est_final = false}\nlet n2_9 = {id = 9; clefs = [(3, 5); (4, 10)]; est_final = false}\nlet n2_10 = {id = 10; clefs = [(13, 10)]; est_final = false}\nlet n2_11 = {id = 11; clefs = [(10, 10)]; est_final = false}\nlet n2_12 = {id = 12; clefs = [(11, 10); (9, 5)]; est_final = false}\nlet n2_13 = {id = 13; clefs = []; est_final = false}\nlet n2_14 = {id = 14; clefs = [(15, 10)]; est_final = false}\nlet n2_15 = {id = 15; clefs = [(7, 10)]; est_final = false}\nlet n2_16 = {id = 16; clefs = [(5, 5)]; est_final = false}\nlet n2_17 = {id = 17; clefs = [(16, 10)]; est_final = false}\n\nlet g2 = Array.make 18 []\nlet () = ajoute_transition g2 n2_0 n2_3 2 [11; 12; 13]\nlet () = ajoute_transition g2 n2_1 n2_4 14 [6; 7]\nlet () = ajoute_transition g2 n2_2 n2_3 9 [1]\nlet () = ajoute_transition g2 n2_3 n2_4 12 [3]\nlet () = ajoute_transition g2 n2_3 n2_4 5 [0]\nlet () = ajoute_transition g2 n2_4 n2_5 8 [0; 2]\nlet () = ajoute_transition g2 n2_2 n2_6 12 [5; 6]\nlet () = ajoute_transition g2 n2_2 n2_7 12 []\nlet () = ajoute_transition g2 n2_3 n2_7 7 [4]\nlet () = ajoute_transition g2 n2_3 n2_8 10 []\nlet () = ajoute_transition g2 n2_4 n2_11 10 []\nlet () = ajoute_transition g2 n2_5 n2_12 15 [3]\nlet () = ajoute_transition g2 n2_6 n2_7 17 [4; 5]\nlet () = ajoute_transition g2 n2_7 n2_8 12 [4]\nlet () = ajoute_transition g2 n2_8 n2_9 12 [6]\nlet () = ajoute_transition g2 n2_9 n2_10 22 [7]\nlet () = ajoute_transition g2 n2_10 n2_11 27 [4; 7]\nlet () = ajoute_transition g2 n2_7 n2_12 17 [0]\nlet () = ajoute_transition g2 n2_8 n2_12 22 [0; 6]\nlet () = ajoute_transition g2 n2_10 n2_13 12 []\nlet () = ajoute_transition g2 n2_12 n2_13 15 [0; 9]\nlet () = ajoute_transition g2 n2_13 n2_14 31 [7; 8]\nlet () = ajoute_transition g2 n2_13 n2_15 17 [2]\nlet () = ajoute_transition g2 n2_13 n2_16 17 [10]\nlet () = ajoute_transition g2 n2_16 n2_17 17 [15; 16]\n\n(* Q20 *)\n(* Algorithme de Dijkstra o\xf9 la longueur d'un chemin est le temps total *)\n(* On peut l'utiliser car les poids sont positifs *)\n(* Sa complexit\xe9 est O(plog(n)) si impl\xe9ment\xe9 avec un tas *)\n\nlet mise_a_jour_inventaire clefs inventaire : unit =\n  let rec aux = function\n    | [] -> ()\n    | (i, t):: q -> match inventaire.(i) with\n      | None -> inventaire.(i) <- Some t; aux q\n      | Some t' -> if t < t' then (inventaire.(i) <- Some t; aux q)\n  in aux clefs\n\nlet verrou_franchissable verrou inventaire : bool =\n  List.for_all (fun i -> inventaire.(i) <> None) verrou\n\nlet prendre_arete verrou inventaire : temps =\n  let rec aux = function\n    | [] -> 0\n    | i::q -> match inventaire.(i) with\n      | None -> failwith \"Erreur\"\n      | Some t -> inventaire.(i) <- Some 0; t + aux q in\n  aux verrou\n\nlet voisins etat g =\n  let (noeud, temps, inventaire) = (etat.noeud, etat.temps, etat.inventaire) in\n  let transitions = g.(noeud.id) in\n  let rec aux = function\n    | [] -> []\n    | (t, verrou, n):: q when verrou_franchissable verrou inventaire ->\n        let inventaire' = Array.copy inventaire in\n        let temps' = temps + t + prendre_arete verrou inventaire' in\n        mise_a_jour_inventaire n.clefs inventaire';\n        {noeud = n; temps = temps'; inventaire = inventaire'}::aux q\n    | _:: q -> aux q in\n  aux transitions\n\n(* tests *)\nlet v = voisins {noeud = n1_0; temps = 0; inventaire = Array.make 3 None} g1\nvoisins (List.hd v) g1\n\n(* Q25 *)\n(* On peut impl\xe9menter une file de priorit\xe9 avec un tas ou avec un ABR (si possible \xe9quilibr\xe9 pour des op\xe9rations en O(log(n))) *)\n(* L'impl\xe9mentation avec un tas est plus efficace (voir cours) mais un ABR est plus rapide \xe0 coder *)\ntype arb = V | N of arb * etat * arb\n\nlet rec add x = function\n  | V -> N(V, x, V)\n  | N(g, y, d) when x.temps < y.temps -> N(add x g, y, d)\n  | N(g, y, d) -> N(g, y, add x d)\n\nlet rec take_min = function\n  | N(V, x, d) -> (x, d)\n  | N(g, x, d) -> let (min, g') = take_min g in (min, N(g', x, d))\n\nlet dijkstra g n =\n  let rec aux file =\n    match take_min file with\n    | (etat, file') when etat.noeud.est_final -> etat\n    | (etat, file') -> aux (List.fold_left (fun f e -> add e f) file' (voisins etat g))\n  in aux (add n V)\n\ndijkstra g1 {noeud = n1_0; temps = 0; inventaire = Array.make 3 None}\n\n(* Q30 *)\n(* Pour se souvenir des sommets (avec inventaire) d\xe9j\xe0 rencontr\xe9s, il faut impl\xe9menter une structure d'ensemble, par exemple table de hachage. Ce qui demande de d\xe9finir une fonction de hachage... *)\n",o={hide_table_of_contents:!0,hide_title:!1,cor:!0,title:"TP 10 : Jeu randomis\xe9 et route optimale (Centrale 2023)"},_=void 0,u={id:"tp/tp_cs/tp_cs",title:"TP 10 : Jeu randomis\xe9 et route optimale (Centrale 2023)",description:"Rapport.",source:"@site/docs/tp/10_tp_cs/10_tp_cs.mdx",sourceDirName:"tp/10_tp_cs",slug:"/tp/tp_cs/",permalink:"/mpi-info/docs/tp/tp_cs/",draft:!1,unlisted:!1,editUrl:"https://github.com/mpi-lamartin/mpi-info/docs/tp/10_tp_cs/10_tp_cs.mdx",tags:[],version:"current",sidebarPosition:10,frontMatter:{hide_table_of_contents:!0,hide_title:!1,cor:!0,title:"TP 10 : Jeu randomis\xe9 et route optimale (Centrale 2023)"},sidebar:"tp",previous:{title:"TP 9 : Apprentissage automatique",permalink:"/mpi-info/docs/tp/tp_mnist/"},next:{title:"TP 11 : Pr\xe9diction de mots",permalink:"/mpi-info/docs/tp/tp_ngrammes/"}},c={},f=[];function d(n){const e={a:"a",li:"li",p:"p",ul:"ul",...(0,i.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(7857).A+"",children:"Rapport"}),"."]}),"\n",(0,r.jsx)(s.A,{file:l,lang:"c",show:o.cor,title:"Partie 1 et 2 (C)"}),"\n",(0,r.jsx)(s.A,{file:a,lang:"ocaml",show:o.cor,title:"Partie 3 (OCaml)"}),"\n",(0,r.jsxs)(e.p,{children:[(0,r.jsx)(e.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(5027).A+"",children:"\xc9nonc\xe9"}),"."]}),"\n",(0,r.jsx)(e.p,{children:"Fichiers \xe0 compl\xe9ter :"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(7260).A+"",children:"randomizer.c"})}),"\n",(0,r.jsx)(e.li,{children:(0,r.jsx)(e.a,{target:"_blank","data-noBrokenLinkCheck":!0,href:t(837).A+"",children:"route_optimale.ml"})}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},688:(n,e,t)=>{t.d(e,{A:()=>_});t(6540);var r=t(1432),i=t(4164),s=t(3551),l=t(9893);const a="details_JMAC";var o=t(4848);const _=n=>{let{file:e,lang:t,show:_,title:u="Solution",children:c}=n;return(0,o.jsxs)("div",{children:[" ",_&&(0,o.jsxs)(s.B,{className:(0,i.A)("alert alert--success",a),summary:u,children:[c&&(0,o.jsx)(l.A,{children:c}),(0,o.jsx)(r.A,{language:t,children:e})]})]})}},7260:(n,e,t)=>{t.d(e,{A:()=>r});const r=t.p+"assets/files/randomizer-12cd75d11e09e5331d713b060cf20995.c"},837:(n,e,t)=>{t.d(e,{A:()=>r});const r=t.p+"assets/files/route_optimale-6130111e0ce0803991787667c461e587.ml"},5027:(n,e,t)=>{t.d(e,{A:()=>r});const r=t.p+"assets/files/tp_cs_rdm-5ba41e5221e2abc826f094e1454d2761.pdf"},7857:(n,e,t)=>{t.d(e,{A:()=>r});const r=t.p+"assets/files/tp_cs_rdm_com-2cf058f5099844166b8334f949024de7.pdf"}}]);