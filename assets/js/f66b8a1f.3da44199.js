"use strict";(self.webpackChunkmpi_info=self.webpackChunkmpi_info||[]).push([[2379],{95156:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>d,contentTitle:()=>u,default:()=>f,frontMatter:()=>a,metadata:()=>i,toc:()=>m});var i=t(29578),o=t(74848),r=t(28453),s=t(30688),l=t(78256);const a={title:"LeetCode 2 : Min Cost to Connect All Points",authors:"qfortier",tags:["leetcode","devoir","programmation"]},u=void 0,d={authorsImageUrls:[void 0]},m=[];function p(n){const e={a:"a",code:"code",p:"p",pre:"pre",...(0,r.R)(),...n.components},{Details:t}=e;return t||function(n,e){throw new Error("Expected "+(e?"component":"object")+" `"+n+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(e.p,{children:["Exercice \xe0 faire en C sur LeetCode, avant lundi prochain : ",(0,o.jsx)(e.a,{href:"https://leetcode.com/problems/min-cost-to-connect-all-points",children:"https://leetcode.com/problems/min-cost-to-connect-all-points"})]}),"\n",(0,o.jsxs)(t,{children:[(0,o.jsx)("summary",{children:"Indice"}),(0,o.jsx)(e.p,{children:"Utiliser l'algorithme de Kruskal sur le graphe dont les sommets sont les points et les ar\xeates sont les distances entre les points. Vous pouvez impl\xe9menter un tri fusion :"}),(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-c",children:"typedef struct {\n    int n; // nombre de sommets\n    int *degres; // degres[i] = nombre de voisins du sommet i\n    arete **aretes; // aretes[i] = tableau des aretes incidentes au sommet i\n} graphe;\n\narete a(int u, int v, int poids) {\n    arete e;\n    e.u = u;\n    e.v = v;\n    e.poids = poids;\n    return e;\n}\n\nvoid fusion(arete* t, int n, arete* t1, int n1, arete* t2, int n2) {\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < n1 && j < n2) {\n        if (t1[i].poids < t2[j].poids) {\n            t[k] = t1[i];\n            i++;\n        } else {\n            t[k] = t2[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        t[k] = t1[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        t[k] = t2[j];\n        j++;\n        k++;\n    }\n}\n\n// tri t de taille n entre les indices debut (inclus) et fin (exclus)\nvoid tri_fusion(arete* t, int n, int debut, int fin) {\n    if (fin - debut <= 1) {\n        return;\n    }\n    int milieu = (debut + fin) / 2;\n    tri_fusion(t, n, debut, milieu);\n    tri_fusion(t, n, milieu, fin);\n    arete* temp = malloc((fin - debut) * sizeof(arete));\n    fusion(temp, fin - debut, &t[debut], milieu - debut, &t[milieu], fin - milieu);\n    for (int i = debut; i < fin; i++) {\n        t[i] = temp[i - debut];\n    }\n    free(temp);\n}\n"})})]}),"\n","\n",(0,o.jsx)(s.A,{file:l.A,lang:"c",show:!0})]})}function f(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(p,{...n})}):p(n)}},30688:(n,e,t)=>{t.d(e,{A:()=>u});t(96540);var i=t(83457),o=t(34164),r=t(83551),s=t(6622);const l="details_JMAC";var a=t(74848);const u=({file:n,lang:e,show:t,title:u="Solution",children:d})=>(0,a.jsxs)("div",{children:[" ",t&&(0,a.jsxs)(r.B,{className:(0,o.A)("alert alert--success",l),summary:u,children:[d&&(0,a.jsx)(s.A,{children:d}),(0,a.jsx)(i.A,{language:e,children:n})]})]})},78256:(n,e,t)=>{t.d(e,{A:()=>i});const i="typedef struct {\n    int u;\n    int v;\n    int poids;\n} arete;\n\ntypedef struct {\n    int n; // nombre de sommets\n    int *degres; // degres[i] = nombre de voisins du sommet i\n    arete **aretes; // aretes[i] = tableau des aretes incidentes au sommet i\n} graphe;\n\narete a(int u, int v, int poids) {\n    arete e;\n    e.u = u;\n    e.v = v;\n    e.poids = poids;\n    return e;\n}\n\ntypedef struct {\n  int n; // nombre d'\xe9lements\n  int* t; // t[i] = p\xe8re de i\n} uf;\n\nuf* create(int n) {\n    uf* u = malloc(sizeof(uf));\n    u->n = n;\n    u->t = malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        u->t[i] = -1;\n    }\n    return u;\n}\n\nint find(uf* u, int x) {\n    if (u->t[x] < 0) {\n        return x;\n    } else {\n        int r = find(u, u->t[x]);\n        u->t[x] = r;\n        return r;\n    }\n}\n\nvoid merge(uf* u, int x, int y) {\n    int rx = find(u, x);\n    int ry = find(u, y);\n    if (rx < ry) u->t[ry] = rx;\n    else if (rx > ry) u->t[rx] = ry;\n    else {\n        u->t[ry] = rx;\n        u->t[rx]--;\n    }\n}\n\nvoid fusion(arete* t, int n, arete* t1, int n1, arete* t2, int n2) {\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    while (i < n1 && j < n2) {\n        if (t1[i].poids < t2[j].poids) {\n            t[k] = t1[i];\n            i++;\n        } else {\n            t[k] = t2[j];\n            j++;\n        }\n        k++;\n    }\n    while (i < n1) {\n        t[k] = t1[i];\n        i++;\n        k++;\n    }\n    while (j < n2) {\n        t[k] = t2[j];\n        j++;\n        k++;\n    }\n}\n\nvoid tri_fusion(arete* t, int n, int debut, int fin) {\n    if (fin - debut <= 1) {\n        return;\n    }\n    int milieu = (debut + fin) / 2;\n    tri_fusion(t, n, debut, milieu);\n    tri_fusion(t, n, milieu, fin);\n    arete* temp = malloc((fin - debut) * sizeof(arete));\n    fusion(temp, fin - debut, &t[debut], milieu - debut, &t[milieu], fin - milieu);\n    for (int i = debut; i < fin; i++) {\n        t[i] = temp[i - debut];\n    }\n    free(temp);\n}\n\nint minCostConnectPoints(int** points, int pointsSize, int* pointsColSize) {\n    arete* t = malloc(pointsSize * (pointsSize - 1) / 2 * sizeof(arete));\n    int k = 0;\n    for (int i = 0; i < pointsSize; i++) {\n        for (int j = i + 1; j < pointsSize; j++) {\n            t[k] = a(i, j, abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]));\n            k++;\n        }\n    }\n    tri_fusion(t, pointsSize * (pointsSize - 1) / 2, 0, pointsSize * (pointsSize - 1) / 2);\n    uf* u = create(pointsSize);\n    int res = 0;\n    for (int i = 0; i < pointsSize * (pointsSize - 1) / 2; i++) {\n        if (find(u, t[i].u) != find(u, t[i].v)) {\n            res += t[i].poids;\n            merge(u, t[i].u, t[i].v);\n        }\n    }\n    free(u->t);\n    free(u);\n    free(t);\n    return res;\n}\n"},29578:n=>{n.exports=JSON.parse('{"permalink":"/mpi-info/2025/11/3/leetcode2","editUrl":"https://github.com/mpi-lamartin/mpi-info/blog/2025-11-3-leetcode2.mdx","source":"@site/blog/2025-11-3-leetcode2.mdx","title":"LeetCode 2 : Min Cost to Connect All Points","description":"Exercice \xe0 faire en C sur LeetCode, avant lundi prochain//leetcode.com/problems/min-cost-to-connect-all-points","date":"2025-11-03T00:00:00.000Z","tags":[{"inline":false,"label":"LeetCode","permalink":"/mpi-info/tags/leetcode"},{"inline":false,"label":"Devoir","permalink":"/mpi-info/tags/devoir"},{"inline":false,"label":"Programmation","permalink":"/mpi-info/tags/programmation"}],"hasTruncateMarker":false,"authors":[{"name":"Quentin Fortier","title":"Professeur d\'informatique","url":"https://fortierq.github.io/","imageURL":"https://fortierq.github.io/assets/images/photo_cv.png","key":"qfortier","page":null}],"frontMatter":{"title":"LeetCode 2 : Min Cost to Connect All Points","authors":"qfortier","tags":["leetcode","devoir","programmation"]},"unlisted":false,"prevItem":{"title":"Cours 3/11","permalink":"/mpi-info/2025/11/3/cahier"},"nextItem":{"title":"LeetCode 1 : Number of Islands","permalink":"/mpi-info/2025/10/18/leetcode1"}}')}}]);