"use strict";(self.webpackChunkmpi_info=self.webpackChunkmpi_info||[]).push([[646],{54854:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>h,contentTitle:()=>u,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>m});const s=JSON.parse('{"id":"tp/tp5/tp5","title":"TP 5 : Algorithme de Kruskal","description":"Codespace","source":"@site/docs/tp/5_tp5/5_tp5.mdx","sourceDirName":"tp/5_tp5","slug":"/tp/tp5/","permalink":"/mpi-info/docs/tp/tp5/","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"hide_table_of_contents":false,"hide_title":false,"cor":true,"title":"TP 5 : Algorithme de Kruskal"},"sidebar":"tp","previous":{"title":"TP 4 : Algorithme CYK (Cocke-Younger-Kasami)","permalink":"/mpi-info/docs/tp/tp4/"},"next":{"title":"TP 6 : Couplage maximum dans un graphe biparti","permalink":"/mpi-info/docs/tp/tp6/"}}');var t=i(74848),r=i(28453),a=i(86025),l=i(21122),d=i(30688);const c="#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int u;\n    int v;\n    int poids;\n} arete;\n\ntypedef struct {\n    int n; // nombre de sommets\n    int *degres; // degres[i] = nombre de voisins du sommet i\n    arete **aretes; // aretes[i] = tableau des aretes incidentes au sommet i\n} graphe;\n\n// 1 \narete a(int u, int v, int poids) {\n    arete e;\n    e.u = u;\n    e.v = v;\n    e.poids = poids;\n    return e;\n}\n\n// 3\nint n_aretes(graphe g) {\n    int n = 0;\n    for (int i = 0; i < g.n; i++) {\n        n += g.degres[i];\n    }\n    return n / 2;\n}\n\n// 4\narete* aretes(graphe g) {\n    arete* t = malloc(n_aretes(g) * sizeof(arete));\n    int k = 0;\n    for (int i = 0; i < g.n; i++) {\n        for (int j = 0; j < g.degres[i]; j++) {\n            if (i < g.aretes[i][j].v) {\n                t[k] = g.aretes[i][j];\n                k++;\n            }\n        }\n    }\n    return t;\n}\n\n\n// 5\nvoid tri_insertion(arete* t, int n) {\n    for (int i = 1; i < n; i++) {\n        arete e = t[i];\n        int j = i - 1;\n        while (j >= 0 && t[j].poids > e.poids) {\n            t[j + 1] = t[j];\n            j = j - 1;\n        }\n        t[j + 1] = e;\n    }\n}\n\n\n// 6\ntypedef struct {\n  int n; // nombre d'\xe9lements\n  int* t; // t[i] = p\xe8re de i\n} uf;\nuf* create(int n) {\n    uf* u = malloc(sizeof(uf));\n    u->n = n;\n    u->t = malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        u->t[i] = i;\n    }\n    return u;\n}\n\n// 7\nint find(uf* u, int x) {\n    if (u->t[x] == x) {\n        return x;\n    } else {\n        return find(u, u->t[x]);\n    }\n}\n\n// 8\nvoid merge(uf* u, int x, int y) {\n    u->t[find(u, x)] = find(u, y);\n}\n\n// 9\nint n_cc(uf* u) {\n    int n = 0;\n    for (int i = 0; i < u->n; i++) {\n        if (u->t[i] == i) {\n            n++;\n        }\n    }\n    return n;\n}\n\n// 10\narete* kruskal(graphe g) {\n    arete* t = aretes(g);\n    tri_insertion(t, n_aretes(g));\n    uf* u = create(g.n);\n    arete* mst = malloc((g.n - 1) * sizeof(arete));\n    int k = 0;\n    for (int i = 0; i < n_aretes(g); i++) {\n        if (find(u, t[i].u) != find(u, t[i].v)) {\n            mst[k] = t[i];\n            k++;\n            merge(u, t[i].u, t[i].v);\n        }\n    }\n    free(u->t);\n    free(u);\n    free(t);\n    return mst;\n}\n\n// 11. R\xe9\xe9crire la fonction `find` pour qu'elle utilise la compression de chemin.  \nint find(uf* u, int x) {\n    if (u->t[x] == x) {\n        return x;\n    } else {\n        u->t[x] = find(u, u->t[x]);\n        return u->t[x];\n    }\n}\n\n// 12. Red\xe9finir le type `uf` et r\xe9\xe9crire `merge` pour qu'il utilise l'union par rang.\ntypedef struct {\n  int n; // nombre d'\xe9lements\n  int* t; // t[i] = p\xe8re de i\n  int* h; // h[i] = hauteur de l'arbre enracin\xe9 en i\n} uf;\n\nvoid merge(uf* u, int x, int y) {\n    int rx = find(u, x);\n    int ry = find(u, y);\n    if (u->h[rx] < u->h[ry]) {\n        u->t[rx] = ry;\n    } else if (u->h[rx] > u->h[ry]) {\n        u->t[ry] = rx;\n    } else {\n        u->t[rx] = ry;\n        u->h[ry]++;\n    }\n}\n\nint main() {\n    // 2\n    graphe g;\n    g.n = 7;\n    g.degres = malloc(7 * sizeof(int));\n    g.degres[0] = 3;\n    g.degres[1] = 3;\n    g.degres[2] = 4;\n    g.degres[3] = 3;\n    g.degres[4] = 2;\n    g.degres[5] = 3;\n    g.degres[6] = 2;\n    g.aretes = malloc(7 * sizeof(arete*));\n    for(int i = 0; i < 7; i++)\n        g.aretes[i] = malloc(g.degres[i] * sizeof(arete));\n    g.aretes[0][0] = g.aretes[1][0] = a(0, 1, 1);\n    g.aretes[0][1] = g.aretes[2][0] = a(0, 2, 5);\n    g.aretes[0][2] = g.aretes[6][0] = a(0, 6, 5);\n    g.aretes[1][1] = g.aretes[3][0] = a(1, 3, 2);\n    g.aretes[1][2] = g.aretes[6][1] = a(1, 6, 3);\n    g.aretes[2][1] = g.aretes[3][1] = a(2, 3, 3);\n    g.aretes[2][2] = g.aretes[4][0] = a(2, 4, 2);\n    g.aretes[2][3] = g.aretes[5][0] = a(2, 5, 5);\n    g.aretes[3][2] = g.aretes[5][1] = a(3, 5, 1);\n    g.aretes[4][1] = g.aretes[5][2] = a(4, 5, 5);\n\n    printf(\"Nombre d'aretes : %d\\n\", n_aretes(g));\n    arete* t = aretes(g);\n    for (int i = 0; i < n_aretes(g); i++) {\n        printf(\"Arete %d : %d %d %d\\n\", i, t[i].u, t[i].v, t[i].poids);\n    }\n    arete* mst = kruskal(g);\n    for (int i = 0; i < 6; i++) {\n        printf(\"Arete %d : %d %d %d\\n\", i, mst[i].u, mst[i].v, mst[i].poids);\n    }\n    // free_graphe(g);\n    free(t);\n    free(mst);\n}\n",o={hide_table_of_contents:!1,hide_title:!1,cor:!0,title:"TP 5 : Algorithme de Kruskal"},u=void 0,h={},m=[{value:"Tri des ar\xeates",id:"tri-des-ar\xeates",level:2},{value:"Union-Find",id:"union-find",level:2},{value:"Algorithme de Kruskal",id:"algorithme-de-kruskal",level:2},{value:"Optimisations",id:"optimisations",level:2},{value:"LeetCode",id:"leetcode",level:2}];function g(e){const n={a:"a",annotation:"annotation",br:"br",code:"code",h2:"h2",img:"img",li:"li",math:"math",mi:"mi",mo:"mo",mrow:"mrow",ol:"ol",p:"p",pre:"pre",semantics:"semantics",span:"span",...(0,r.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"https://codespaces.new/mpi-lamartin/environnement?quickstart=1",children:(0,t.jsx)(n.img,{src:"https://github.com/codespaces/badge.svg",alt:"Codespace"})})}),"\n",(0,t.jsx)(d.A,{file:c,lang:"ocaml",show:o.cor}),"\n",(0,t.jsx)(n.h2,{id:"tri-des-ar\xeates",children:"Tri des ar\xeates"}),"\n",(0,t.jsx)(n.p,{children:"On d\xe9finit les types suivants pour un graphe pond\xe9r\xe9 non-orient\xe9 en C :"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"typedef struct {\n    int u;\n    int v;\n    int poids;\n} arete;\n\ntypedef struct {\n    int n; // nombre de sommets\n    int *degres; // degres[i] = nombre de voisins du sommet i\n    arete **aretes; // aretes[i] = tableau des aretes incidentes au sommet i\n} graphe;\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"0",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["\xc9crire une fonction ",(0,t.jsx)(n.code,{children:"arete a(int u, int v, int poids)"})," renvoyant une nouvelle ar\xeate de poids ",(0,t.jsx)(n.code,{children:"poids"})," entre les sommets ",(0,t.jsx)(n.code,{children:"u"})," et ",(0,t.jsx)(n.code,{children:"v"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["D\xe9finir le graphe ",(0,t.jsx)(n.code,{children:"G1"})," suivant :"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(l.A,{alt:"Graphe",sources:{light:(0,a.Ay)("/img/g1_.png"),dark:(0,a.Ay)("/img/g1_inv.png")},width:"70%"}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)("summary",{children:"Solution"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"graphe g;\ng.n = 7;\ng.degres = malloc(7 * sizeof(int));\ng.degres[0] = 3;\ng.degres[1] = 3;\ng.degres[2] = 4;\ng.degres[3] = 3;\ng.degres[4] = 2;\ng.degres[5] = 3;\ng.degres[6] = 2;\ng.aretes = malloc(7 * sizeof(arete*));\nfor(int i = 0; i < 7; i++)\n    g.aretes[i] = malloc(g.degres[i] * sizeof(arete));\ng.aretes[0][0] = g.aretes[1][0] = a(0, 1, 1);\ng.aretes[0][1] = g.aretes[2][0] = a(0, 2, 5);\ng.aretes[0][2] = g.aretes[6][0] = a(0, 6, 5);\ng.aretes[1][1] = g.aretes[3][0] = a(1, 3, 2);\ng.aretes[1][2] = g.aretes[6][1] = a(1, 6, 3);\ng.aretes[2][1] = g.aretes[3][1] = a(2, 3, 3);\ng.aretes[2][2] = g.aretes[4][0] = a(2, 4, 2);\ng.aretes[2][3] = g.aretes[5][0] = a(2, 5, 5);\ng.aretes[3][2] = g.aretes[5][1] = a(3, 5, 1);\ng.aretes[4][1] = g.aretes[5][2] = a(4, 5, 5);\n"})})]}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsxs)(n.li,{children:["\xc9crire une fonction ",(0,t.jsx)(n.code,{children:"void free_graphe(graphe g)"})," lib\xe9rant la m\xe9moire allou\xe9e pour le graphe ",(0,t.jsx)(n.code,{children:"g"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["On utilisera ",(0,t.jsx)(n.code,{children:"G1"})," pour tester les fonctions suivantes."]}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:["\xc9crire une fonction ",(0,t.jsx)(n.code,{children:"int n_aretes(graphe g)"})," renvoyant le nombre d'ar\xeates du graphe ",(0,t.jsx)(n.code,{children:"g"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["\xc9crire une fonction ",(0,t.jsx)(n.code,{children:"arete* aretes(graphe g)"})," renvoyant un tableau contenant toutes les ar\xeates du graphe ",(0,t.jsx)(n.code,{children:"g"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Le tri par insertion trie un tableau ",(0,t.jsx)(n.code,{children:"t"})," en parcourant chaque \xe9l\xe9ment ",(0,t.jsx)(n.code,{children:"t[i]"})," et en le pla\xe7ant \xe0 sa place dans le sous-tableau tri\xe9 ",(0,t.jsx)(n.code,{children:"t[0]"}),", ",(0,t.jsx)(n.code,{children:"t[1]"}),", ..., ",(0,t.jsx)(n.code,{children:"t[i - 1]"}),". Pour le mettre \xe0 sa bonne position, on l'\xe9change avec l'\xe9l\xe9ment pr\xe9c\xe9dent tant que celui-ci est plus grand.",(0,t.jsx)(n.br,{}),"\n","L'invariant suivant est conserv\xe9 : \xe0 la fin de la ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"i"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"i"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6595em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"i"})]})})]}),"-\xe8me it\xe9ration, le sous-tableau ",(0,t.jsx)(n.code,{children:"t[0]"}),", ",(0,t.jsx)(n.code,{children:"t[1]"}),", ..., ",(0,t.jsx)(n.code,{children:"t[i]"})," est tri\xe9."]}),"\n",(0,t.jsxs)(n.ol,{start:"5",children:["\n",(0,t.jsxs)(n.li,{children:["\xc9crire une fonction ",(0,t.jsx)(n.code,{children:"void tri_insertion(arete* aretes, int n)"})," qui trie le tableau ",(0,t.jsx)(n.code,{children:"aretes"})," de taille ",(0,t.jsx)(n.code,{children:"n"}),", par poids croissant. Quelle est sa complexit\xe9 ?"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"union-find",children:"Union-Find"}),"\n",(0,t.jsx)(n.p,{children:"On utilise le type suivant pour repr\xe9senter une structure Union-Find :"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"typedef struct {\n  int n; // nombre d'\xe9lements\n  int* t; // t[i] = p\xe8re de i\n} uf;\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Si ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsx)(n.mrow,{children:(0,t.jsx)(n.mi,{children:"i"})}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"i"})]})})}),(0,t.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6595em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"i"})]})})]})," est une racine, on prendra ",(0,t.jsxs)(n.span,{className:"katex",children:[(0,t.jsx)(n.span,{className:"katex-mathml",children:(0,t.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,t.jsxs)(n.semantics,{children:[(0,t.jsxs)(n.mrow,{children:[(0,t.jsx)(n.mi,{children:"t"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"["}),(0,t.jsx)(n.mi,{children:"i"}),(0,t.jsx)(n.mo,{stretchy:"false",children:"]"}),(0,t.jsx)(n.mo,{children:"="}),(0,t.jsx)(n.mi,{children:"i"})]}),(0,t.jsx)(n.annotation,{encoding:"application/x-tex",children:"t[i] = i"})]})})}),(0,t.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"t"}),(0,t.jsx)(n.span,{className:"mopen",children:"["}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"i"}),(0,t.jsx)(n.span,{className:"mclose",children:"]"}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}}),(0,t.jsx)(n.span,{className:"mrel",children:"="}),(0,t.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2778em"}})]}),(0,t.jsxs)(n.span,{className:"base",children:[(0,t.jsx)(n.span,{className:"strut",style:{height:"0.6595em"}}),(0,t.jsx)(n.span,{className:"mord mathnormal",children:"i"})]})]})]}),"."]}),"\n",(0,t.jsxs)(n.ol,{start:"6",children:["\n",(0,t.jsxs)(n.li,{children:["\xc9crire une fonction ",(0,t.jsx)(n.code,{children:"uf create(int n)"})," initialisant une structure Union-Find de taille ",(0,t.jsx)(n.code,{children:"n"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["\xc9crire une fonction ",(0,t.jsx)(n.code,{children:"int find(uf u, int x)"})," renvoyant la racine de l'arbre contenant ",(0,t.jsx)(n.code,{children:"x"}),", sans compression de chemin."]}),"\n",(0,t.jsxs)(n.li,{children:["\xc9crire une fonction ",(0,t.jsx)(n.code,{children:"void merge(uf u, int x, int y)"})," fusionnant les arbres contenant ",(0,t.jsx)(n.code,{children:"x"})," et ",(0,t.jsx)(n.code,{children:"y"}),", sans optimisation."]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Remarque : on utilise ",(0,t.jsx)(n.code,{children:"merge"})," au lieu de ",(0,t.jsx)(n.code,{children:"union"})," car ce mot est r\xe9serv\xe9 en C."]}),"\n",(0,t.jsx)(n.h2,{id:"algorithme-de-kruskal",children:"Algorithme de Kruskal"}),"\n",(0,t.jsxs)(n.ol,{start:"9",children:["\n",(0,t.jsxs)(n.li,{children:["\xc9crire une fonction ",(0,t.jsx)(n.code,{children:"int n_cc(uf u)"})," renvoyant le nombre de composantes connexes de la structure Union-Find ",(0,t.jsx)(n.code,{children:"u"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["\xc9crire une fonction ",(0,t.jsx)(n.code,{children:"arete* kruskal(graphe g)"})," renvoyant un tableau contenant les ar\xeates de l'arbre couvrant minimum du graphe ",(0,t.jsx)(n.code,{children:"g"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"optimisations",children:"Optimisations"}),"\n",(0,t.jsxs)(n.ol,{start:"11",children:["\n",(0,t.jsxs)(n.li,{children:["R\xe9\xe9crire la fonction ",(0,t.jsx)(n.code,{children:"find"})," pour qu'elle utilise la compression de chemin."]}),"\n",(0,t.jsxs)(n.li,{children:["Red\xe9finir le type ",(0,t.jsx)(n.code,{children:"uf"})," et r\xe9\xe9crire ",(0,t.jsx)(n.code,{children:"merge"})," pour qu'il utilise l'union par rang."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"leetcode",children:"LeetCode"}),"\n",(0,t.jsxs)(n.ol,{start:"13",children:["\n",(0,t.jsxs)(n.li,{children:["R\xe9soudre ce ",(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/min-cost-to-connect-all-points",children:"probl\xe8me LeetCode"}),".\nPour cela, il faut utiliser un tri plus rapide que le tri par insertion. Vous pouvez impl\xe9menter un tri fusion, en vous inspirant de ",(0,t.jsx)(n.a,{href:"https://mp2i-info.github.io/7_algo/2_divide_conquer/divide_conquer",children:"https://mp2i-info.github.io/7_algo/2_divide_conquer/divide_conquer"})]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(g,{...e})}):g(e)}},30688:(e,n,i)=>{i.d(n,{A:()=>c});i(96540);var s=i(83457),t=i(34164),r=i(83551),a=i(6622);const l="details_JMAC";var d=i(74848);const c=({file:e,lang:n,show:i,title:c="Solution",children:o})=>(0,d.jsxs)("div",{children:[" ",i&&(0,d.jsxs)(r.B,{className:(0,t.A)("alert alert--success",l),summary:c,children:[o&&(0,d.jsx)(a.A,{children:o}),(0,d.jsx)(s.A,{language:n,children:e})]})]})}}]);