"use strict";(self.webpackChunkmpi_info=self.webpackChunkmpi_info||[]).push([[6337],{6648:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>l,metadata:()=>d,toc:()=>u});var t=i(4848),r=i(8453),s=i(688),o=i(2824);const l={title:"LeetCode 1 : Number of Islands",authors:"qfortier",tags:["leetcode","devoir","programmation"]},a=void 0,d={permalink:"/mpi-info/2025/10/18/leetcode1",editUrl:"https://github.com/mpi-lamartin/mpi-info/blog/2025-10-18-leetcode1.mdx",source:"@site/blog/2025-10-18-leetcode1.mdx",title:"LeetCode 1 : Number of Islands",description:"- Vous devez vous inscrire sur https://leetcode.com (en cliquant sur Create Account).",date:"2025-10-18T00:00:00.000Z",tags:[{inline:!0,label:"leetcode",permalink:"/mpi-info/tags/leetcode"},{inline:!0,label:"devoir",permalink:"/mpi-info/tags/devoir"},{inline:!0,label:"programmation",permalink:"/mpi-info/tags/programmation"}],hasTruncateMarker:!1,authors:[{name:"Quentin Fortier",title:"Professeur d'informatique",url:"https://fortierq.github.io/",imageURL:"https://fortierq.github.io/assets/images/photo_cv.png",key:"qfortier",page:null}],frontMatter:{title:"LeetCode 1 : Number of Islands",authors:"qfortier",tags:["leetcode","devoir","programmation"]},unlisted:!1,prevItem:{title:"LeetCode 2 : Min Cost to Connect All Points",permalink:"/mpi-info/2025/11/3/leetcode2"},nextItem:{title:"Cours 18/10",permalink:"/mpi-info/2025/10/16/cahier"}},c={authorsImageUrls:[void 0]},u=[];function p(e){const n={a:"a",br:"br",code:"code",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components},{Details:i}=n;return i||function(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Vous devez vous inscrire sur ",(0,t.jsx)(n.a,{href:"https://leetcode.com",children:"https://leetcode.com"})," (en cliquant sur Create Account)."]}),"\n",(0,t.jsxs)(n.li,{children:["Exercice \xe0 faire en C sur LeetCode : ",(0,t.jsx)(n.a,{href:"https://leetcode.com/problems/number-of-islands",children:"https://leetcode.com/problems/number-of-islands"})]}),"\n",(0,t.jsxs)(n.li,{children:["Une vid\xe9o explicative pour utiliser LeetCode : ",(0,t.jsx)(n.a,{href:"https://youtu.be/q5dEFWMO8-o",children:"https://youtu.be/q5dEFWMO8-o"})]}),"\n"]}),"\n",(0,t.jsxs)(i,{children:[(0,t.jsx)("summary",{children:"Indice"}),(0,t.jsxs)(n.p,{children:["Le probl\xe8me revient \xe0 calculer les composantes connexes du graphe dont les sommets sont les cases de la grille et o\xf9 chaque case a 4 ar\xeates possibles avec les cases voisines.",(0,t.jsx)(n.br,{}),"\n","Pour calculer le nombre de composantes connexes, on peut utiliser un parcours en profondeur (ou en largeur). On peut directement utiliser ",(0,t.jsx)(n.code,{children:"grid"})," comme tableau des vus (en mettant une case \xe0 '0' apr\xe8s l'avoir visit\xe9e)."]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-c",children:"// Parcours en profondeur depuis la case (i, j)\nvoid dfs(char** grid, int n, int p, int i, int j) {\n    ...\n}\n\nint numIslands(char** grid, int gridSize, int* gridColSize) {\n    int n = gridSize, p = gridColSize[0]; // n lignes, p colonnes\n    int k = 0; // nombre de composantes connexes\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < p; j++)\n            ...\n    return k;\n}\n"})})]}),"\n","\n",(0,t.jsx)(s.A,{file:o.A,lang:"c",show:!0})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(p,{...e})}):p(e)}},688:(e,n,i)=>{i.d(n,{A:()=>d});i(6540);var t=i(1432),r=i(4164),s=i(3551),o=i(9893);const l="details_JMAC";var a=i(4848);const d=e=>{let{file:n,lang:i,show:d,title:c="Solution",children:u}=e;return(0,a.jsxs)("div",{children:[" ",d&&(0,a.jsxs)(s.B,{className:(0,r.A)("alert alert--success",l),summary:c,children:[u&&(0,a.jsx)(o.A,{children:u}),(0,a.jsx)(t.A,{language:i,children:n})]})]})}},2824:(e,n,i)=>{i.d(n,{A:()=>t});const t="// Solution en O(l) avec un parcours en profondeur, o\xf9 l = np est le nombre de cases de la grille\n// Plut\xf4t qu'utiliser une matrice de bool\xe9ens vus, on peut mettre les cases visit\xe9es \xe0 0 pour \xe9viter de les revisiter\n\nvoid dfs(char** grid, int n, int p, int i, int j) {\n    if(grid[i][j] == '0') return;\n    grid[i][j] = '0';\n    if(i > 0) // chaque sommet a 4 voisins\n        dfs(grid, n, p, i - 1, j);\n    if(i < n - 1)\n        dfs(grid, n, p, i + 1, j);\n    if(j > 0)\n        dfs(grid, n, p, i, j - 1);\n    if(j < p - 1)\n        dfs(grid, n, p, i, j + 1);\n}\n\nint numIslands(char** grid, int gridSize, int* gridColSize) {\n    int n = gridSize, p = gridColSize[0];\n    int k = 0;\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < p; j++)\n            if(grid[i][j] == '1') {\n                dfs(grid, n, p, i, j);\n                k++;\n            }\n    return k;\n}\n"}}]);