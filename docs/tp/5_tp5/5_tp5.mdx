---
hide_table_of_contents: false
hide_title: false
cor: true
title: "TP 5 : Algorithme de Kruskal"
---

import useBaseUrl from '@docusaurus/useBaseUrl';
import ThemedImage from '@theme/ThemedImage';

## Tri des arêtes

On définit les types suivants pour un graphe pondéré non-orienté en C :

```c
typedef struct {
    int u;
    int v;
    int poids;
} arete;

typedef struct {
    int n; // nombre de sommets
    int *degres; // degres[i] = nombre de voisins du sommet i
    arete **aretes; // aretes[i] = tableau des aretes incidentes au sommet i
} graphe;
```

1. Écrire une fonction `arete a(int u, int v, int poids)` renvoyant une nouvelle arête de poids `poids` entre les sommets `u` et `v`.

2. Définir le graphe suivant. On l'utilisera pour tester les fonctions suivantes. On fera attention à libérer la mémoire à la fin de votre `main`, si besoin.

<ThemedImage
  alt="Graphe"
  sources={{
    light: useBaseUrl('/img/g1_.png'),
    dark: useBaseUrl('/img/g1_inv.png'),
  }}
  width={"70%"}
/>

<details>
<summary>Solution</summary>

```c
arete a0[] = {a(0, 1, 1), a(0, 2, 5), a(0, 6, 5)};
arete a1[] = {a(0, 1, 1), a(1, 3, 2), a(1, 6, 3)};
arete a2[] = {a(0, 2, 5), a(2, 3, 3), a(2, 5, 5), a(2, 4, 2)};
arete a3[] = {a(1, 3, 2), a(2, 3, 3), a(3, 5, 1)};
arete a4[] = {a(2, 4, 2), a(4, 5, 5)};
arete a5[] = {a(4, 5, 5), a(2, 5, 5), a(3, 5, 1)};
arete a6[] = {a(0, 6, 5), a(0, 6, 5)};
graphe g = {
    .n = 7,
    .degres = {3, 3, 4, 3, 2, 3, 2},
    .aretes = {a0, a1, a2, a3, a4, a5, a6}
};
  ```

</details>

3. Écrire une fonction `int n_aretes(graphe g)` renvoyant le nombre d'arêtes du graphe `g`.  
4. Écrire une fonction `arete* aretes(graphe g)` renvoyant un tableau contenant toutes les arêtes du graphe `g`.

Le tri par insertion trie un tableau `t` en parcourant chaque élément `t[i]` et en le plaçant à sa place dans le sous-tableau trié `t[0]`, `t[1]`, ..., `t[i - 1]`. Pour le mettre à sa bonne position, on l'échange avec l'élément précédent tant que celui-ci est plus grand.  
L'invariant suivant est conservé : à la fin de la $i$-ème itération, le sous-tableau `t[0]`, `t[1]`, ..., `t[i]` est trié.

5. Écrire une fonction `void tri_insertion(arete* aretes, int n)` qui trie le tableau `aretes` de taille `n`, par poids croissant. Quelle est sa complexité ?  

## Union-Find

On utilise le type suivant pour représenter une structure Union-Find :

```c
typedef struct {
  int n; // nombre d'élements
  int* t; // t[i] = père de i
} uf;
```

Si $i$ est une racine, on prendra $t[i] = i$.

6. Écrire une fonction `uf create(int n)` initialisant une structure Union-Find de taille `n`.  
7. Écrire une fonction `int find(uf u, int x)` renvoyant la racine de l'arbre contenant `x`, sans compression de chemin.
8. Écrire une fonction `void merge(uf u, int x, int y)` fusionnant les arbres contenant `x` et `y`, sans optimisation.

## Algorithme de Kruskal

9. Écrire une fonction `int n_cc(uf u)` renvoyant le nombre de composantes connexes de la structure Union-Find `u`.
10. Écrire une fonction `arete* kruskal(graphe g)` renvoyant un tableau contenant les arêtes de l'arbre couvrant minimum du graphe `g`.

## Optimisations

11. Réécrire la fonction `find` pour qu'elle utilise la compression de chemin.  
12. Redéfinir le type `uf` et réécrire `merge` pour qu'il utilise l'union par rang.

## LeetCode

13. Résoudre ce [problème LeetCode](https://leetcode.com/problems/min-cost-to-connect-all-points).

