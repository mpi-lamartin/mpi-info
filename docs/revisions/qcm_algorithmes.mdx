---
title: "QCM Révisions - Algorithmes et Structures de données"
sidebar_position: 1
---

import QCMRandom from '@site/src/components/QCMRandom';

# QCM Révisions — Algorithmes et Structures de données

Les questions sont posées une par une dans un ordre aléatoire. Pour chaque question, il s'agit d'identifier un algorithme ou une structure de données à partir de sa description, ou inversement.

<QCMRandom
  title="QCM — Algorithmes et Structures de données"
  questions={[
    {
      question:
        "Quel algorithme calcule les plus courts chemins depuis un sommet source dans un graphe pondéré à poids positifs, en explorant les sommets par ordre croissant de distance ?",
      answers: ["Bellman-Ford", "Dijkstra", "Floyd-Warshall", "BFS"],
      correct: 1,
      explanation:
        "L'algorithme de Dijkstra explore les sommets par ordre croissant de distance à la source en utilisant une file de priorité.",
    },
    {
      question: "L'algorithme de Dijkstra permet de :",
      answers: [
        "Calculer un arbre couvrant de poids minimum",
        "Trouver les composantes fortement connexes",
        "Calculer les plus courts chemins depuis une source dans un graphe à poids positifs",
        "Trier les arêtes d'un graphe",
      ],
      correct: 2,
      explanation:
        "Dijkstra calcule les plus courts chemins depuis un sommet source dans un graphe pondéré dont les poids sont positifs.",
    },
    {
      question:
        "Quel algorithme est une variante de Dijkstra utilisant une heuristique $h(v)$ estimant la distance restante au sommet cible pour explorer en priorité les sommets les plus prometteurs ?",
      answers: ["Bellman-Ford", "Kruskal", "A*", "Floyd-Warshall"],
      correct: 2,
      explanation:
        "A* utilise une heuristique pour guider la recherche vers le sommet cible plus efficacement que Dijkstra.",
    },
    {
      question: "L'algorithme A* permet de :",
      answers: [
        "Trouver le plus court chemin entre deux sommets en utilisant une heuristique",
        "Calculer les composantes connexes d'un graphe",
        "Trouver un arbre couvrant de poids minimum",
        "Déterminer si un graphe est planaire",
      ],
      correct: 0,
      explanation:
        "A* combine le coût réel du chemin avec une heuristique estimant le coût restant pour guider efficacement la recherche.",
    },
    {
      question:
        "Quel algorithme de programmation dynamique calcule les plus courts chemins depuis une source dans un graphe pouvant contenir des poids négatifs, en relâchant les arêtes $n-1$ fois ?",
      answers: ["Dijkstra", "Floyd-Warshall", "Bellman-Ford", "Kruskal"],
      correct: 2,
      explanation:
        "Bellman-Ford gère les poids négatifs en relâchant toutes les arêtes $n-1$ fois successivement.",
    },
    {
      question: "L'algorithme de Bellman-Ford permet de :",
      answers: [
        "Calculer les distances depuis une source dans un graphe à poids négatifs",
        "Trouver le plus grand couplage d'un graphe",
        "Calculer un arbre couvrant de poids minimum",
        "Trier un tableau",
      ],
      correct: 0,
      explanation:
        "Bellman-Ford peut traiter des graphes avec des poids négatifs, contrairement à Dijkstra.",
    },
    {
      question:
        "Quel algorithme de programmation dynamique calcule les distances entre toutes les paires de sommets d'un graphe en considérant progressivement chaque sommet comme intermédiaire ?",
      answers: ["Dijkstra", "Bellman-Ford", "Kosaraju", "Floyd-Warshall"],
      correct: 3,
      explanation:
        "Floyd-Warshall considère chaque sommet comme intermédiaire potentiel dans les chemins entre toutes les paires.",
    },
    {
      question: "L'algorithme de Floyd-Warshall permet de :",
      answers: [
        "Calculer les plus courts chemins depuis un sommet source",
        "Calculer les distances entre toutes les paires de sommets",
        "Trouver un cycle eulérien",
        "Détecter les composantes fortement connexes",
      ],
      correct: 1,
      explanation:
        "Floyd-Warshall résout le problème des plus courts chemins entre toutes les paires de sommets en $O(n^3)$.",
    },
    {
      question:
        "Quel algorithme trouve les composantes fortement connexes d'un graphe orienté en effectuant deux parcours en profondeur (un sur le graphe et un sur le graphe transposé) ?",
      answers: ["Kruskal", "Dijkstra", "Kosaraju", "Prim"],
      correct: 2,
      explanation:
        "Kosaraju effectue un premier DFS pour obtenir un ordre de traitement, puis un second DFS sur le graphe transposé.",
    },
    {
      question: "L'algorithme de Kosaraju permet de :",
      answers: [
        "Trouver un arbre couvrant de poids minimum",
        "Calculer un couplage maximum",
        "Trouver les composantes fortement connexes d'un graphe orienté",
        "Calculer les plus courts chemins",
      ],
      correct: 2,
      explanation:
        "Kosaraju identifie les composantes fortement connexes en utilisant deux parcours DFS.",
    },
    {
      question:
        "Quel algorithme glouton calcule un arbre couvrant de poids minimum en triant les arêtes par poids croissant et en ajoutant chaque arête qui ne crée pas de cycle ?",
      answers: ["Prim", "Dijkstra", "Kruskal", "Bellman-Ford"],
      correct: 2,
      explanation:
        "Kruskal trie les arêtes puis les ajoute une par une si elles ne créent pas de cycle, en utilisant Union-Find.",
    },
    {
      question: "L'algorithme de Kruskal permet de :",
      answers: [
        "Trouver le plus court chemin entre deux sommets",
        "Calculer un arbre couvrant de poids minimum",
        "Détecter les cycles dans un graphe",
        "Trier les sommets par degré",
      ],
      correct: 1,
      explanation:
        "Kruskal construit un arbre couvrant de poids minimum en ajoutant les arêtes par poids croissant sans créer de cycle.",
    },
    {
      question:
        "Quel algorithme glouton calcule un arbre couvrant de poids minimum en partant d'un sommet et en ajoutant à chaque étape l'arête sortante de l'arbre de poids minimum ?",
      answers: ["Kruskal", "Prim", "Dijkstra", "Floyd-Warshall"],
      correct: 1,
      explanation:
        "Prim fait grossir l'arbre sommet par sommet en choisissant l'arête de poids minimum connectant l'arbre à un nouveau sommet.",
    },
    {
      question: "L'algorithme de Prim permet de :",
      answers: [
        "Calculer un arbre couvrant de poids minimum",
        "Trouver les composantes fortement connexes",
        "Calculer les plus courts chemins depuis une source",
        "Trouver un couplage parfait",
      ],
      correct: 0,
      explanation:
        "Prim construit un ACM en partant d'un sommet et en ajoutant l'arête de poids minimum vers un sommet non encore dans l'arbre.",
    },
    {
      question:
        "Quel algorithme calcule un couplage maximum dans un graphe en cherchant itérativement des chemins augmentants ?",
      answers: [
        "Kruskal",
        "Algorithme de couplage par chemin augmentant",
        "Kosaraju",
        "Bellman-Ford",
      ],
      correct: 1,
      explanation:
        "L'algorithme cherche des chemins augmentants et applique la différence symétrique avec le couplage courant pour l'agrandir.",
    },
    {
      question: "L'algorithme de couplage par chemin augmentant permet de :",
      answers: [
        "Trouver un cycle hamiltonien",
        "Calculer un couplage maximum dans un graphe",
        "Trouver un arbre couvrant de poids minimum",
        "Déterminer la connexité d'un graphe",
      ],
      correct: 1,
      explanation:
        "En cherchant itérativement des chemins augmentants, on construit un couplage de taille maximale.",
    },
    {
      question:
        "Quel parcours de graphe visite les sommets le plus profondément possible avant de revenir en arrière, implémenté récursivement ?",
      answers: ["BFS", "Dijkstra", "DFS (parcours en profondeur)", "A*"],
      correct: 2,
      explanation:
        "Le DFS (Depth-First Search) explore chaque branche aussi loin que possible avant de revenir en arrière.",
    },
    {
      question: "Le parcours DFS (en profondeur) permet de :",
      answers: [
        "Visiter les sommets par distance croissante à la source",
        "Explorer les sommets le plus profondément possible avant de revenir en arrière",
        "Calculer les plus courts chemins dans un graphe pondéré",
        "Trier les sommets par degré",
      ],
      correct: 1,
      explanation:
        "Le DFS explore récursivement en allant le plus loin possible dans chaque branche.",
    },
    {
      question:
        "Quel parcours de graphe visite les sommets par distance croissante depuis une racine, en utilisant une file ?",
      answers: ["DFS", "BFS (parcours en largeur)", "Dijkstra", "Kosaraju"],
      correct: 1,
      explanation:
        "Le BFS (Breadth-First Search) utilise une file pour explorer les sommets couche par couche.",
    },
    {
      question: "Le parcours BFS (en largeur) permet de :",
      answers: [
        "Explorer les sommets le plus profondément possible",
        "Calculer un arbre couvrant de poids minimum",
        "Visiter les sommets par distance croissante depuis la source",
        "Détecter les composantes fortement connexes",
      ],
      correct: 2,
      explanation:
        "Le BFS visite les sommets couche par couche, ce qui donne les distances dans un graphe non pondéré.",
    },
    {
      question:
        "Quel type d'algorithme probabiliste renvoie toujours un résultat correct mais avec un temps d'exécution variable ?",
      answers: [
        "Monte-Carlo",
        "Las Vegas",
        "Algorithme d'approximation",
        "Algorithme glouton",
      ],
      correct: 1,
      explanation:
        "Un algorithme de Las Vegas est toujours correct mais son temps d'exécution est aléatoire. Exemple : tri rapide randomisé.",
    },
    {
      question: "Un algorithme de Las Vegas est un algorithme qui :",
      answers: [
        "Peut renvoyer un résultat incorrect mais s'exécute en temps déterministe",
        "Renvoie toujours un résultat correct mais avec un temps d'exécution aléatoire",
        "Garantit un facteur d'approximation constant",
        "Fonctionne uniquement sur des graphes",
      ],
      correct: 1,
      explanation:
        "Las Vegas = toujours correct, temps variable. Exemple : quicksort randomisé.",
    },
    {
      question:
        "Quel type d'algorithme probabiliste peut renvoyer un résultat incorrect mais s'exécute toujours en temps déterministe ?",
      answers: ["Las Vegas", "Monte-Carlo", "Backtracking", "Branch and Bound"],
      correct: 1,
      explanation:
        "Un algorithme de Monte-Carlo a un temps d'exécution fixe mais peut se tromper. Exemple : test de primalité de Fermat.",
    },
    {
      question: "Un algorithme de Monte-Carlo est un algorithme qui :",
      answers: [
        "Renvoie toujours un résultat correct en temps aléatoire",
        "Peut renvoyer un résultat incorrect mais avec un temps d'exécution déterministe",
        "Calcule un résultat exact en temps polynomial",
        "Résout un problème NP-complet en temps polynomial",
      ],
      correct: 1,
      explanation:
        "Monte-Carlo = temps fixe, résultat potentiellement faux. Exemple : test de Fermat.",
    },
    {
      question:
        "Quel type d'algorithme polynomial garantit une solution dont la valeur est à un facteur $\\alpha$ constant de la solution optimale, pour un problème NP-difficile ?",
      answers: [
        "Algorithme de Las Vegas",
        "Algorithme glouton",
        "Algorithme d'approximation",
        "Algorithme de Monte-Carlo",
      ],
      correct: 2,
      explanation:
        "Un algorithme d'approximation est polynomial et garantit que sa solution est au plus $\\alpha$ fois pire que l'optimal.",
    },
    {
      question: "Un algorithme d'approximation permet de :",
      answers: [
        "Résoudre exactement un problème NP-difficile",
        "Obtenir une solution polynomiale à facteur garanti de l'optimum pour un problème NP-difficile",
        "Trouver la solution optimale en temps exponentiel",
        "Vérifier si un problème est NP-complet",
      ],
      correct: 1,
      explanation:
        "Les algorithmes d'approximation fournissent une solution avec un ratio de performance garanti en temps polynomial.",
    },
    {
      question:
        "Quel algorithme explore un arbre de jeu en utilisant une heuristique pour estimer la valeur des configurations, dans les jeux à deux joueurs ?",
      answers: ["K-moyennes", "Dijkstra", "Min-Max", "Kosaraju"],
      correct: 2,
      explanation:
        "Min-Max évalue les positions de jeu en alternant maximisation (joueur) et minimisation (adversaire).",
    },
    {
      question: "L'algorithme Min-Max permet de :",
      answers: [
        "Trouver le plus court chemin dans un graphe",
        "Jouer de manière optimale dans un jeu à deux joueurs à information complète",
        "Classifier des données par apprentissage",
        "Compresser un fichier",
      ],
      correct: 1,
      explanation:
        "Min-Max explore l'arbre de jeu en alternant min et max pour déterminer le meilleur coup.",
    },
    {
      question:
        "Quel algorithme de classification supervisée prédit la classe d'une donnée à partir des $k$ données les plus proches dans l'ensemble d'entraînement ?",
      answers: [
        "K-moyennes",
        "ID3",
        "K plus proches voisins (KNN)",
        "Classification hiérarchique",
      ],
      correct: 2,
      explanation:
        "KNN classe une donnée en trouvant les k plus proches voisins et en renvoyant la classe majoritaire.",
    },
    {
      question: "L'algorithme des K plus proches voisins (KNN) permet de :",
      answers: [
        "Partitionner des données en k groupes sans supervision",
        "Prédire la classe d'une donnée en cherchant ses k voisins les plus proches",
        "Construire un arbre de décision",
        "Calculer un couplage maximum",
      ],
      correct: 1,
      explanation:
        "KNN est un algorithme supervisé : il utilise les classes connues des voisins pour prédire celle de la nouvelle donnée.",
    },
    {
      question:
        "Quel algorithme de classification non supervisée partitionne des données en $k$ groupes en recalculant itérativement les centres des classes ?",
      answers: ["KNN", "K-moyennes (K-means)", "ID3", "Min-Max"],
      correct: 1,
      explanation:
        "K-means attribue chaque donnée au centre le plus proche puis recalcule les centres, jusqu'à convergence.",
    },
    {
      question: "L'algorithme des K-moyennes (K-means) permet de :",
      answers: [
        "Classifier une donnée en utilisant ses voisins les plus proches",
        "Partitionner des données en k groupes en minimisant la variance intra-classe",
        "Construire un arbre de décision",
        "Calculer les composantes connexes d'un graphe",
      ],
      correct: 1,
      explanation:
        "K-means est un algorithme non supervisé qui partitionne les données en minimisant la distance aux centres des classes.",
    },
    {
      question:
        "Quel algorithme de classification non supervisée fusionne itérativement les deux classes les plus proches, en partant d'une classe par donnée ?",
      answers: [
        "K-moyennes",
        "KNN",
        "Classification hiérarchique ascendante (CHA)",
        "ID3",
      ],
      correct: 2,
      explanation:
        "La CHA construit une hiérarchie de classes en fusionnant les plus proches à chaque étape.",
    },
    {
      question: "La classification hiérarchique ascendante (CHA) permet de :",
      answers: [
        "Prédire la classe d'une donnée par ses voisins",
        "Fusionner itérativement les classes les plus proches pour former une hiérarchie",
        "Construire un arbre de décision par gain d'information",
        "Résoudre un problème de plus court chemin",
      ],
      correct: 1,
      explanation:
        "La CHA part de n classes (une par donnée) et fusionne les deux plus proches à chaque étape.",
    },
    {
      question:
        "Quel algorithme de classification supervisée construit un arbre de décision en choisissant à chaque nœud l'attribut maximisant le gain d'information ?",
      answers: ["KNN", "K-moyennes", "Min-Max", "ID3"],
      correct: 3,
      explanation:
        "ID3 construit un arbre de décision de manière gloutonne en maximisant le gain d'entropie à chaque nœud.",
    },
    {
      question: "L'algorithme ID3 permet de :",
      answers: [
        "Partitionner des données en k groupes",
        "Construire un arbre de décision par maximisation du gain d'information",
        "Classifier une donnée par ses k plus proches voisins",
        "Explorer un arbre de jeu",
      ],
      correct: 1,
      explanation:
        "ID3 choisit à chaque nœud l'attribut qui réduit le plus l'entropie pour construire un arbre de décision.",
    },
    {
      question:
        "Quel algorithme construit un automate (de Glushkov) reconnaissant le langage d'une expression régulière en linéarisant l'expression ?",
      answers: [
        "Déterminisation",
        "Berry-Sethi (Glushkov)",
        "Kleene",
        "Floyd-Warshall",
      ],
      correct: 1,
      explanation:
        "Berry-Sethi (ou Glushkov) linéarise l'expression régulière et construit un automate local reconnaissant le même langage.",
    },
    {
      question: "L'algorithme de Berry-Sethi (Glushkov) permet de :",
      answers: [
        "Déterminiser un automate non déterministe",
        "Construire un automate reconnaissant le langage d'une expression régulière",
        "Minimiser un automate déterministe",
        "Calculer le complément d'un langage",
      ],
      correct: 1,
      explanation:
        "Berry-Sethi construit un automate à partir d'une expression régulière en passant par la linéarisation.",
    },
    {
      question:
        "Quel algorithme transforme un automate non déterministe en automate déterministe équivalent par construction des parties ?",
      answers: [
        "Berry-Sethi",
        "Algorithme de déterminisation (construction par sous-ensembles)",
        "Kleene",
        "Kosaraju",
      ],
      correct: 1,
      explanation:
        "La déterminisation construit l'automate des parties : chaque état de l'automate déterministe est un sous-ensemble d'états de l'AFN.",
    },
    {
      question:
        "L'algorithme de déterminisation (construction par sous-ensembles) permet de :",
      answers: [
        "Construire une expression régulière à partir d'un automate",
        "Transformer un automate non déterministe en automate déterministe équivalent",
        "Trouver le plus court mot reconnu par un automate",
        "Vérifier si un langage est régulier",
      ],
      correct: 1,
      explanation:
        "La construction par sous-ensembles produit un AFD dont chaque état correspond à un ensemble d'états de l'AFN.",
    },
    {
      question:
        "Quel algorithme d'exclusion mutuelle pour deux threads utilise un tableau `want` et une variable `turn` ?",
      answers: ["Lamport", "Dekker", "Peterson", "Dijkstra"],
      correct: 2,
      explanation:
        "Peterson utilise deux variables want (indiquant le souhait d'entrer en section critique) et turn (cédant la priorité).",
    },
    {
      question: "L'algorithme de Peterson permet de :",
      answers: [
        "Trouver le plus court chemin dans un graphe",
        "Assurer l'exclusion mutuelle entre deux threads",
        "Trier un tableau en parallèle",
        "Détecter les interblocages",
      ],
      correct: 1,
      explanation:
        "Peterson garantit l'exclusion mutuelle et l'absence de famine pour deux processus concurrents.",
    },
    {
      question:
        "Quel algorithme d'exclusion mutuelle généralisé à $n$ threads utilise un système de tickets de priorité ?",
      answers: ["Peterson", "Dekker", "Boulangerie de Lamport", "Min-Max"],
      correct: 2,
      explanation:
        "La boulangerie de Lamport : chaque thread prend un ticket et attend que tous les threads de ticket inférieur aient fini.",
    },
    {
      question: "L'algorithme de la boulangerie de Lamport permet de :",
      answers: [
        "Assurer l'exclusion mutuelle entre n threads grâce à un système de tickets",
        "Calculer les composantes connexes en parallèle",
        "Optimiser l'ordonnancement des processus",
        "Classifier des données par apprentissage",
      ],
      correct: 0,
      explanation:
        "Lamport généralise l'exclusion mutuelle à n processus avec un mécanisme de prise de ticket.",
    },
    {
      question:
        "Quelle méthode algorithmique résout un problème en combinant une équation de récurrence avec le stockage des résultats intermédiaires pour éviter les recalculs ?",
      answers: [
        "Backtracking",
        "Algorithme glouton",
        "Programmation dynamique",
        "Diviser pour régner",
      ],
      correct: 2,
      explanation:
        "La programmation dynamique mémorise les sous-problèmes déjà résolus pour éviter de les recalculer.",
    },
    {
      question: "La programmation dynamique consiste à :",
      answers: [
        "Explorer toutes les solutions et revenir en arrière",
        "Choisir localement le meilleur choix à chaque étape",
        "Combiner récurrence et stockage des résultats intermédiaires pour éviter les recalculs",
        "Diviser le problème en sous-problèmes indépendants",
      ],
      correct: 2,
      explanation:
        "La programmation dynamique utilise une relation de récurrence et du stockage (mémoïsation ou tableau) pour éviter les calculs redondants.",
    },
    {
      question:
        "Quel algorithme glouton de compression construit un arbre binaire optimal où les lettres fréquentes ont un code court ?",
      answers: ["LZW", "Rabin-Karp", "Huffman", "Boyer-Moore-Horspool"],
      correct: 2,
      explanation:
        "Huffman construit un arbre de codage préfixe optimal en fusionnant les deux symboles les moins fréquents à chaque étape.",
    },
    {
      question: "L'algorithme de Huffman permet de :",
      answers: [
        "Rechercher un motif dans un texte",
        "Compresser des données en construisant un code préfixe optimal basé sur les fréquences",
        "Trier un texte par ordre alphabétique",
        "Calculer la distance d'édition entre deux mots",
      ],
      correct: 1,
      explanation:
        "Huffman produit un codage sans perte où les caractères fréquents ont un code court.",
    },
    {
      question:
        "Quel algorithme de compression en ligne construit un dictionnaire de motifs au fur et à mesure de la lecture du texte ?",
      answers: [
        "Huffman",
        "Rabin-Karp",
        "Boyer-Moore-Horspool",
        "LZW (Lempel-Ziv-Welch)",
      ],
      correct: 3,
      explanation:
        "LZW construit dynamiquement un dictionnaire et remplace les motifs déjà vus par des codes plus courts.",
    },
    {
      question: "L'algorithme LZW (Lempel-Ziv-Welch) permet de :",
      answers: [
        "Construire un arbre de Huffman",
        "Compresser un texte en construisant un dictionnaire de motifs au fur et à mesure",
        "Rechercher un motif dans un texte",
        "Coder un texte en base 64",
      ],
      correct: 1,
      explanation:
        "LZW est un algorithme de compression en ligne : il enrichit le dictionnaire à chaque caractère lu.",
    },
    {
      question:
        "Quel algorithme de recherche de motif dans un texte utilise une fonction de hachage glissante (rolling hash) ?",
      answers: ["Boyer-Moore-Horspool", "Huffman", "Rabin-Karp", "LZW"],
      correct: 2,
      explanation:
        "Rabin-Karp utilise un hash glissant pour comparer le motif à chaque fenêtre du texte en $O(n)$ en moyenne.",
    },
    {
      question: "L'algorithme de Rabin-Karp permet de :",
      answers: [
        "Compresser un texte",
        "Rechercher un motif dans un texte en utilisant une fonction de hachage glissante",
        "Trier un tableau de chaînes",
        "Construire un automate à partir d'un motif",
      ],
      correct: 1,
      explanation:
        "Rabin-Karp compare le hash du motif avec le hash de chaque fenêtre du texte, recalculé en $O(1)$.",
    },
    {
      question:
        "Quel algorithme de recherche de motif compare les caractères de droite à gauche et utilise une table de décalage précalculée ?",
      answers: ["Rabin-Karp", "Boyer-Moore-Horspool", "Huffman", "KMP"],
      correct: 1,
      explanation:
        "Boyer-Moore-Horspool compare de droite à gauche et saute des positions grâce à une table de décalage.",
    },
    {
      question: "L'algorithme de Boyer-Moore-Horspool permet de :",
      answers: [
        "Compresser un texte par dictionnaire",
        "Rechercher un motif dans un texte en comparant de droite à gauche avec des sauts optimisés",
        "Construire un arbre de suffixes",
        "Calculer la distance de Levenshtein",
      ],
      correct: 1,
      explanation:
        "Boyer-Moore-Horspool est efficace en pratique grâce aux sauts lors des non-correspondances.",
    },
    {
      question:
        "Quelle méthode algorithmique explore récursivement les solutions possibles et revient en arrière dès qu'une branche ne peut mener à une solution valide ?",
      answers: [
        "Programmation dynamique",
        "Algorithme glouton",
        "Backtracking (retour sur trace)",
        "Algorithme d'approximation",
      ],
      correct: 2,
      explanation:
        "Le backtracking explore l'arbre des solutions et élague les branches invalides pour réduire l'espace de recherche.",
    },
    {
      question: "Le backtracking (retour sur trace) consiste à :",
      answers: [
        "Choisir localement le meilleur choix",
        "Explorer récursivement les solutions et revenir en arrière si une branche est invalide",
        "Mémoriser les résultats intermédiaires",
        "Diviser le problème en deux sous-problèmes",
      ],
      correct: 1,
      explanation:
        "Le backtracking est une exploration systématique avec élagage des branches sans issue.",
    },
    {
      question:
        "Quel algorithme résout le problème SAT par backtracking sur une formule en FNC, en affectant successivement chaque variable ?",
      answers: [
        "Kosaraju",
        "Min-Max",
        "Quine (DPLL simplifié)",
        "Floyd-Warshall",
      ],
      correct: 2,
      explanation:
        "L'algorithme de Quine affecte chaque variable à vrai ou faux et simplifie les clauses à chaque étape par backtracking.",
    },
    {
      question: "L'élagage alpha-bêta est une optimisation de Min-Max qui :",
      answers: [
        "Explore tous les nœuds de l'arbre de jeu",
        "Coupe les branches qui ne peuvent pas influencer le résultat final",
        "Utilise une heuristique pour évaluer les feuilles",
        "Calcule le couplage dans un graphe biparti",
      ],
      correct: 1,
      explanation: "Alpha-bêta élague les branches inutiles de l'arbre de jeu en maintenant des bornes $\\alpha$ et $\\beta$."
    },
    {
      question: "Quelle structure de données permet d'ajouter et extraire le maximum (ou minimum) en $O(\\log n)$, et d'accéder au maximum en $O(1)$ ?",
      answers: ["Pile", "File", "Tas binaire (file de priorité)", "Table de hachage"],
      correct: 2,
      explanation: "Le tas binaire est un arbre binaire presque complet implémenté par un tableau, avec insertion et extraction en $O(\\log n)$."
    },
    {
      question: "Le tas binaire (binary heap) supporte les opérations suivantes :",
      answers: [
        "push, pop, is_empty en $O(1)$",
        "ajouter en $O(\\log n)$, extraire le max en $O(\\log n)$, valeur du max en $O(1)$",
        "ajout en $O(1)$, extraction en $O(1)$ amorti",
        "recherche, ajout, suppression en $O(\\log n)$"
      ],
      correct: 1,
      explanation: "Le tas offre l'accès au max en $O(1)$ (racine), l'insertion et l'extraction en $O(\\log n)$ via les opérations up et down."
    },
    {
      question: "Quels algorithmes du cours utilisent un tas binaire (file de priorité) ?",
      answers: [
        "Dijkstra",
        "A*",
        "Tri par tas (heapsort)",
        "Huffman",
        "BFS",
        "Floyd-Warshall",
        "Kruskal",
        "KNN"
      ],
      correct: [0, 1, 2, 3],
      explanation: "Le tas (file de priorité) est utilisé par Dijkstra et A* pour extraire le sommet le plus proche, par le tri par tas (heapsort), et par Huffman pour fusionner les arbres de fréquences minimales."
    },
    {
      question: "Quelle structure de données représente une partition en classes disjointes avec les opérations `find` (trouver le représentant) et `union` (fusionner deux classes) ?",
      answers: ["Tas binaire", "ABR", "Union-Find", "Table de hachage"],
      correct: 2,
      explanation: "Union-Find stocke une partition dans un tableau de pères. Avec compression de chemins et union par rang, find et union sont en $O(\\alpha(n))$ amorti."
    },
    {
      question: "Quel algorithme du cours utilise la structure Union-Find ?",
      answers: ["Kruskal"],
      correct: 0,
      explanation: "Kruskal utilise Union-Find pour vérifier efficacement si une arête crée un cycle (si ses deux extrémités sont dans la même composante)."
    },
    {
      question: "Avec les heuristiques d'union par rang et compression de chemins, la complexité amortie de `find` et `union` dans Union-Find est :",
      answers: ["$O(n)$", "$O(\\log n)$", "$O(\\alpha(n)) \\approx O(1)$", "$O(n \\log n)$"],
      correct: 2,
      explanation: "$\\alpha$ est la fonction inverse d'Ackermann, qui croît extrêmement lentement : $\\alpha(n) \\leq 4$ pour tout $n$ pratique."
    },
    {
      question: "Quelle structure de données de type LIFO (dernier entré, premier sorti) supporte `push` et `pop` en $O(1)$ ?",
      answers: ["File", "Pile", "Tas", "ABR"],
      correct: 1,
      explanation: "La pile (stack) est une structure LIFO. En OCaml, elle s'implémente naturellement avec une liste (tête = sommet)."
    },
    {
      question: "Quel algorithme du cours utilise une pile (ou la pile d'appels récursifs) ?",
      answers: ["DFS (parcours en profondeur)"],
      correct: 0,
      explanation: "Le DFS utilise la pile d'appels récursifs, ou une pile explicite dans sa version itérative."
    },
    {
      question: "Quelle structure de données de type FIFO (premier entré, premier sorti) supporte l'ajout et l'extraction en $O(1)$ amorti ?",
      answers: ["Pile", "File", "Tas", "ABR"],
      correct: 1,
      explanation: "La file (queue) est FIFO. Implémentable avec deux listes : ajout dans l'une, extraction dans l'autre, renversement si nécessaire."
    },
    {
      question: "Quel algorithme du cours utilise une file ?",
      answers: ["BFS (parcours en largeur)"],
      correct: 0,
      explanation: "Le BFS utilise une file pour traiter les sommets par distance croissante à la source."
    },
    {
      question: "Quelle structure de données représente un graphe avec un espace $O(n^2)$, un test d'adjacence en $O(1)$ mais un parcours des voisins en $O(n)$ ?",
      answers: ["Liste d'adjacence", "Matrice d'adjacence", "Dictionnaire d'adjacence", "Table de hachage"],
      correct: 1,
      explanation: "La matrice d'adjacence utilise un tableau $n \\times n$. Elle est adaptée aux graphes denses."
    },
    {
      question: "Quels algorithmes sont naturellement adaptés à une matrice d'adjacence ?",
      answers: [
        "Floyd-Warshall",
        "Exponentiation de matrice ($A^k$)",
        "BFS",
        "DFS",
        "Dijkstra",
        "Kruskal"
      ],
      correct: [0, 1],
      explanation: "Floyd-Warshall travaille directement sur une matrice de distances. L'exponentiation de matrice ($A^k$) compte les chemins de longueur $k$."
    },
    {
      question: "Quelle structure de données représente un graphe avec un espace $O(n + m)$ et un parcours des voisins de $u$ en $O(\\deg(u))$ ?",
      answers: ["Matrice d'adjacence", "Liste d'adjacence", "Tas binaire", "Union-Find"],
      correct: 1,
      explanation: "La liste d'adjacence stocke pour chaque sommet la liste de ses voisins. Elle est adaptée aux graphes creux."
    },
    {
      question: "Quels algorithmes sont plus efficaces avec des listes d'adjacence qu'avec une matrice d'adjacence ?",
      answers: [
        "DFS",
        "BFS",
        "Dijkstra",
        "Bellman-Ford",
        "Kosaraju",
        "Floyd-Warshall",
        "Exponentiation de matrice"
      ],
      correct: [0, 1, 2, 3, 4],
      explanation: "DFS et BFS sont en $O(n + m)$ avec listes d'adjacence contre $O(n^2)$ avec matrice. Dijkstra, Bellman-Ford et Kosaraju parcourent aussi les voisins."
    },
    {
      question: "Quelle structure de données est un arbre binaire tel que pour chaque nœud $r$, toutes les étiquettes du sous-arbre gauche sont $\\leq r$ et toutes celles du sous-arbre droit sont $\\geq r$ ?",
      answers: ["Tas binaire", "Arbre binaire de recherche (ABR)", "Arbre de Huffman", "Arbre rouge-noir"],
      correct: 1,
      explanation: "L'ABR est défini par cette propriété héréditaire. Son parcours infixe donne les éléments triés."
    },
    {
      question: "L'arbre binaire de recherche (ABR) supporte les opérations suivantes :",
      answers: [
        "recherche, ajout, suppression en $O(h)$ (hauteur de l'arbre)",
        "extraction du max en $O(1)$, ajout en $O(\\log n)$",
        "push, pop en $O(1)$",
        "find, union en $O(\\alpha(n))$"
      ],
      correct: 0,
      explanation: "Toutes les opérations d'un ABR parcourent une branche, donc en $O(h)$. Si l'arbre est équilibré, $h = O(\\log n)$."
    },
    {
      question: "Quelle variante d'ABR garantit une hauteur $h = O(\\log n)$ grâce à un coloriage rouge/noir des nœuds ?",
      answers: ["Treap", "Arbre de Huffman", "Arbre rouge-noir (ARN)", "Tas binaire"],
      correct: 2,
      explanation: "L'arbre rouge-noir impose des règles de coloration qui garantissent $h \\leq 2 \\log_2(n+1)$. Il est utilisé dans les modules Set et Map d'OCaml."
    },
    {
      question: "Les modules `Set` et `Map` d'OCaml sont implémentés par :",
      answers: [
        "Des tables de hachage",
        "Des arbres rouge-noir (ABR équilibrés)",
        "Des tas binaires",
        "Des listes triées"
      ],
      correct: 1,
      explanation: "OCaml utilise des arbres rouge-noir pour Set et Map, garantissant des opérations en $O(\\log n)$."
    },
    {
      question: "Qu'est-ce qu'un treap (arbretas) ?",
      answers: [
        "Un arbre binaire qui est un ABR sur les éléments et un tas sur des priorités aléatoires",
        "Un arbre rouge-noir randomisé",
        "Un tas dont les éléments sont des arbres",
        "Un ABR stocké dans un tableau"
      ],
      correct: 0,
      explanation: "Le treap combine ABR (sur les clés) et tas min (sur les priorités aléatoires). La hauteur moyenne est $O(\\log n)$ grâce au choix aléatoire."
    },
    {
      question: "Quelle structure de données associe des clés à des valeurs avec ajout, recherche et suppression en $O(1)$ en moyenne ?",
      answers: ["ABR", "Table de hachage", "Tas binaire", "File"],
      correct: 1,
      explanation: "La table de hachage utilise une fonction $h(k)$ pour ranger les éléments. Les collisions sont résolues par chaînage ou adressage ouvert."
    },
    {
      question: "La table de hachage a une complexité en $O(1)$ en moyenne pour ses opérations. Son pire cas est :",
      answers: ["$O(1)$", "$O(\\log n)$", "$O(n)$", "$O(n \\log n)$"],
      correct: 2,
      explanation: "Si toutes les clés entrent en collision (même indice), la recherche parcourt toute la liste chaînée : $O(n)$."
    },
    {
      question: "Quelle structure de données est construite par l'algorithme de Huffman pour obtenir un codage préfixe optimal ?",
      answers: ["ABR", "Tas binaire", "Arbre de Huffman", "Arbre rouge-noir"],
      correct: 2,
      explanation: "L'arbre de Huffman est un arbre binaire dont les feuilles sont les lettres. Le chemin racine→feuille (0/1) donne le code de chaque lettre."
    },
    {
      question: "L'arbre de Huffman garantit que :",
      answers: [
        "Toutes les lettres ont un code de même longueur",
        "Les lettres fréquentes ont un code court et c'est un codage préfixe optimal",
        "L'arbre est toujours parfaitement équilibré",
        "Le décodage nécessite la table de codage complète"
      ],
      correct: 1,
      explanation: "Le codage de Huffman est un codage préfixe (aucun code n'est préfixe d'un autre) qui minimise la longueur moyenne."
    },
    {
      question: "Le module `Hashtbl` d'OCaml implémente :",
      answers: [
        "Un arbre binaire de recherche",
        "Une table de hachage",
        "Un tas binaire",
        "Un arbre rouge-noir"
      ],
      correct: 1,
      explanation: "Hashtbl implémente une table de hachage avec chaînage pour résoudre les collisions."
    },
    {
      question: "Quelle structure de données utilise-t-on pour stocker les sommets visités dans un parcours DFS ou BFS ?",
      answers: [
        "Un tableau de booléens",
        "Un tas binaire",
        "Un arbre de Huffman",
        "Une file de priorité"
      ],
      correct: 0,
      explanation: "Un tableau de booléens `visited` indexé par les sommets permet de vérifier en $O(1)$ si un sommet a déjà été visité."
    },
    {
      question: "L'algorithme de Dijkstra utilise comme structure de données principale :",
      answers: [
        "Une pile",
        "Une file (FIFO)",
        "Une file de priorité (tas min)",
        "Un Union-Find"
      ],
      correct: 2,
      explanation: "Dijkstra extrait à chaque étape le sommet de distance minimale grâce à une file de priorité (tas min)."
    },
    {
      question: "L'algorithme de Kruskal utilise comme structure de données principale :",
      answers: [
        "Une file de priorité",
        "Un Union-Find",
        "Un ABR",
        "Une pile"
      ],
      correct: 1,
      explanation: "Kruskal utilise Union-Find pour tester si une arête relie deux composantes distinctes (find) et les fusionner (union)."
    },
    {
      question: "L'algorithme BFS utilise comme structure de données principale :",
      answers: [
        "Une file (FIFO)"],
      correct: 0,
      explanation: "Le BFS utilise une file pour parcourir les sommets par distance croissante à la source."
    },
    {
      question: "L'algorithme DFS utilise comme structure de données principale :",
      answers: [
        "Une pile (ou la pile d'appels récursifs)"],
      correct: 0,
      explanation: "Le DFS utilise la pile d'appels récursifs (ou une pile explicite en version itérative) pour explorer en profondeur."
    },
    {
      question: "L'algorithme de Huffman utilise comme structure de données principale :",
      answers: [
        "Une file de priorité (tas min)"],
      correct: 0,
      explanation: "Huffman extrait les deux arbres de fréquences minimales à chaque étape, ce qui nécessite une file de priorité."
    },
    {
      question: "Pour implémenter un dictionnaire, on peut utiliser :",
      answers: [
        "Une table de hachage ($O(1)$ en moyenne) ou un ABR équilibré ($O(\\log n)$)",
        "Un tas binaire",
        "Une pile",
        "Un Union-Find"
      ],
      correct: 0,
      explanation: "Les deux implémentations classiques d'un dictionnaire sont la table de hachage (Hashtbl) et l'ABR équilibré (Map)."
    },
    {
      question: "Un arbre binaire presque complet dont chaque nœud est supérieur ou égal à ses fils est :",
      answers: ["Un ABR", "Un tas max", "Un arbre rouge-noir", "Un arbre de Huffman"],
      correct: 1,
      explanation: "C'est la définition d'un tas max : arbre presque complet + propriété de tas (nœud ≥ fils)."
    },
    {
      question: "Le parcours infixe d'un ABR donne :",
      answers: [
        "Les éléments dans un ordre aléatoire",
        "Les éléments triés par ordre croissant",
        "Les éléments par niveau (largeur)",
        "Uniquement les feuilles"
      ],
      correct: 1,
      explanation: "La propriété ABR (gauche ≤ racine ≤ droite) implique que le parcours infixe visite les éléments dans l'ordre croissant."
    },
    {
      question: "Dans un tas binaire stocké dans un tableau, les fils du nœud à l'indice $i$ sont aux indices :",
      answers: ["$i-1$ et $i+1$", "$2i+1$ et $2i+2$", "$i/2$ et $i/2+1$", "$i^2$ et $i^2+1$"],
      correct: 1,
      explanation: "Dans un tas stocké dans un tableau (à partir de l'indice 0), les fils de $a[i]$ sont $a[2i+1]$ et $a[2i+2]$. Le père de $a[j]$ est $a[\\lfloor(j-1)/2\\rfloor]$."
    },
    {
      question: "La compression de chemins dans Union-Find consiste à :",
      answers: [
        "Trier les éléments de chaque classe",
        "Rattacher tous les nœuds du chemin directement à la racine lors d'un `find`",
        "Fusionner les deux plus petites classes",
        "Doubler la taille du tableau interne"
      ],
      correct: 1,
      explanation: "Lors d'un find, la compression de chemins rattache chaque nœud traversé directement à la racine, aplatissant l'arbre pour les requêtes futures."
    },
    {
      question: "La construction d'un tas à partir d'un tableau de $n$ éléments par la méthode bottom-up (down depuis les nœuds internes) a une complexité de :",
      answers: ["$O(n \\log n)$", "$O(n^2)$", "$O(n)$", "$O(\\log n)$"],
      correct: 2,
      explanation: "La méthode bottom-up applique down sur chaque nœud interne, du dernier au premier. La somme des hauteurs donne $O(n)$."
    }
  ]}
/>
