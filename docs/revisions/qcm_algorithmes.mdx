---
hide_title: true
title: "QCM Révisions"
sidebar_position: 1
---

import QCMRandom from "@site/src/components/QCMRandom";

<QCMRandom
  title="QCM Révisions"
  questions={[
    /*{
      question:
        "Quel algorithme est une variante de Dijkstra utilisant une heuristique $h(v)$ estimant la distance restante au sommet cible pour explorer en priorité les sommets les plus prometteurs ?",
      answers: ["Bellman-Ford", "Kruskal", "A*", "LZW"],
      correct: 2,
      explanation:
        "A* utilise une heuristique pour guider la recherche vers le sommet cible plus efficacement que Dijkstra.",
    },
    {
      question: "L'algorithme A* permet de :",
      answers: [
        "Trouver un plus court chemin entre deux sommets en utilisant une heuristique",
        "Calculer les composantes connexes d'un graphe",
        "Trouver un arbre couvrant de poids minimum",
        "Partitionner des données en classes",
      ],
      correct: 0,
      explanation:
        "A* combine le coût réel du chemin avec une heuristique estimant le coût restant pour guider efficacement la recherche.",
    },
    {
      question:
        "Lesquels de ces algorithmes utilisent la programmation dynamique (ou mémoïsation) ?",
      answers: [
        "Boyer-Moore",
        "Calcul des attracteurs",
        "Quine",
        "Floyd-Warshall",
      ],
      correct: [1, 3],
      explanation:
        "Dans le calcul des attracteurs, pour éviter de calculer plusieurs fois le même sommet. Dans Floyd-Warshall, avec une équation de récurrence.",
    },
    {
      question: "L'algorithme de Floyd-Warshall sur un graphe à $n$ sommets :",
      answers: [
        "Utilise une récurrence sur le nombre de sommets utilisable dans un plus court chemin",
        "Utilise une récurrence sur la longueur d'un plus court chemin",
        "Est en O($n^3$)",
        "Est en O($n\log(n)$)",
      ],
      correct: [0, 2],
      explanation:
        "Floyd-Warshall résout en $O(n^3)$ (3 boucles) le problème des plus courts chemins entre toutes les paires de sommets en calculant la distance $d_k(u, v)$ de $u$ à $v$ utilisant les sommets $1, ..., k$.",
    },
    {
      question:
        "Quel algorithme trouve les composantes fortement connexes d'un graphe orienté en effectuant deux parcours en profondeur (un sur le graphe et un sur le graphe transposé) ?",
      answers: ["Kruskal", "Dijkstra", "Kosaraju", "Prim"],
      correct: 2,
      explanation:
        "Kosaraju effectue un premier parcours en profondeur pour obtenir un ordre de traitement, puis un second parcours en profondeur sur le graphe transposé.",
    },
    {
      question: "L'algorithme de Kosaraju permet de :",
      answers: [
        "Trouver un arbre couvrant de poids minimum",
        "Calculer un couplage maximum",
        "Trouver les composantes fortement connexes",
        "Calculer les plus courts chemins",
      ],
      correct: 2,
      explanation:
        "Kosaraju identifie les composantes fortement connexes en utilisant deux parcours en profondeur.",
    },
    {
      question: "Quel algorithme utilise la structure d'Union-Find ?",
      answers: ["Prim", "Dijkstra", "Kruskal", "Kosaraju"],
      correct: 2,
      explanation:
        "Kruskal trie les arêtes puis les ajoute une par une si elles ne créent pas de cycle, en utilisant Union-Find.",
    },
    {
      question:
        "La complexité de l'algorithme de Kruskal avec Union-Find sur un graphe à $n$ sommets et $p$ arêtes est :",
      answers: ["$O(np)$", "$O(p \\log p)$", "$O(np \\log p)$", "$O(n + p)$"],
      correct: 1,
      explanation:
        "Le tri des arêtes coûte $O(p \\log p)$ ($= O(p \\log n)$). Les opérations Union-Find ont une complexité amortie quasi-constante grâce à l'union par rang et la compression de chemins.",
    },
    {
      question: "Quel algorithme utilise des chemins augmentants ?",
      answers: [
        "Kruskal",
        "Recherche de couplage maximum",
        "Kosaraju",
        "Bellman-Ford",
      ],
      correct: 1,
      explanation:
        "L'algorithme cherche des chemins augmentants et applique la différence symétrique avec le couplage courant pour l'agrandir.",
    },
    {
      question:
        "Un couplage $M$ dans un graphe $G = (S, A)$ est maximum si et seulement si :",
      answers: [
        "Il n'y a pas de chemin alternant pour $M$",
        "Il n'y a pas de chemin augmentant pour $M$",
        "$\\forall e\\in A$, $M\\cup\\{e\\}$ n'est pas un couplage",
        "Tous les sommets de $G$ sont couverts par $M$",
      ],
      correct: 1,
      explanation:
        "Par définition, $M$ est maximum s'il n'y a pas de couplage de cardinal supérieur (contenant plus d'arêtes). Si $C$ est un chemin augmentant, $M\\Delta C$ est un couplage de cardinal supérieur à $M$.",
    },
    {
      question:
        "Quel est l'algorithme le plus efficace pour trouver des plus courts chemins depuis un sommet fixé dans un graphe non pondéré ?",
      answers: [
        "Parcours en largeur",
        "Dijkstra",
        "Parcours en profondeur",
        "A*",
      ],
      correct: 0,
      explanation:
        "Le parcours en largeur visite les sommets par distance croissante (en nombre d'arêtes) depuis un sommet de départ.",
    },
    {
      question: "Quels algorithmes utilisent une file ?",
      answers: [
        "Parcours en profondeur",
        "Parcours en largeur",
        "Huffman",
        "LZW",
      ],
      correct: [1],
      explanation:
        "Le parcours en largeur utilise une file pour explorer les sommets couche par couche. Huffman utilise une file de priorité. LZW un dictionnaire. Le parcours en profondeur peut utiliser une pile.",
    },
    {
      question: "Un parcours en profondeur peut être utilisé pour :",
      answers: [
        "L'algorithme min-max",
        "Trouver un arbre couvrant",
        "Détecter un cycle dans un graphe orienté",
        "Trouver un tri topologique",
      ],
      correct: [0, 1, 2, 3],
      explanation:
        "On peut parcourir l'arbre min-max en profondeur. L'ensemble des arêtes parcourues forme un arbre couvrant. On peut tester l'existence d'un arc arrière pour détecter un cycle. L'algorithme de Kosaraju utilise deux DFS.",
    },
    {
      question:
        "Quel type d'algorithme probabiliste renvoie toujours un résultat correct mais avec un temps d'exécution variable ?",
      answers: ["Monaco", "Monte-Carlo", "Las Vegas", "Los Angeles"],
      correct: 2,
      explanation:
        "Un algorithme de Las Vegas est toujours correct mais son temps d'exécution est aléatoire. Exemple : tri rapide randomisé.",
    },
    {
      question: "Un algorithme de Las Vegas est un algorithme qui :",
      answers: [
        "Peut renvoyer un résultat incorrect mais s'exécute en temps déterministe",
        "Renvoie toujours un résultat correct mais avec un temps d'exécution aléatoire",
        "Garantit un facteur d'approximation constant mais s'exécute en temps déterministe",
        "Donne un facteur d'approximation variable mais avec un temps d'exécution aléatoire",
      ],
      correct: 1,
      explanation:
        "Las Vegas = toujours correct, temps variable. Exemple : quicksort randomisé.",
    },
    {
      question:
        "Quels algorithmes permettent d'explorer seulement une partie du graphe des configurations ?",
      answers: [
        "Calcul des attracteurs",
        "Branch-and-bound",
        "Alpha-beta",
        "Quine",
      ],
      correct: [1, 2, 3],
      explanation:
        "Le calcul des attracteurs est optimal mais explore toutes les configurations. Branch-and-bound coupe les branches dont l'heuristique est moins bonne que la meilleure solution trouvée. Alpha-beta coupe les branches en dehors de l'intervalle $\\alpha \\leq \\beta$. Quine s'implifie la formule pour éviter de parcourir toutes les valuations.",
    },
    {
      question: "Quels sont les algorithmes de classification supervisée ?",
      answers: [
        "$k$-moyennes",
        "ID3",
        "k plus proches voisins",
        "Classification hiérarchique ascendante",
      ],
      correct: [1, 2],
      explanation:
        "$k$-moyennes et classification hiérarchique ascendante sont non-supervisés (pas de donnée d'entraînement).",
    },
    {
      question: "Un arbre $k$-dimensionnel :",
      answers: [
        "Permet de trouver efficacement des plus proches voisins",
        "Permet de classifier des données",
        "Est un arbre binaire de recherche",
        "Est un arbre équilibré",
      ],
      correct: [0, 2],
      explanation:
        "Un arbre $k$-dimensionnel est obtenu en divisant récursivement en deux (suivant un axe) des points dans $\mathbb{R}^k$. Il peut être utilisé dans l'algorithme KNN.",
    },
    {
      question: "Dans l'algorithme des $k$-moyennes, $k$ désigne :",
      answers: [
        "Le nombre de voisins",
        "Le nombre de classes",
        "Le nombre de données",
        "La dimension de l'espace",
      ],
      correct: 1,
      explanation:
        "L'algorithme des $k$-moyennes est un algorithme de classification non supervisé qui partitionne les données en essayant de minimiser la distance aux centres des classes.",
    },
    {
      question:
        "Quel algorithme de classification non supervisée fusionne itérativement les deux classes les plus proches, en partant d'une classe par donnée ?",
      answers: [
        "$k$-moyennes",
        "$k$ plus proches voisins",
        "Classification hiérarchique ascendante",
        "ID3",
      ],
      correct: 2,
      explanation:
        "CHA construit une hiérarchie de classes en fusionnant les plus proches à chaque étape.",
    },
    {
      question: "La classification hiérarchique ascendante :",
      answers: [
        "Prédit la classe d'une donnée à partir de ses voisins",
        "Fusionne itérativement les classes les plus proches",
        "Construit un arbre de décision par gain d'information",
        "Met à jour alternativement classes et centres",
      ],
      correct: 1,
      explanation:
        "CHA part de $n$ classes (une par donnée) et fusionne les deux plus proches à chaque étape.",
    },
    {
      question:
        "Quel algorithme de classification supervisée construit un arbre de décision en choisissant à chaque nœud l'attribut maximisant le gain d'information ?",
      answers: ["KNN", "$k$-moyennes", "CHA", "ID3"],
      correct: 3,
      explanation:
        "ID3 construit un arbre de décision de manière gloutonne en maximisant le gain d'entropie à chaque nœud.",
    },
    {
      question:
        "Quel algorithme construit un automate reconnaissant le langage d'une expression régulière en linéarisant l'expression ?",
      answers: ["Automate produit", "Berry-Sethi", "Kleene", "Thompson"],
      correct: 1,
      explanation:
        "Berry-Sethi linéarise l'expression régulière et construit un automate local reconnaissant le même langage.",
    },
    {
      question: "Les langages réguliers sont stables par :",
      answers: ["Complémentaire", "Différence", "Intersection", "Inclusion"],
      correct: [0, 1, 2],
      explanation:
        "Complémentaire : déterminiser l'automate puis inverser états initiaux et finaux. Différence et intersection : automate produit. Inclusion : faux car tout langage contient $\\emptyset$ et est inclus dans $\\Sigma^*$.",
    },
    {
      question: "Lesquels de ces langages sont réguliers ?",
      answers: [
        "$\\{a^n b^p | n, p \\in \\mathbb{N}\\}$",
        "$\\{a^n b^n | n \\in \\mathbb{N}\\}$",
        "$\\{a^n b^p | n = p \\mod 3\\}$",
        "$\\{a^n b^p | n < p\\}$",
      ],
      correct: [0, 2],
      explanation:
        "Le premier est $a^* b^*$. Le 3ème est reconnu par un automate produit à $4$ états où on arrive sur l'état $(x, y)$ si le nombre de $a$ (resp. $b$) est égal à $x$ (resp. $y$). Le 2ème et 4ème ne sont pas régulier par le lemme de l'étoile.",
    },*/
    {
      question:
        "Quel est le nombre d'arêtes d'un graphe complet non-orienté à $n$ sommets ?",
      answers: ["$n!$", "$n^2$", "$n - 1$", "$\\frac{n(n-1)}{2}$"],
      correct: 3,
      explanation:
        "Un graphe complet non orienté à $n$ sommets a une arête entre chaque paire de sommets, soit $\\binom{n}{2} = \\frac{n(n-1)}{2}$ arêtes.",
    },
    {
      question:
        "Quel algorithme d'exclusion mutuelle pour deux threads utilise un tableau `want` et une variable `turn` ?",
      answers: ["Boulangerie de Lamport", "Dekker", "Peterson", "Dijkstra"],
      correct: 2,
      explanation:
        "Peterson utilise deux variables want (indiquant le souhait d'entrer en section critique) et turn (cédant la priorité).",
    },
    {
      question: "L'algorithme de la boulangerie de Lamport :",
      answers: [
        "Implémente un mutex pour $n$ threads",
        "Implémente un sémaphore pour $n$ threads",
        "Utilise un tableau `want` et une variable `turn`",
        "Utilise un système de tickets pour gérer l'accès à la section critique",
      ],
      correct: [0, 3],
      explanation:
        "Lamport généralise l'exclusion mutuelle à $n$ threads avec un mécanisme de prise de ticket.",
    },
    {
      question: "La programmation dynamique :",
      answers: [
        "Diviser le problème en sous-problèmes indépendants",
        "Choisit localement le meilleur choix à chaque étape",
        "Utilise une relation de récurrence",
        "Stocke les résultats intermédiaires",
      ],
      correct: [2, 3],
      explanation:
        "La programmation dynamique utilise une relation de récurrence et du stockage (mémoïsation ou tableau) pour éviter les calculs redondants.",
    },
    {
      question:
        "Quel algorithme glouton de compression construit un arbre binaire optimal où les lettres fréquentes ont un code court ?",
      answers: ["LZW", "Rabin-Karp", "Huffman", "Boyer-Moore-Horspool"],
      correct: 2,
      explanation:
        "Huffman construit un arbre de codage préfixe optimal en fusionnant les deux symboles les moins fréquents à chaque étape.",
    },
    {
      question:
        "Quel algorithme de compression en ligne construit un dictionnaire de motifs au fur et à mesure de la lecture du texte ?",
      answers: [
        "Huffman",
        "Rabin-Karp",
        "Boyer-Moore-Horspool",
        "LZW (Lempel-Ziv-Welch)",
      ],
      correct: 3,
      explanation:
        "LZW construit dynamiquement un dictionnaire et remplace les motifs déjà vus par des codes plus courts.",
    },
    {
      question:
        "Quel algorithme de recherche de motif dans un texte utilise une fonction de hachage glissante (rolling hash) ?",
      answers: ["Boyer-Moore-Horspool", "Huffman", "Rabin-Karp", "LZW"],
      correct: 2,
      explanation:
        "Rabin-Karp utilise un hash glissant pour comparer le motif à chaque fenêtre du texte en $O(n)$ en moyenne.",
    },
    {
      question:
        "Quel algorithme de recherche de motif compare les caractères de droite à gauche et utilise une table de décalage précalculée ?",
      answers: ["Rabin-Karp", "Boyer-Moore-Horspool", "Huffman", "KMP"],
      correct: 1,
      explanation:
        "Boyer-Moore-Horspool compare de droite à gauche et saute des positions grâce à une table de décalage.",
    },
    {
      question:
        "Quel algorithme résout le problème SAT par backtracking en affectant les variables et en simplifiant les clauses à chaque étape ?",
      answers: [
        "Branch-and-bound",
        "Alpha-beta",
        "Quine",
        "Calcul des attracteurs",
      ],
      correct: 2,
      explanation:
        "L'algorithme de Quine affecte chaque variable à vrai ou faux et simplifie les clauses à chaque étape par backtracking.",
    },
    {
      question: "L'élagage alpha-bêta est une variante de min-max qui :",
      answers: [
        "Explore en priorité les branches d'heuristique la plus prometteuses",
        "Coupe les branches qui ne peuvent pas influencer le résultat final",
        "Parcourt toutes les configurations du jeu",
        "Mémorise les résultats intermédiaires pour éviter les calculs redondants",
      ],
      correct: 1,
      explanation:
        "Alpha-bêta élague les branches inutiles de l'arbre de jeu en maintenant des bornes $\\alpha$ et $\\beta$.",
    },
    {
      question:
        "Quelles sont les implémentations efficaces d'une file de priorité ?",
      answers: [
        "Arbre binaire de recherche",
        "Arbre $k$-dimensionnel",
        "Tas",
        "Table de hachage",
      ],
      correct: [0, 2],
      explanation:
        "Un tas binaire est un arbre binaire presque complet implémenté par un tableau, avec insertion et extraction du minimum en $O(\\log n)$. On peut aussi utiliser un ABR (équilibré éventuellement) en cherchant le minimum tout à gauche",
    },
    {
      question:
        "Soit $a = N(g, r, d)$ un arbre. $a$ est un arbre binaire de recherche (ABR) si et seulement si :",
      answers: [
        "Les étiquettes de $g$ sont inférieures à $r$ et celles de $d$ supérieures à $r$",
        "La racine de $g$ est inférieure à $r$ et celle de $d$ supérieure à $r$",
        "Le parcours préfixe de $a$ est trié par ordre croissant",
        "Le parcours infixe de $a$ est trié par ordre croissant",
      ],
      correct: 3,
      explanation:
        "Un arbre est un ABR si et seulement si son parcours infixe donne les éléments triés par ordre croissant. La 1ère condition sur les étiquettes de $g$ et $d$ n'est pas suffisante pour garantir la propriété ABR, elle doit être vérifiée pour tous les nœuds du sous-arbre.",
    },
    {
      question: "Quels algorithmes du cours utilisent une file de priorité ?",
      answers: [
        "Dijkstra",
        "A*",
        "Tri par tas (heapsort)",
        "Huffman",
        "BFS",
        "Floyd-Warshall",
        "Kruskal",
        "KNN",
      ],
      correct: [0, 1, 2, 3],
      explanation:
        "Le tas (file de priorité) est utilisé par Dijkstra et A* pour extraire le sommet le plus proche, par le tri par tas (heapsort), et par Huffman pour fusionner les arbres de fréquences minimales.",
    },
    {
      question: "Quelles sont des applications possibles d'Union-Find ?",
      answers: [
        "Gestion de classes d'équivalence",
        "Prim",
        "Kruskal",
        "Tester la connexité d'un graphe",
      ],
      correct: 2,
      explanation:
        "Union-Find stocke une partition dans un tableau de pères. Il est utilisé par Kruskal pour vérifier si une arête relie deux composantes distinctes (find) et pour les fusionner (union). On peut aussi l'utiliser pour gérer des classes d'équivalence ou tester la connexité d'un graphe en vérifiant que tous les sommets sont dans la même classe.",
    },
    {
      question: "Le lemme de l'étoile :",
      answers: [
        "Permet de choisir la décomposition $u = xyz$",
        "S'applique aux langages hors-contextes",
        "Permet de prouver qu'un langage n'est pas régulier",
        "Permet de prouver qu'un langage est régulier",
      ],
      correct: 2,
      explanation:
        "Le lemme de l'étoile est utilisé par l'absurde pour prouver qu'un langage n'est pas régulier. La réciproque est fausse donc on ne peut pas prouver qu'un langage est régulier avec ce lemme. Il est faux pour les langages hors-contextes généraux, qui ont un lemme de l'étoile différent (avec $u = vwx$ et $|vx| > 0$).",
    },
    {
      question: "Tout automate est équivalent à :",
      answers: [
        "Une expression régulière",
        "Un automate déterministe",
        "Un automate émondé (dont tous les états sont accessibles et co-accessibles)",
        "Un automate local",
        "Un automate sans $\\epsilon$-transition",
      ],
      correct: [0, 1, 2, 4],
      explanation:
        "Tout automate est équivalent à une expression régulière par le théorème de Kleene. Tout automate est équivalent à un automate déterministe par déterminisation. Tout automate est équivalent à un automate émondé en supprimant les états inaccessibles ou non co-accessibles. Seuls les langages locaux sont reconnus par des automates locaux.",
    },
    {
      question: "L'algorithme d'élimination des états :",
      answers: [
        "Permet d'obtenir un automate minimal",
        "Permet d'obtenir une expression régulière",
        "Permet d'obtenir un automate émondé (dont tous les états sont accessibles et co-accessibles)",
        "Permet d'obtenir un automate local",
      ],
      correct: 1,
      explanation:
        "L'algorithme d'élimination des états permet de transformer un automate en une expression régulière équivalente en éliminant les états un par un et en mettant à jour les transitions avec des expressions régulières.",
    },
    {
      question:
        "Quelle est la structure de donnée utilisée dans le cours pour représenter un tas ?",
      answers: [
        "Tableau `T` où `T[i]` est le père de `T[2i+1]` et `T[2i+2]`",
        "Tableau `T` où `T[i]` est le père de `i`",
        "Type OCaml `type 'a arb = Empty | Node of 'a * 'a arb * 'a arb`",
        "Dictionnaire associant à chaque sommet la liste de ses fils",
      ],
      correct: 0,
      explanation:
        "Un tas binaire est un arbre binaire presque complet, qui peut être représenté par un tableau `T` où `T[i]` est le père de `T[2i+1]` et `T[2i+2]`. Le père de `T[j]` est `T[⌊(j-1)/2⌋]`.\\n Remarque : on peut aussi définir un tas persistant (skew heap).",
    },
    {
      question:
        "Quelle est la structure de donnée utilisée pour représenter un Union-Find ?",
      answers: [
        "Tableau `T` où `T[i]` est le père de `T[2i+1]` et `T[2i+2]`",
        "Tableau `T` où `T[i]` est le père de `i`",
        "Type OCaml `type 'a arb = Empty | Node of 'a * 'a arb * 'a arb`",
        "Dictionnaire associant à chaque sommet la liste de ses fils",
      ],
      correct: 1,
      explanation:
        "Union-Find est représenté par un tableau `T` où `T[i]` est le père de `i`. Les éléments d'une même classe d'équivalence forment un arbre dont la racine est un représentant de la classe.",
    },
    {
      question: "Quel est le nombre d'arêtes d'un arbre à $n$ sommets ?",
      answers: ["$n-1$", "$n$", "$2n-1$", "$2n$"],
      correct: 0,
      explanation: "Un arbre à $n$ sommets a toujours $n-1$ arêtes.",
    },
    {
      question:
        "Quelles structures de données permettent d'implémenter un dictionnaire ?",
      answers: ["ABR", "Table de hachage", "Tas binaire", "File"],
      correct: [0, 1],
      explanation:
        "On peut utiliser un ABR dont les étiquettes sont des couples (clé, valeur), avec des opérations O($h$). On peut aussi utiliser une table de hachage avec du O(1) en moyenne.",
    },
    {
      question: "L'arbre de Huffman garantit que :",
      answers: [
        "Toutes les lettres ont un code de même longueur",
        "Les lettres fréquentes ont un code court et c'est une compression préfixe optimale",
        "L'arbre est équilibré",
        "Le décodage nécessite la table de codage complète",
      ],
      correct: 1,
      explanation:
        "Le codage de Huffman est un codage préfixe (aucun code n'est préfixe d'un autre) qui minimise la longueur moyenne.",
    },
    {
      question: "Pour implémenter un dictionnaire, on peut utiliser :",
      answers: [
        "Un arbre binaire de recherche",
        "Un tas binaire",
        "Une table de hachage",
        "Un Union-Find",
      ],
      correct: [0, 2],
      explanation:
        "Les deux implémentations classiques d'un dictionnaire sont la table de hachage (Hashtbl) et l'ABR équilibré (Map).",
    },
    {
      question:
        "Un arbre binaire presque complet dont chaque nœud est supérieur ou égal à ses fils est :",
      answers: [
        "Un arbre binaire de recherche",
        "Un tas max",
        "Un arbre min-max",
        "Un arbre de Huffman",
      ],
      correct: 1,
      explanation:
        "C'est la définition d'un tas max : arbre presque complet + propriété de tas (nœud ≥ fils).",
    },
    {
      question:
        "Dans un tas binaire stocké dans un tableau, les fils du nœud à l'indice $i$ sont aux indices :",
      answers: [
        "$i-1$ et $i+1$",
        "$2i+1$ et $2i+2$",
        "$i/2$ et $i/2+1$",
        "$i^2$ et $i^2+1$",
      ],
      correct: 1,
      explanation:
        "Dans un tas stocké dans un tableau (à partir de l'indice 0), les fils de $a[i]$ sont $a[2i+1]$ et $a[2i+2]$. Le père de $a[j]$ est $a[\\lfloor(j-1)/2\\rfloor]$.",
    },
    {
      question: "La compression de chemins dans Union-Find consiste à :",
      answers: [
        "Trier les éléments de chaque classe",
        "Rattacher tous les nœuds du chemin directement à la racine lors d'un `find`",
        "Fusionner les deux plus petites classes",
        "Doubler la taille du tableau interne",
      ],
      correct: 1,
      explanation:
        "Lors d'un find, la compression de chemins rattache chaque nœud traversé directement à la racine, aplatissant l'arbre pour les requêtes futures.",
    },
    {
      question:
        "Dans un arbre binaire strict (chaque nœud a soit 0 soit 2 fils) avec $f$ feuilles et $n_i$ nœuds internes (non feuilles) :",
      answers: ["$f = n_i$", "$f = n_i + 1$", "$f = 2n_i$", "$f = 2n_i + 1$"],
      correct: 1,
      explanation: "Par induction structurelle.",
    },
    {
      question: "Dans un arbre binaire de hauteur $h$ et à $n$ nœuds :",
      answers: [
        "$n \\leq 2^h - 1$",
        "$n \\leq 2^{h+1} - 1$",
        "$n \\geq h$",
        "$n \\geq h + 1$",
      ],
      correct: [1, 3],
      explanation:
        "Il y a entre $1$ et $2^p$ nœuds à la profondeur $p$, qu'on peut sommer.",
    },
    {
      question: "Si $\\Pi_1 \\leq_p \\Pi_2$ alors :",
      answers: [
        "Si $\\Pi_1 \\in$ P alors $\\Pi_2 \\in$ P",
        "Si $\\Pi_2 \\in$ P alors $\\Pi_1 \\in$ P",
        "Si $\\Pi_1 \\in$ NP alors $\\Pi_2 \\in$ NP",
        "Si $\\Pi_2 \\in$ NP alors $\\Pi_1 \\in$ NP",
        "Si $\\Pi_2\\in$ NP et $\\Pi_1$ est NP-complet alors $\\Pi_2$ est NP-complet",
        "Si $\\Pi_1\\in$ NP et $\\Pi_2$ est NP-complet alors $\\Pi_1$ est NP-complet",
      ],
      correct: [1, 3, 5],
      explanation:
        "Soit $\\phi$ une réduction de $\\Pi_1$ à $\\Pi_2$. Si $\\Pi_2 \\in P$, alors $\\Pi_1$ est dans $P$ car on peut résoudre $\\Pi_1$ en résolvant $\\Pi_2$ sur l'instance transformée. De même pour NP. Si $\\Pi_2$ est NP-complet et $\\Pi_1 \\in NP$, alors $\\Pi_1$ est NP-complet par transitivité.",
    },
    {
      question: "Un problème est décidable si :",
      answers: [
        "Il peut être résolu en temps polynomial",
        "Il existe un algorithme qui termine toujours et répond correctement",
        "Il appartient à $NP$",
        "Il peut être vérifié en temps polynomial",
      ],
      correct: 1,
      explanation:
        "Un problème est décidable s'il existe un algorithme (machine de Turing) qui termine toujours et donne la bonne réponse.",
    },
    {
      question: "Quelle relation est vraie concernant $P$ et $NP$ ?",
      answers: [
        "$P = NP$",
        "$P \\subset NP$",
        "$NP \\subset P$",
        "$P$ et $NP$ sont disjoints",
      ],
      correct: 1,
      explanation:
        "On sait que $P \\subset NP$ car un problème résoluble en temps polynomial peut évidemment être vérifié en temps polynomial. La question $P = NP$ reste ouverte.",
    },
    {
      question: "Quels sont les problèmes NP-complets ?",
      answers: [
        "`SAT`",
        "`2-SAT`",
        "`3-SAT`",
        "Couplage maximum",
        "Clique maximum",
        "Arbre couvrant de poids maximum",
        "Chemin de poids maximum",
      ],
      correct: [0, 2, 4, 6],
      explanation:
        "`SAT` est est NP-complet d'après le théorème de Cook-Levin. `2-SAT` $\\in$ P. `3-SAT` est NP-complet par réduction depuis `SAT`. Couplage maximum $\\in$ P (algorithme des chemins augmentants pour graphe biparti et algorithme hongrois dans le cas général). Clique maximum est NP-complet par réduction depuis `SAT` (ou `STABLE` comme dans le cours). Un arbre couvrant de poids max peut être trouvé en triant les arêtes par poids décroissant dans Kruskal. Chemin de poids maximum est NP-complet par réduction depuis `HAMILTONIEN`.",
    },
    {
      question:
        "Si $\\Pi$ est un problème de décision, on note $\\bar{\\Pi}$ le problème de décision qui à une instance de $\\Pi$ répond `oui` si et seulement si $\\Pi$ répond `non` sur cette instance.",
      answers: ["$\\Pi \\in$ P $\\Longleftrightarrow \\bar{\\Pi} \\in$ P"],
      correct: [0],
      explanation:
        "`SAT` est est NP-complet d'après le théorème de Cook-Levin. `2-SAT` $\\in$ P. `3-SAT` est NP-complet par réduction depuis `SAT`. Couplage maximum $\\in$ P (algorithme des chemins augmentants pour graphe biparti et algorithme hongrois dans le cas général). Clique maximum est NP-complet par réduction depuis `SAT` (ou `STABLE` comme dans le cours). Un arbre couvrant de poids max peut être trouvé en triant les arêtes par poids décroissant dans Kruskal. Chemin de poids maximum est NP-complet par réduction depuis `HAMILTONIEN`.",
    },
    {
      question:
        "On note $\\phi \\equiv \\psi$ lorsque $\\phi$ et $\\psi$ ont les mêmes valuations positives. Lesquelles de ces identités sont vraies ?",
      answers: [
        "$\\lnot \\lnot \\varphi \\equiv \\varphi$",
        "$\\varphi_1 \\lor (\\varphi_2 \\land \\varphi_3) \\equiv (\\varphi_1 \\lor \\varphi_2) \\land (\\varphi_1 \\lor \\varphi_3)$",
        "$\\varphi_1 \\land (\\varphi_2 \\lor \\varphi_3) \\equiv (\\varphi_1 \\land \\varphi_2) \\lor (\\varphi_1 \\land \\varphi_3)$",
        "$\\varphi_1 \\longrightarrow \\varphi_2 \\equiv \\lnot \\varphi_2 \\longrightarrow \\lnot \\varphi_1$",
        "$\\lnot(\\varphi_1 \\land \\varphi_2) \\equiv \\lnot \\varphi_1 \\lor \\lnot \\varphi_2$",
        "$\\lnot(\\varphi_1 \\lor \\varphi_2) \\equiv \\lnot \\varphi_1 \\land \\lnot \\varphi_2$",
      ],
      correct: [0, 1, 2, 3, 4, 5],
      explanation:
        "Par table de vérité ou utilisation de la définition de l'évaluation d'une formule.",
    },
    {
      question: "$\\Pi_1$ se réduit à $\\Pi_2$ est équivalent à :",
      answers: [
        "$\\Pi_2 \\leq \\Pi_1$",
        "Il existe une fonction de réduction de $\\Pi_1$ à $\\Pi_2$",
        "$\\Pi_1$ indécidable $\\Rightarrow \\Pi_2$ indécidable",
      ],
      correct: [1, 2],
      explanation:
        "$\\Pi_1 \\leq_p \\Pi_2$ signifie que $\\Pi_1$ se réduit à $\\Pi_2$, c'est-à-dire qu'il existe une fonction de réduction de $\\Pi_1$ à $\\Pi_2$. Par conséquent, si $\\Pi_1$ est indécidable, alors $\\Pi_2$ doit également être indécidable, car sinon on pourrait résoudre $\\Pi_1$ en utilisant la réduction vers $\\Pi_2$.",
    },
    {
      question:
        "Le lemme de l'étoile sur un langage régulier $L$ commence ainsi :",
      answers: [
        "$\\forall u \\in L, \\exists n \\in \\mathbb{N}, |u| \\geq n \\Rightarrow \\exists x, y, z \\in \\Sigma^*, u = xyz, |xy| \\leq n, |y| > 0$",
        "$\\exists n \\in \\mathbb{N}, \\forall u \\in L, |u| \\geq n \\Rightarrow \\exists x, y, z \\in \\Sigma^*, u = xyz, |xy| \\leq n, |y| > 0$",
        "$\\forall u \\in L, \\exists n \\in \\mathbb{N}, |u| \\geq n \\Rightarrow \\forall x, y, z \\in \\Sigma^*, u = xyz, |xy| \\leq n, |y| > 0$",
        "$\\exists n \\in \\mathbb{N}, \\forall u \\in L, |u| \\geq n \\Rightarrow \\forall x, y, z \\in \\Sigma^*, u = xyz, |xy| \\leq n, |y| > 0$",
      ],
      correct: 1,
      explanation:
        "En cas de doute, revenir à la démonstration du lemme de l'étoile.",
    },
  ]}
/>
